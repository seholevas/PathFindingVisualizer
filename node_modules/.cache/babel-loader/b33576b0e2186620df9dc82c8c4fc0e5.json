{"ast":null,"code":"import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\"; // import { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\n\nimport { PriorityQueue } from \"../data-structures/priority-queue\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\"; // import { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\n\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nexport default function* aStar(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations = {}, walls = {}, weights = {}) {\n  let found = false;\n  let start_coordinates = [...start];\n  let end_coordinates = [...end];\n  var priority_queue = new PriorityQueue(); // let additional_dest = Object.assign({}, additional_destinations);\n\n  let visited_coordinates = [];\n  let path = [];\n  let parent_matrix = shallowCopy(matrix, null);\n  let visited = shallowCopy(matrix, false);\n  let distance_matrix = shallowCopy(matrix, Infinity);\n  distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n  priority_queue.enqueue([...start_coordinates], manhattanDistance(start_coordinates, end_coordinates));\n\n  while (!priority_queue.isEmpty() && !found) {\n    let q_item = priority_queue.dequeue(); // let f_cost = tuple[0];\n\n    let current_coordinates = q_item.element;\n    updatetoVisited(current_coordinates, visited);\n    visited_coordinates.push(current_coordinates);\n\n    if (Object.keys(additional_destinations).length !== 0) {\n      let keys = Object.keys(additional_destinations);\n      let next_dest = additional_destinations[keys[0]];\n      console.log(additional_destinations[keys[0]]);\n      delete additional_destinations[keys[0]];\n      let new_path = aStar(matrix, current_coordinates, next_dest, additional_destinations, walls, weights);\n      let add_to_visited_nodes = new_path.next().value;\n      let add_shortest_path = new_path.next().value;\n      visited_coordinates = visited_coordinates.concat(add_to_visited_nodes); // if (add_shortest_path === undefined)\n      //     break;\n\n      path = path.concat(add_shortest_path);\n      console.log(path);\n      current_coordinates = [...next_dest];\n      end_coordinates = [...end]; // end_coordinates = current_coordinates;\n      // found = true;\n    }\n\n    if (current_coordinates[0] === end_coordinates[0] && current_coordinates[1] === end_coordinates[1] && Object.keys(additional_destinations).length === 0) {\n      found = true;\n    } // yield [...current_coordinates];\n    // if(coordinatesAreEqual(current_coordinates,end_coordinates))\n    // {\n    //     break;\n    // }\n\n\n    const generator = checkNeighbors(current_coordinates, visited);\n    let result = generator.next();\n\n    while (!result.done && !found) {\n      let neighbor_coordinates = result.value;\n      let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]]; // EDIT: needs to change once weight and walls are added in.\n\n      let cost_from_current_node = calculateWeight(distance_matrix[current_coordinates[0]][current_coordinates[1]], neighbor_coordinates, weights);\n      let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates); // cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates) \n\n      let is_current_cost_less = f_cost < distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]];\n      let is_neighbor_in_priority_queue = priority_queue.items.includes([f_cost, neighbor_coordinates]); // if (!have_visited && is_neighbor_in_priority_queue && is_current_cost_less) {\n      //     const index = priority_queue.items.indexOf([f_cost, neighbor_coordinates]);\n      //     priority_queue.items.splice(index);\n      // }\n\n      if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_queue && walls[neighbor_coordinates] === undefined) {\n        // update the distance of the neighbor_node\n        updateDistance(f_cost, neighbor_coordinates, distance_matrix); // distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n        // update the parent node of the neighbor node to the current node\n\n        updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n        priority_queue.enqueue(neighbor_coordinates, calculateWeight(manhattanDistance(neighbor_coordinates, end_coordinates), neighbor_coordinates, weights));\n      }\n\n      result = generator.next();\n    }\n  }\n\n  yield visited_coordinates; // could be undefined or a path\n\n  let undefined_or_path = getShortestPath(end_coordinates, parent_matrix); // if it is undefined, return undefined (void)\n\n  if (undefined_or_path === undefined) {\n    return;\n  }\n\n  path = path.concat(undefined_or_path);\n  yield path; // yield getShortestPath(end_coordinates, parent_matrix);\n  // yield* traverseShortestPath(end_coordinates,parent_matrix);\n}\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n  return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/a-star.js"],"names":["shallowCopy","checkNeighbors","PriorityQueue","updatetoVisited","getShortestPath","calculateWeight","updateParent","updateDistance","aStar","matrix","start","end","additional_destinations","walls","weights","found","start_coordinates","end_coordinates","priority_queue","visited_coordinates","path","parent_matrix","visited","distance_matrix","Infinity","enqueue","manhattanDistance","isEmpty","q_item","dequeue","current_coordinates","element","push","Object","keys","length","next_dest","console","log","new_path","add_to_visited_nodes","next","value","add_shortest_path","concat","generator","result","done","neighbor_coordinates","have_visited","cost_from_current_node","f_cost","is_current_cost_less","is_neighbor_in_priority_queue","items","includes","undefined","undefined_or_path","coordinates1","coordinates2","Math","abs"],"mappings":"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","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\"\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\n// import { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { PriorityQueue } from \"../data-structures/priority-queue\"\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\n// import { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\n\nexport default function* aStar(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations = {}, walls = {}, weights = {}) {\n    let found = false;\n    let start_coordinates = [...start]\n    let end_coordinates = [...end]\n    var priority_queue = new PriorityQueue();\n    // let additional_dest = Object.assign({}, additional_destinations);\n    let visited_coordinates = [];\n    let path = [];\n    let parent_matrix = shallowCopy(matrix, null);\n    let visited = shallowCopy(matrix, false);\n    let distance_matrix = shallowCopy(matrix, Infinity);\n\n\n    distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n\n    priority_queue.enqueue([...start_coordinates], manhattanDistance(start_coordinates, end_coordinates));\n    while (!priority_queue.isEmpty() && !found) {\n        let q_item = priority_queue.dequeue();\n        // let f_cost = tuple[0];\n        let current_coordinates = q_item.element;\n        updatetoVisited(current_coordinates, visited);\n        visited_coordinates.push(current_coordinates);\n\n        if (Object.keys(additional_destinations).length !== 0) {\n            let keys = Object.keys(additional_destinations);\n            let next_dest = additional_destinations[keys[0]]\n            console.log(additional_destinations[keys[0]])\n            delete additional_destinations[keys[0]];\n            let new_path = aStar(matrix, current_coordinates, next_dest, additional_destinations, walls, weights);\n            let add_to_visited_nodes = new_path.next().value;\n            let add_shortest_path = new_path.next().value;\n            visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n            // if (add_shortest_path === undefined)\n            //     break;\n            path = path.concat(add_shortest_path);\n            console.log(path);\n            current_coordinates = [...next_dest]\n            end_coordinates = [...end]\n            // end_coordinates = current_coordinates;\n            // found = true;\n\n\n        }\n        if (((current_coordinates[0] === end_coordinates[0]) && (current_coordinates[1] === end_coordinates[1])) && Object.keys(additional_destinations).length === 0) {\n            found = true;\n        }\n        // yield [...current_coordinates];\n\n        // if(coordinatesAreEqual(current_coordinates,end_coordinates))\n        // {\n        //     break;\n        // }\n\n        const generator = checkNeighbors(current_coordinates, visited);\n        let result = generator.next();\n\n        while (!result.done && !found) {\n            let neighbor_coordinates = result.value\n            let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]];\n            // EDIT: needs to change once weight and walls are added in.\n            let cost_from_current_node = calculateWeight(distance_matrix[current_coordinates[0]][current_coordinates[1]], neighbor_coordinates, weights);\n\n            let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates);\n            // cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates) \n\n            let is_current_cost_less = f_cost < distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]];\n            let is_neighbor_in_priority_queue = priority_queue.items.includes([f_cost, neighbor_coordinates]);\n\n            // if (!have_visited && is_neighbor_in_priority_queue && is_current_cost_less) {\n            //     const index = priority_queue.items.indexOf([f_cost, neighbor_coordinates]);\n            //     priority_queue.items.splice(index);\n\n            // }\n            if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_queue && walls[neighbor_coordinates] === undefined) {\n                // update the distance of the neighbor_node\n                updateDistance(f_cost, neighbor_coordinates, distance_matrix)\n                // distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n                // update the parent node of the neighbor node to the current node\n                updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n                priority_queue.enqueue(neighbor_coordinates, calculateWeight(manhattanDistance(neighbor_coordinates, end_coordinates), neighbor_coordinates, weights))\n            }\n\n            result = generator.next();\n        }\n    }\n    yield visited_coordinates;\n    // could be undefined or a path\n    let undefined_or_path = getShortestPath(end_coordinates, parent_matrix);\n    // if it is undefined, return undefined (void)\n    if (undefined_or_path === undefined) {\n        return;\n    }\n\n    path = path.concat(undefined_or_path);\n\n\n    yield path\n    // yield getShortestPath(end_coordinates, parent_matrix);\n    // yield* traverseShortestPath(end_coordinates,parent_matrix);\n\n\n\n\n}\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n    return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}"]},"metadata":{},"sourceType":"module"}