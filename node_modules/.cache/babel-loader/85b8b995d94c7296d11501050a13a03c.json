{"ast":null,"code":"import isEqual from \"../helpers/2d-array-functions/is-equal\";\nimport shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nimport { PriorityQueue } from \"../data-structures/priority-queue\";\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\nexport default function* dijkstra(matrix = [[]], source = [2, 2], end = [0, 3], additional_destinations, walls, weights) {\n  // yield [...source]\n  let visited_coordinates = [];\n  let adjacency_matrix = shallowCopy(matrix);\n  let visited = shallowCopy(matrix, false);\n  let parent_coordinates = shallowCopy(matrix, null);\n  let coordinates = source; // let queue = [];\n\n  let queue = new PriorityQueue();\n  adjacency_matrix[source[0]][source[1]] = 0;\n  coordinates = [source[0], source[1]];\n  visited[source[0]][source[1]] = true;\n  parent_coordinates[source[0]][source[1]] = null;\n  queue.enqueue(coordinates, 0);\n  visited_coordinates.push(coordinates);\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      if (!isEqual(source, [row, col])) {\n        parent_coordinates[row][col] = null;\n        adjacency_matrix[row][col] = Infinity;\n        visited[row][col] = false;\n      }\n    }\n  }\n\n  let found = false;\n\n  while (!found && !queue.isEmpty()) {\n    coordinates = queue.dequeue().element;\n    visited_coordinates.push(coordinates); // updatetoVisited(coordinates, visited);\n\n    if (coordinates[0] === end[0] && coordinates[1] === end[1]) {\n      found = true;\n    }\n\n    const generator = checkNeighbors(coordinates, visited);\n    let result = null;\n\n    do {\n      result = generator.next();\n      var neighbors_coordinates = result.value;\n\n      if (!result.done && !found && walls[neighbors_coordinates] === undefined) {\n        let alternative_weight = calculateWeight(adjacency_matrix[coordinates[0]][coordinates[1]], neighbors_coordinates, weights);\n\n        if (alternative_weight < adjacency_matrix[neighbors_coordinates[0]][neighbors_coordinates[1]]) {\n          updateDistance(alternative_weight, neighbors_coordinates, adjacency_matrix);\n          queue.enqueue(neighbors_coordinates, alternative_weight);\n          updateParent(coordinates, neighbors_coordinates, parent_coordinates);\n        } // updateDistance(adjacency_matrix[coordinates[0]][coordinates[1]], neighbors_coordinates, adjacency_matrix, weights);\n        // updatetoVisited(neighbors_coordinates, visited);\n        // updateParent(coordinates, neighbors_coordinates, parent_coordinates);\n        // queue.enqueue(neighbors_coordinates,adjacency_matrix[coordinates[0]][coordinates[1]]);\n        // found = isEqual(neighbors_coordinates, end);\n        // yield [...neighbors_coordinates];\n        // visited_coordinates.push(neighbors_coordinates);\n\n      }\n    } while (!result.done);\n  }\n\n  yield visited_coordinates;\n  yield getShortestPath(end, parent_coordinates); // yield* traverseShortestPath(end, parent_coordinates)\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/dijkstra.js"],"names":["isEqual","shallowCopy","checkNeighbors","updatetoVisited","updateParent","updateDistance","getShortestPath","PriorityQueue","calculateWeight","dijkstra","matrix","source","end","additional_destinations","walls","weights","visited_coordinates","adjacency_matrix","visited","parent_coordinates","coordinates","queue","enqueue","push","row","length","col","Infinity","found","isEmpty","dequeue","element","generator","result","next","neighbors_coordinates","value","done","undefined","alternative_weight"],"mappings":"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","sourcesContent":["import isEqual from \"../helpers/2d-array-functions/is-equal\";\nimport shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nimport { PriorityQueue } from \"../data-structures/priority-queue\";\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\n\n\n\nexport default function* dijkstra(matrix = [[]], source = [2, 2], end = [0, 3], additional_destinations, walls, weights) {\n    // yield [...source]\n    let visited_coordinates = [];\n    let adjacency_matrix = shallowCopy(matrix);\n    let visited = shallowCopy(matrix, false);\n    let parent_coordinates = shallowCopy(matrix, null);\n    let coordinates = source;\n    // let queue = [];\n    let queue = new PriorityQueue();\n    adjacency_matrix[source[0]][source[1]] = 0;\n    coordinates = [source[0], source[1]];\n    visited[source[0]][source[1]] = true;\n    parent_coordinates[source[0]][source[1]] = null;\n    queue.enqueue(coordinates, 0);\n    visited_coordinates.push(coordinates);\n\n\n    for (let row = 0; row < matrix.length; row++) {\n        for (let col = 0; col < matrix[row].length; col++) {\n            if (!isEqual(source, [row, col])) {\n                parent_coordinates[row][col] = null;\n                adjacency_matrix[row][col] = Infinity;\n                visited[row][col] = false;\n            }\n        }\n    }\n\n\n    let found = false;\n    while (!found && !queue.isEmpty()) {\n        coordinates = queue.dequeue().element;\n        visited_coordinates.push(coordinates);\n        // updatetoVisited(coordinates, visited);\n        if(coordinates[0] === end[0] && coordinates[1] === end[1])\n        {\n            found = true;\n        }\n\n\n        const generator = checkNeighbors(coordinates, visited);\n        let result = null;\n\n        do {\n            result = generator.next();\n            var neighbors_coordinates = result.value;\n            if (!result.done && !found && walls[neighbors_coordinates] === undefined) {\n                let alternative_weight = calculateWeight(adjacency_matrix[coordinates[0]][coordinates[1]],neighbors_coordinates,weights)\n                if(alternative_weight < adjacency_matrix[neighbors_coordinates[0]][neighbors_coordinates[1]])\n                {\n                    updateDistance(alternative_weight,neighbors_coordinates, adjacency_matrix);\n                    queue.enqueue(neighbors_coordinates, alternative_weight);\n                    updateParent(coordinates,neighbors_coordinates,parent_coordinates);\n                } \n                // updateDistance(adjacency_matrix[coordinates[0]][coordinates[1]], neighbors_coordinates, adjacency_matrix, weights);\n                // updatetoVisited(neighbors_coordinates, visited);\n                // updateParent(coordinates, neighbors_coordinates, parent_coordinates);\n                // queue.enqueue(neighbors_coordinates,adjacency_matrix[coordinates[0]][coordinates[1]]);\n                // found = isEqual(neighbors_coordinates, end);\n                // yield [...neighbors_coordinates];\n                // visited_coordinates.push(neighbors_coordinates);\n            }\n        }\n        while (!result.done)\n    }\n    yield visited_coordinates;\n    yield getShortestPath(end, parent_coordinates);\n    // yield* traverseShortestPath(end, parent_coordinates)\n\n}\n"]},"metadata":{},"sourceType":"module"}