{"ast":null,"code":"export default function* dijkstra(matrix = [[]], source = [2, 2], end = [0, 3]) {\n  let adjacency_matrix = shallow_copy(matrix);\n  let visited = shallow_copy(matrix);\n  let parent_coordinates = shallow_copy(matrix);\n  let coordinates = source;\n  let queue = []; // setting all initial values for the source node within each data structure\n\n  adjacency_matrix[source[0]][source[1]] = 0;\n  coordinates = [source[0], source[1]];\n  visited[source[0]][source[1]] = true;\n  parent_coordinates[source[0]][source[1]] = null;\n  queue.push(coordinates);\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      if (!isEqual(source, [row, col])) {\n        parent_coordinates[row][col] = null;\n        adjacency_matrix[row][col] = Infinity;\n        visited[row][col] = false;\n      }\n    }\n  }\n\n  let found = false;\n\n  while (!found) {\n    coordinates = queue.shift();\n    const generator = check_neighbors(coordinates, visited);\n    let result = null;\n\n    do {\n      result = generator.next();\n      var neighbors_coordinates = result.value;\n\n      if (!result.done && !found) {\n        update_distance(adjacency_matrix[coordinates[0]][coordinates[1]], neighbors_coordinates, adjacency_matrix);\n        update_to_visited(neighbors_coordinates, visited);\n        update_parent(coordinates, neighbors_coordinates, parent_coordinates);\n        queue.push(neighbors_coordinates);\n        found = isEqual(neighbors_coordinates, end);\n        yield [...neighbors_coordinates];\n      }\n    } while (!result.done);\n  } // yield visited;\n\n\n  yield parent_coordinates;\n  yield [...adjacency_matrix];\n  let path = [];\n  let current = parent_coordinates[end[0]][end[1]];\n\n  do {\n    path.push(current);\n    current = parent_coordinates[(current[0], current[1])];\n  } while (current !== null);\n}\n\nfunction update_distance(prev_value, node_location, adjacency_matrix) {\n  // let prev_row = prev_node_location[0];\n  // let prev_column = prev_node_location[1];\n  let row = node_location[0];\n  let column = node_location[1];\n  if (prev_value < adjacency_matrix[row][column]) adjacency_matrix[row][column] = prev_value + 1;\n}\n\nfunction isEqual(array1 = [], array2 = []) {\n  if (array1.length !== array2.length) return false;\n\n  for (let i = 0; i < array1.length; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction update_parent(parent_node_location, child_node_location, parent_coordinates) {\n  let row = child_node_location[0];\n  let column = child_node_location[1];\n  parent_coordinates[row][column] = parent_node_location;\n}\n\nfunction* check_neighbors(node_location, visited) {\n  let row = node_location[0];\n  let column = node_location[1];\n  const RIGHT = column + 1;\n  const LEFT = column - 1;\n  const UP = row - 1;\n  const DOWN = row + 1;\n\n  if (RIGHT >= 0 && RIGHT < visited.length && !visited[row][RIGHT]) {\n    yield [row, RIGHT];\n  }\n\n  if (LEFT >= 0 && !visited[row][LEFT]) {\n    yield [row, LEFT];\n  }\n\n  if (UP >= 0 && !visited[UP][column]) {\n    yield [UP, column];\n  }\n\n  if (DOWN >= 0 && DOWN < visited.length && !visited[DOWN][column]) {\n    yield [DOWN, column];\n  }\n}\n\nfunction update_to_visited(node_location, visited) {\n  let row = node_location[0];\n  let col = node_location[1];\n  visited[row][col] = true;\n}\n\nfunction shallow_copy(array) {\n  const temp = [];\n\n  for (let i = 0; i < array.length; i++) {\n    temp.push([...array[i]]);\n  } // console.log('temp: ', temp)\n\n\n  return temp;\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/dijkstra.js"],"names":["dijkstra","matrix","source","end","adjacency_matrix","shallow_copy","visited","parent_coordinates","coordinates","queue","push","row","length","col","isEqual","Infinity","found","shift","generator","check_neighbors","result","next","neighbors_coordinates","value","done","update_distance","update_to_visited","update_parent","path","current","prev_value","node_location","column","array1","array2","i","parent_node_location","child_node_location","RIGHT","LEFT","UP","DOWN","array","temp"],"mappings":"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","sourcesContent":["export default function* dijkstra(matrix = [[]], source = [2, 2], end = [0, 3]) {\n    let adjacency_matrix = shallow_copy(matrix);\n    let visited = shallow_copy(matrix);\n    let parent_coordinates = shallow_copy(matrix);\n    let coordinates = source;\n    let queue = [];\n\n    // setting all initial values for the source node within each data structure\n    adjacency_matrix[source[0]][source[1]] = 0;\n    coordinates = [source[0], source[1]];\n    visited[source[0]][source[1]] = true;\n    parent_coordinates[source[0]][source[1]] = null;\n    queue.push(coordinates);\n\n\n    for (let row = 0; row < matrix.length; row++) {\n        for (let col = 0; col < matrix[row].length; col++) {\n            if (!isEqual(source, [row, col])) {\n                parent_coordinates[row][col] = null;\n                adjacency_matrix[row][col] = Infinity;\n                visited[row][col] = false;\n            }\n        }\n    }\n\n\n    let found = false;\n    while (!found) {\n        coordinates = queue.shift();\n        const generator = check_neighbors(coordinates, visited);\n        let result = null;\n        do {\n            result = generator.next();\n            var neighbors_coordinates = result.value;\n            if (!result.done && !found) {\n                update_distance(adjacency_matrix[coordinates[0]][coordinates[1]], neighbors_coordinates, adjacency_matrix);\n                update_to_visited(neighbors_coordinates, visited);\n                update_parent(coordinates, neighbors_coordinates, parent_coordinates);\n                queue.push(neighbors_coordinates);\n                found = isEqual(neighbors_coordinates, end);\n                yield [...neighbors_coordinates];\n\n            }\n        }\n        while (!result.done)\n    }\n\n    // yield visited;\n\n    yield parent_coordinates;\n\n    yield [...adjacency_matrix]\n\n\n    let path = []\n    let current = parent_coordinates[end[0]][end[1]]\n    do {\n        path.push(current);\n        current = parent_coordinates[current[0], current[1]];\n    }\n    while (current !== null)\n\n}\n\nfunction update_distance(prev_value, node_location, adjacency_matrix) {\n    // let prev_row = prev_node_location[0];\n    // let prev_column = prev_node_location[1];\n    let row = node_location[0];\n    let column = node_location[1];\n    if (prev_value < adjacency_matrix[row][column])\n        adjacency_matrix[row][column] = prev_value + 1;\n}\n\nfunction isEqual(array1 = [], array2 = []) {\n    if (array1.length !== array2.length)\n        return false;\n\n    for (let i = 0; i < array1.length; i++) {\n        if (array1[i] !== array2[i]) {\n            return false\n        }\n    }\n    return true;\n}\n\n\nfunction update_parent(parent_node_location, child_node_location, parent_coordinates) {\n    let row = child_node_location[0]\n    let column = child_node_location[1]\n    parent_coordinates[row][column] = parent_node_location\n}\n\nfunction* check_neighbors(node_location, visited) {\n    let row = node_location[0];\n    let column = node_location[1];\n    const RIGHT = column + 1;\n    const LEFT = column - 1;\n    const UP = row - 1;\n    const DOWN = row + 1;\n\n    if (RIGHT >= 0 && RIGHT < visited.length && !visited[row][RIGHT]) {\n        yield [row, RIGHT];\n    }\n    if (LEFT >= 0 && !visited[row][LEFT]) {\n        yield [row, LEFT];\n    }\n\n    if (UP >= 0 && !visited[UP][column]) {\n        yield [UP, column];\n    }\n    if (DOWN >= 0 && DOWN < visited.length && !visited[DOWN][column]) {\n        yield [DOWN, column];\n    }\n\n}\n\nfunction update_to_visited(node_location, visited) {\n    let row = node_location[0];\n    let col = node_location[1];\n    visited[row][col] = true;\n}\n\nfunction shallow_copy(array) {\n    const temp = [];\n\n    for (let i = 0; i < array.length; i++) {\n        temp.push([...array[i]])\n    }\n    // console.log('temp: ', temp)\n    return temp;\n}"]},"metadata":{},"sourceType":"module"}