{"ast":null,"code":"import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nexport default function* depthFirstSearch(adjacency_matrix = [[]], start_node_coordinates = [2, 2], end_node_coordinates = [0, 0], additional_destinations, walls) {\n  // data structure for storing next values\n  let stack = [];\n  let start_coordinates = [...start_node_coordinates];\n  let end_coordinates = [...end_node_coordinates]; // coordinates that have been visited\n\n  let visited_coordinates = []; // matrix that shows if a node at index [i][j] has been visited\n\n  let visited = shallowCopy(adjacency_matrix, false); // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n\n  let parent_matrix = shallowCopy(adjacency_matrix, null); // if end is found\n\n  let found = false; // pushing the starting coordintes into the stack, this will be where we start our search.\n\n  stack.push([...start_node_coordinates]); // while stack is not empty\n\n  while (stack.length !== 0 && !found) {\n    // the current verticies.\n    let vertex_coordinates = stack.pop();\n    visited_coordinates.push(vertex_coordinates); // yielding the coordinates\n    // yield [...vertex_coordinates];\n\n    if (vertex_coordinates[0]) // if(coordinatesAreEqual(vertex_coordinates, end_node_coordinates))\n      // {\n      //     found = true;\n      //     yield visited_coordinates;\n      //     continue;\n      // }\n      // if (!visited[vertex_coordinates[0]][vertex_coordinates[1]] && !found) {\n      updatetoVisited(vertex_coordinates, visited);\n    const generator = checkNeighbors(vertex_coordinates, visited);\n    let result = generator.next();\n\n    while (!result.done) {\n      let value = result.value;\n\n      if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n        updateParent(vertex_coordinates, value, parent_matrix);\n        stack.push(value);\n      }\n\n      result = generator.next();\n    } // }\n\n  } // yield* traverseShortestPath(end_node_coordinates, parent_matrix);\n\n\n  yield getShortestPath(end_node_coordinates, parent_matrix);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/depth-first-search.js"],"names":["shallowCopy","updatetoVisited","checkNeighbors","updateParent","coordinatesAreEqual","getShortestPath","depthFirstSearch","adjacency_matrix","start_node_coordinates","end_node_coordinates","additional_destinations","walls","stack","start_coordinates","end_coordinates","visited_coordinates","visited","parent_matrix","found","push","length","vertex_coordinates","pop","generator","result","next","done","value","undefined"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,4CAAxB;AACA,SAASC,eAAT,QAAgC,gEAAhC;AACA,SAASC,cAAT,QAA+B,wDAA/B;AACA,SAASC,YAAT,QAA6B,4DAA7B;AACA,OAAOC,mBAAP,MAAgC,oEAAhC;AACA,OAAOC,eAAP,MAA4B,gEAA5B;AAGA,eAAe,UAAUC,gBAAV,CAA2BC,gBAAgB,GAAG,CAAC,EAAD,CAA9C,EAAoDC,sBAAsB,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA7E,EAAqFC,oBAAoB,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA5G,EAAmHC,uBAAnH,EAA4IC,KAA5I,EAAmJ;AAC9J;AACA,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,iBAAiB,GAAG,CAAC,GAAGL,sBAAJ,CAAxB;AACA,MAAIM,eAAe,GAAG,CAAC,GAAGL,oBAAJ,CAAtB,CAJ8J,CAK9J;;AACA,MAAIM,mBAAmB,GAAG,EAA1B,CAN8J,CAQ9J;;AACA,MAAIC,OAAO,GAAGhB,WAAW,CAACO,gBAAD,EAAmB,KAAnB,CAAzB,CAT8J,CAU9J;;AACA,MAAIU,aAAa,GAAGjB,WAAW,CAACO,gBAAD,EAAmB,IAAnB,CAA/B,CAX8J,CAY9J;;AACA,MAAIW,KAAK,GAAG,KAAZ,CAb8J,CAc9J;;AACAN,EAAAA,KAAK,CAACO,IAAN,CAAW,CAAC,GAAGX,sBAAJ,CAAX,EAf8J,CAgB9J;;AACA,SAAOI,KAAK,CAACQ,MAAN,KAAiB,CAAjB,IAAsB,CAACF,KAA9B,EAAqC;AACjC;AACA,QAAIG,kBAAkB,GAAGT,KAAK,CAACU,GAAN,EAAzB;AACAP,IAAAA,mBAAmB,CAACI,IAApB,CAAyBE,kBAAzB,EAHiC,CAIjC;AACA;;AACA,QAAGA,kBAAkB,CAAC,CAAD,CAArB,EAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACIpB,MAAAA,eAAe,CAACoB,kBAAD,EAAqBL,OAArB,CAAf;AAGA,UAAMO,SAAS,GAAGrB,cAAc,CAACmB,kBAAD,EAAqBL,OAArB,CAAhC;AACA,QAAIQ,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAb;;AAEA,WAAO,CAACD,MAAM,CAACE,IAAf,EAAqB;AACjB,UAAIC,KAAK,GAAGH,MAAM,CAACG,KAAnB;;AAEA,UAAI,CAACX,OAAO,CAACW,KAAK,CAAC,CAAD,CAAN,CAAP,CAAkBA,KAAK,CAAC,CAAD,CAAvB,CAAD,IAAgChB,KAAK,CAACgB,KAAD,CAAL,KAAiBC,SAArD,EAAgE;AAC5DzB,QAAAA,YAAY,CAACkB,kBAAD,EAAqBM,KAArB,EAA4BV,aAA5B,CAAZ;AACAL,QAAAA,KAAK,CAACO,IAAN,CAAWQ,KAAX;AACH;;AAEDH,MAAAA,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAT;AACH,KA/B4B,CAgCjC;;AACH,GAlD6J,CAoD9J;;;AAEA,QAAMpB,eAAe,CAACI,oBAAD,EAAuBQ,aAAvB,CAArB;AACH","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\n\n\nexport default function* depthFirstSearch(adjacency_matrix = [[]], start_node_coordinates = [2, 2], end_node_coordinates = [0, 0],additional_destinations, walls) {\n    // data structure for storing next values\n    let stack = [];\n    let start_coordinates = [...start_node_coordinates]\n    let end_coordinates = [...end_node_coordinates]\n    // coordinates that have been visited\n    let visited_coordinates = [];\n\n    // matrix that shows if a node at index [i][j] has been visited\n    let visited = shallowCopy(adjacency_matrix, false);\n    // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n    let parent_matrix = shallowCopy(adjacency_matrix, null);\n    // if end is found\n    let found = false;\n    // pushing the starting coordintes into the stack, this will be where we start our search.\n    stack.push([...start_node_coordinates]);\n    // while stack is not empty\n    while (stack.length !== 0 && !found) {\n        // the current verticies.\n        let vertex_coordinates = stack.pop();\n        visited_coordinates.push(vertex_coordinates);\n        // yielding the coordinates\n        // yield [...vertex_coordinates];\n        if(vertex_coordinates[0])\n\n        // if(coordinatesAreEqual(vertex_coordinates, end_node_coordinates))\n        // {\n        //     found = true;\n        //     yield visited_coordinates;\n        //     continue;\n        // }\n\n        // if (!visited[vertex_coordinates[0]][vertex_coordinates[1]] && !found) {\n            updatetoVisited(vertex_coordinates, visited);\n\n\n            const generator = checkNeighbors(vertex_coordinates, visited);\n            let result = generator.next();\n\n            while (!result.done) {\n                let value = result.value\n\n                if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n                    updateParent(vertex_coordinates, value, parent_matrix);\n                    stack.push(value);\n                }\n\n                result = generator.next();\n            }\n        // }\n    }\n\n    // yield* traverseShortestPath(end_node_coordinates, parent_matrix);\n\n    yield getShortestPath(end_node_coordinates, parent_matrix);\n}\n\n"]},"metadata":{},"sourceType":"module"}