{"ast":null,"code":"import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nexport default function* depthFirstSearch(adjacency_matrix = [[]], start_node_coordinates = [2, 2], end_node_coordinates = [0, 0], additional_destinations, walls) {\n  // data structure for storing next values\n  let stack = []; // coordinates that have been visited\n\n  let visited_coordinates = []; // matrix that shows if a node at index [i][j] has been visited\n\n  let visited = shallowCopy(adjacency_matrix, false); // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n\n  let parent_matrix = shallowCopy(adjacency_matrix, null); // if end is found\n\n  let found = false; // pushing the starting coordintes into the stack, this will be where we start our search.\n\n  stack.push([...start_node_coordinates]); // while stack is not empty\n\n  while (stack.length !== 0 && !found) {\n    // the current verticies.\n    let vertex_coordinates = stack.pop();\n    visited_coordinates.push(vertex_coordinates); // yielding the coordinates\n    // yield [...vertex_coordinates];\n\n    if (coordinatesAreEqual(vertex_coordinates, end_node_coordinates)) {\n      found = true;\n      yield visited_coordinates;\n      continue;\n    } // if (!visited[vertex_coordinates[0]][vertex_coordinates[1]] && !found) {\n\n\n    updatetoVisited(vertex_coordinates, visited);\n    const generator = checkNeighbors(vertex_coordinates, visited);\n    let result = generator.next();\n\n    while (!result.done) {\n      let value = result.value;\n\n      if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n        updateParent(vertex_coordinates, value, parent_matrix);\n        stack.push(value);\n      }\n\n      result = generator.next();\n    } // }\n\n  } // yield* traverseShortestPath(end_node_coordinates, parent_matrix);\n\n\n  yield getShortestPath(end_node_coordinates, parent_matrix);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/depth-first-search.js"],"names":["shallowCopy","updatetoVisited","checkNeighbors","updateParent","coordinatesAreEqual","getShortestPath","depthFirstSearch","adjacency_matrix","start_node_coordinates","end_node_coordinates","additional_destinations","walls","stack","visited_coordinates","visited","parent_matrix","found","push","length","vertex_coordinates","pop","generator","result","next","done","value","undefined"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,4CAAxB;AACA,SAASC,eAAT,QAAgC,gEAAhC;AACA,SAASC,cAAT,QAA+B,wDAA/B;AACA,SAASC,YAAT,QAA6B,4DAA7B;AACA,OAAOC,mBAAP,MAAgC,oEAAhC;AACA,OAAOC,eAAP,MAA4B,gEAA5B;AAGA,eAAe,UAAUC,gBAAV,CAA2BC,gBAAgB,GAAG,CAAC,EAAD,CAA9C,EAAoDC,sBAAsB,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA7E,EAAqFC,oBAAoB,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA5G,EAAmHC,uBAAnH,EAA4IC,KAA5I,EAAmJ;AAC9J;AACA,MAAIC,KAAK,GAAG,EAAZ,CAF8J,CAI9J;;AACA,MAAIC,mBAAmB,GAAG,EAA1B,CAL8J,CAO9J;;AACA,MAAIC,OAAO,GAAGd,WAAW,CAACO,gBAAD,EAAmB,KAAnB,CAAzB,CAR8J,CAS9J;;AACA,MAAIQ,aAAa,GAAGf,WAAW,CAACO,gBAAD,EAAmB,IAAnB,CAA/B,CAV8J,CAW9J;;AACA,MAAIS,KAAK,GAAG,KAAZ,CAZ8J,CAa9J;;AACAJ,EAAAA,KAAK,CAACK,IAAN,CAAW,CAAC,GAAGT,sBAAJ,CAAX,EAd8J,CAe9J;;AACA,SAAOI,KAAK,CAACM,MAAN,KAAiB,CAAjB,IAAsB,CAACF,KAA9B,EAAqC;AACjC;AACA,QAAIG,kBAAkB,GAAGP,KAAK,CAACQ,GAAN,EAAzB;AACAP,IAAAA,mBAAmB,CAACI,IAApB,CAAyBE,kBAAzB,EAHiC,CAIjC;AACA;;AAEA,QAAGf,mBAAmB,CAACe,kBAAD,EAAqBV,oBAArB,CAAtB,EACA;AACIO,MAAAA,KAAK,GAAG,IAAR;AACA,YAAMH,mBAAN;AACA;AACH,KAZgC,CAcjC;;;AACIZ,IAAAA,eAAe,CAACkB,kBAAD,EAAqBL,OAArB,CAAf;AAGA,UAAMO,SAAS,GAAGnB,cAAc,CAACiB,kBAAD,EAAqBL,OAArB,CAAhC;AACA,QAAIQ,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAb;;AAEA,WAAO,CAACD,MAAM,CAACE,IAAf,EAAqB;AACjB,UAAIC,KAAK,GAAGH,MAAM,CAACG,KAAnB;;AAEA,UAAI,CAACX,OAAO,CAACW,KAAK,CAAC,CAAD,CAAN,CAAP,CAAkBA,KAAK,CAAC,CAAD,CAAvB,CAAD,IAAgCd,KAAK,CAACc,KAAD,CAAL,KAAiBC,SAArD,EAAgE;AAC5DvB,QAAAA,YAAY,CAACgB,kBAAD,EAAqBM,KAArB,EAA4BV,aAA5B,CAAZ;AACAH,QAAAA,KAAK,CAACK,IAAN,CAAWQ,KAAX;AACH;;AAEDH,MAAAA,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAT;AACH,KA9B4B,CA+BjC;;AACH,GAhD6J,CAkD9J;;;AAEA,QAAMlB,eAAe,CAACI,oBAAD,EAAuBM,aAAvB,CAArB;AACH","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\n\n\nexport default function* depthFirstSearch(adjacency_matrix = [[]], start_node_coordinates = [2, 2], end_node_coordinates = [0, 0],additional_destinations, walls) {\n    // data structure for storing next values\n    let stack = [];\n\n    // coordinates that have been visited\n    let visited_coordinates = [];\n\n    // matrix that shows if a node at index [i][j] has been visited\n    let visited = shallowCopy(adjacency_matrix, false);\n    // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n    let parent_matrix = shallowCopy(adjacency_matrix, null);\n    // if end is found\n    let found = false;\n    // pushing the starting coordintes into the stack, this will be where we start our search.\n    stack.push([...start_node_coordinates]);\n    // while stack is not empty\n    while (stack.length !== 0 && !found) {\n        // the current verticies.\n        let vertex_coordinates = stack.pop();\n        visited_coordinates.push(vertex_coordinates);\n        // yielding the coordinates\n        // yield [...vertex_coordinates];\n\n        if(coordinatesAreEqual(vertex_coordinates, end_node_coordinates))\n        {\n            found = true;\n            yield visited_coordinates;\n            continue;\n        }\n\n        // if (!visited[vertex_coordinates[0]][vertex_coordinates[1]] && !found) {\n            updatetoVisited(vertex_coordinates, visited);\n\n\n            const generator = checkNeighbors(vertex_coordinates, visited);\n            let result = generator.next();\n\n            while (!result.done) {\n                let value = result.value\n\n                if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n                    updateParent(vertex_coordinates, value, parent_matrix);\n                    stack.push(value);\n                }\n\n                result = generator.next();\n            }\n        // }\n    }\n\n    // yield* traverseShortestPath(end_node_coordinates, parent_matrix);\n\n    yield getShortestPath(end_node_coordinates, parent_matrix);\n}\n\n"]},"metadata":{},"sourceType":"module"}