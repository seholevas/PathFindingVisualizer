{"ast":null,"code":"import { getValueByElementId } from \"../functions/get-value-by-element-id\";\nimport generateMatrix from \"../2d-array-functions/generate-matrix\";\nimport { dispatchedChangedMatrixSize } from \"../../redux/dispatchs/grid-dispatchs\";\nimport shallowCopy from \"../2d-array-functions/shallow-copy\";\nimport store from \"../../redux/stores/store\";\nimport { dispatchedRemovedAdditionalDestination, dispatchedRemovedWeight, dispatchedRemovedWall, dispatchedMovedEnd, dispatchedMovedStart } from \"../../redux/dispatchs/node-dispatchs\";\nexport function changeArraySize() {\n  const size_of_matrix = getValueByElementId(\"size\");\n  const matrix = generateMatrix(size_of_matrix);\n  const shallow_copy = shallowCopy(matrix);\n  const start = store.getState().nodes.start_coordinates;\n  const end = store.getState().nodes.end_coordinates;\n  const grid_size = store.getState().grid.length;\n\n  if (start[0] < size_of_matrix - 1 && start[1] < size_of_matrix - 1) {\n    shallow_copy[start[0]][start[1]] = {\n      type: \"start_node\",\n      visited: false,\n      shortest_path: false\n    };\n  } else {\n    dispatchedMovedStart([size_of_matrix - 2, size_of_matrix - 2]);\n    shallow_copy[size_of_matrix - 2][size_of_matrix - 2] = {\n      type: \"start_node\",\n      visited: false,\n      shortest_path: false\n    };\n  }\n\n  if (end[0] < size_of_matrix - 1 && end[1] < size_of_matrix - 1) {\n    shallow_copy[end[0]][end[1]] = {\n      type: \"end_node\",\n      visited: false,\n      shortest_path: false\n    };\n  } else {\n    dispatchedMovedEnd([size_of_matrix - 1, size_of_matrix - 1]);\n    shallow_copy[size_of_matrix - 1][size_of_matrix - 1] = {\n      type: \"end_node\",\n      visited: false,\n      shortest_path: false\n    };\n  }\n\n  if (true) {\n    const weights = store.getState().nodes.weight_coordinates;\n    const additional_locations = store.getState().nodes.additional_destination_coordinates;\n    const walls = store.getState().nodes.wall_coordinates;\n\n    for (let i = 0; i < additional_locations.length; i++) {\n      let current = additional_locations[i];\n\n      if (current[0] < size_of_matrix - 1 && current[1] < size_of_matrix - 1) {\n        shallow_copy[current[0]][current[1]] = {\n          type: \"additional_destination_node\",\n          visited: false,\n          shortest_path: false\n        };\n      } else {\n        dispatchedRemovedAdditionalDestination(current);\n      }\n    }\n\n    for (let i = 0; i < weights.length; i++) {\n      let current = weights[i];\n\n      if (current[0] < size_of_matrix - 1 && current[1] < size_of_matrix - 1) {\n        shallow_copy[current[0]][current[1]] = {\n          type: \"weight_node\",\n          visited: false,\n          shortest_path: false\n        };\n      } else {\n        dispatchedRemovedWeight(current);\n      }\n    }\n\n    for (let i = 0; i < walls.length; i++) {\n      let current = walls[i];\n\n      if (current[0] < grid_size && current[1] < size_of_matrix - 1) {\n        shallow_copy[current[0]][current[1]] = {\n          type: \"wall_node\",\n          visited: false,\n          shortest_path: false\n        };\n      } else {\n        dispatchedRemovedWall(current);\n      }\n    }\n  }\n\n  dispatchedChangedMatrixSize(shallow_copy);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/helpers/state-functions/change-array-size.js"],"names":["getValueByElementId","generateMatrix","dispatchedChangedMatrixSize","shallowCopy","store","dispatchedRemovedAdditionalDestination","dispatchedRemovedWeight","dispatchedRemovedWall","dispatchedMovedEnd","dispatchedMovedStart","changeArraySize","size_of_matrix","matrix","shallow_copy","start","getState","nodes","start_coordinates","end","end_coordinates","grid_size","grid","length","type","visited","shortest_path","weights","weight_coordinates","additional_locations","additional_destination_coordinates","walls","wall_coordinates","i","current"],"mappings":"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","sourcesContent":["import { getValueByElementId } from \"../functions/get-value-by-element-id\";\nimport generateMatrix from \"../2d-array-functions/generate-matrix\";\nimport {dispatchedChangedMatrixSize} from \"../../redux/dispatchs/grid-dispatchs\";\nimport shallowCopy from \"../2d-array-functions/shallow-copy\";\nimport store from \"../../redux/stores/store\";\nimport { dispatchedRemovedAdditionalDestination, dispatchedRemovedWeight, dispatchedRemovedWall, dispatchedMovedEnd, dispatchedMovedStart } from \"../../redux/dispatchs/node-dispatchs\";\n\nexport function changeArraySize()\n{\n    const size_of_matrix = getValueByElementId(\"size\");\n    const matrix = generateMatrix(size_of_matrix);\n    const shallow_copy = shallowCopy(matrix);\n    const start = store.getState().nodes.start_coordinates;\n    const end = store.getState().nodes.end_coordinates;\n    const grid_size = store.getState().grid.length;\n\n\n    if ((start[0] < size_of_matrix-1) && (start[1] < size_of_matrix-1)) {\n        shallow_copy[start[0]][start[1]] = { type: \"start_node\", visited: false, shortest_path: false };\n    }\n    else {\n        dispatchedMovedStart([size_of_matrix-2, size_of_matrix-2])\n        shallow_copy[size_of_matrix-2][size_of_matrix-2] = { type: \"start_node\", visited: false, shortest_path: false };\n    }\n    if (end[0] < size_of_matrix-1 && end[1] < size_of_matrix-1) {\n        shallow_copy[end[0]][end[1]] = { type: \"end_node\", visited: false, shortest_path: false };\n    }\n    else {\n        dispatchedMovedEnd([size_of_matrix-1, size_of_matrix-1])\n        shallow_copy[size_of_matrix-1][size_of_matrix-1] = { type: \"end_node\", visited: false, shortest_path: false };\n        \n    }\n    if (true) {\n        const weights = store.getState().nodes.weight_coordinates;\n        const additional_locations = store.getState().nodes.additional_destination_coordinates;\n        const walls = store.getState().nodes.wall_coordinates;\n        \n        for (let i = 0; i < additional_locations.length; i++) {\n            let current = additional_locations[i]\n            if (current[0] < size_of_matrix-1 && current[1] < size_of_matrix-1) {\n                shallow_copy[current[0]][current[1]] = { type: \"additional_destination_node\", visited: false, shortest_path: false };\n            }\n            else{\n                dispatchedRemovedAdditionalDestination(current);\n            }\n        }\n        \n        for (let i = 0; i < weights.length; i++) {\n            let current = weights[i]\n            if (current[0] < size_of_matrix-1 && current[1] < size_of_matrix-1) {\n                shallow_copy[current[0]][current[1]] = { type: \"weight_node\", visited: false, shortest_path: false };\n            }\n            else{\n                dispatchedRemovedWeight(current);\n            }\n        }\n\n\n\n        for (let i = 0; i < walls.length; i++) {\n            let current = walls[i]\n            if (current[0] < grid_size && current[1] < size_of_matrix-1) {\n                shallow_copy[current[0]][current[1]] = { type: \"wall_node\", visited: false, shortest_path: false };\n            }\n            else\n            {\n                dispatchedRemovedWall(current)\n            }\n        }\n\n\n    }\n\n\n\n\n\n\n    dispatchedChangedMatrixSize(shallow_copy);\n}"]},"metadata":{},"sourceType":"module"}