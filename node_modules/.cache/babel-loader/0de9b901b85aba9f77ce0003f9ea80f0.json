{"ast":null,"code":"// procedure DFS_iterative(G, v) is\n//     let S be a stack\n//     S.push(v)\n//     while S is not empty do\n//         v = S.pop()\n//         if v is not labeled as discovered then\n//             label v as discovered\n//             for all edges from v to w in G.adjacentEdges(v) do \n//                 S.push(w)\nimport shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nexport default function* depthFirstSearch(adjacency_matrix = [[]], start_node_coordinates = [0, 0], end_node_coordinates = [3, 3]) {\n  // data structure for storing next values\n  let stack = []; // matrix that shows if a node at index [i][j] has been visited\n\n  let visited = shallowCopy(adjacency_matrix, false); // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n\n  let parent_matrix = shallowCopy(adjacency_matrix, null); // pushing the starting coordintes into the stack, this will be where we start our search.\n\n  stack.push([...start_node_coordinates]); // while stack is not empty\n\n  while (stack.length !== 0) {\n    // the current verticies.\n    let vertex_coordinates = stack.pop();\n    yield [...vertex_coordinates];\n\n    if (!visited[vertex_coordinates[0]][vertex_coordinates[1]]) {\n      updatetoVisited(vertex_coordinates, visited);\n      const generator = checkNeighbors(vertex_coordinates, visited);\n      let result = generator.next();\n\n      while (!result.done) {\n        let value = result.value;\n\n        if (!visited[value[0]][value[1]]) {\n          // yield value;\n          updatetoVisited(value, visited);\n          updateParent(vertex_coordinates, value, parent_matrix);\n          stack.push(value);\n        }\n\n        result = generator.next();\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/depth-first-search.js"],"names":["shallowCopy","updatetoVisited","checkNeighbors","updateParent","depthFirstSearch","adjacency_matrix","start_node_coordinates","end_node_coordinates","stack","visited","parent_matrix","push","length","vertex_coordinates","pop","generator","result","next","done","value"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,WAAP,MAAwB,4CAAxB;AACA,SAASC,eAAT,QAAgC,gEAAhC;AACA,SAASC,cAAT,QAA+B,wDAA/B;AACA,SAASC,YAAT,QAA6B,4DAA7B;AAGA,eAAe,UAAUC,gBAAV,CAA2BC,gBAAgB,GAAG,CAAC,EAAD,CAA9C,EAAoDC,sBAAsB,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA7E,EAAqFC,oBAAoB,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA5G,EAAoH;AAC/H;AACA,MAAIC,KAAK,GAAG,EAAZ,CAF+H,CAG/H;;AACA,MAAIC,OAAO,GAAGT,WAAW,CAACK,gBAAD,EAAmB,KAAnB,CAAzB,CAJ+H,CAK/H;;AACA,MAAIK,aAAa,GAAGV,WAAW,CAACK,gBAAD,EAAmB,IAAnB,CAA/B,CAN+H,CAO/H;;AACAG,EAAAA,KAAK,CAACG,IAAN,CAAW,CAAC,GAAGL,sBAAJ,CAAX,EAR+H,CAU/H;;AACA,SAAOE,KAAK,CAACI,MAAN,KAAiB,CAAxB,EAA2B;AACvB;AACA,QAAIC,kBAAkB,GAAGL,KAAK,CAACM,GAAN,EAAzB;AACA,UAAM,CAAC,GAAGD,kBAAJ,CAAN;;AACA,QAAI,CAACJ,OAAO,CAACI,kBAAkB,CAAC,CAAD,CAAnB,CAAP,CAA+BA,kBAAkB,CAAC,CAAD,CAAjD,CAAL,EAA4D;AACxDZ,MAAAA,eAAe,CAACY,kBAAD,EAAqBJ,OAArB,CAAf;AAGA,YAAMM,SAAS,GAAGb,cAAc,CAACW,kBAAD,EAAqBJ,OAArB,CAAhC;AACA,UAAIO,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAb;;AAEA,aAAO,CAACD,MAAM,CAACE,IAAf,EAAqB;AACjB,YAAIC,KAAK,GAAGH,MAAM,CAACG,KAAnB;;AAEA,YAAI,CAACV,OAAO,CAACU,KAAK,CAAC,CAAD,CAAN,CAAP,CAAkBA,KAAK,CAAC,CAAD,CAAvB,CAAL,EAAkC;AAC9B;AACAlB,UAAAA,eAAe,CAACkB,KAAD,EAAQV,OAAR,CAAf;AACAN,UAAAA,YAAY,CAACU,kBAAD,EAAqBM,KAArB,EAA4BT,aAA5B,CAAZ;AACAF,UAAAA,KAAK,CAACG,IAAN,CAAWQ,KAAX;AACH;;AAEDH,QAAAA,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAT;AACH;AACJ;AAGJ;AACJ","sourcesContent":["// procedure DFS_iterative(G, v) is\n//     let S be a stack\n//     S.push(v)\n//     while S is not empty do\n//         v = S.pop()\n//         if v is not labeled as discovered then\n//             label v as discovered\n//             for all edges from v to w in G.adjacentEdges(v) do \n//                 S.push(w)\n\nimport shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\n\n\nexport default function* depthFirstSearch(adjacency_matrix = [[]], start_node_coordinates = [0, 0], end_node_coordinates = [3, 3]) {\n    // data structure for storing next values\n    let stack = [];\n    // matrix that shows if a node at index [i][j] has been visited\n    let visited = shallowCopy(adjacency_matrix, false);\n    // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n    let parent_matrix = shallowCopy(adjacency_matrix, null);\n    // pushing the starting coordintes into the stack, this will be where we start our search.\n    stack.push([...start_node_coordinates]);\n\n    // while stack is not empty\n    while (stack.length !== 0) {\n        // the current verticies.\n        let vertex_coordinates = stack.pop();\n        yield [...vertex_coordinates];\n        if (!visited[vertex_coordinates[0]][vertex_coordinates[1]]) {\n            updatetoVisited(vertex_coordinates, visited);\n\n\n            const generator = checkNeighbors(vertex_coordinates, visited);\n            let result = generator.next();\n\n            while (!result.done) {\n                let value = result.value\n\n                if (!visited[value[0]][value[1]]) {\n                    // yield value;\n                    updatetoVisited(value, visited);\n                    updateParent(vertex_coordinates, value, parent_matrix);\n                    stack.push(value);\n                }\n\n                result = generator.next();\n            }\n        }\n\n\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}