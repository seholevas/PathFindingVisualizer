{"ast":null,"code":"import { getValueByElementId } from \"../functions/get-value-by-element-id\";\nimport generateMatrix from \"../2d-array-functions/generate-matrix\";\nimport shallowCopy from \"../2d-array-functions/shallow-copy\";\nimport { dispatchedClearMatrix } from \"../../redux/dispatchs/grid-dispatchs\";\nimport store from \"../../redux/stores/store\";\nimport { dispatchedRemovedAdditionalDestination, dispatchedRemovedWeight, dispatchedRemovedWall, dispatchedMovedStart, dispatchedAddedWall, dispatchedMovedEnd } from \"../../redux/dispatchs/node-dispatchs\"; // export function clearMatrix(isClearAll = true) \n// {\n//     // const size_of_matrix = getValueByElementId(\"size\");\n//     const grid_size = store.getState().grid.length;\n//     const matrix = generateMatrix(grid_size);\n//     const shallow_copy = shallowCopy(matrix);\n//     const start = store.getState().nodes.start_coordinates;\n//     const end = store.getState().nodes.end_coordinates;\n//     if ((start[0] < grid_size - 1) && (start[1] < grid_size - 1)) {\n//         shallow_copy[start[0]][start[1]] = { type: \"start_node\", visited: false, shortest_path: false };\n//     }\n//     else {\n//         dispatchedMovedStart([grid_size - 2, grid_size - 2])\n//         shallow_copy[grid_size - 2][grid_size - 2] = { type: \"start_node\", visited: false, shortest_path: false };\n//     }\n//     if (end[0] < grid_size - 1 && end[1] < grid_size - 1) {\n//         shallow_copy[end[0]][end[1]] = { type: \"end_node\", visited: false, shortest_path: false };\n//     }\n//     else {\n//         dispatchedMovedEnd([grid_size - 1, grid_size - 1])\n//         shallow_copy[grid_size - 1][grid_size - 1] = { type: \"end_node\", visited: false, shortest_path: false };\n//     }\n//     if (!isClearAll) {\n//         const weights = store.getState().nodes.weight_coordinates;\n//         const additional_locations = store.getState().nodes.additional_destination_coordinates;\n//         const walls = store.getState().nodes.wall_coordinates;\n//         while (Object.keys(additional_locations).length !== 0) {\n//             let keys = Object.keys(additional_locations);\n//             dispatchedRemovedAdditionalDestination(keys[0]);\n//         }\n//         // for (let i = 0; i < additional_locations.length; i++) {\n//         //     let current = additional_locations[i]\n//         //     if (current[0] < grid_size && current[1] < grid_size) {\n//         //         shallow_copy[current[0]][current[1]] = { type: \"additional_destination_node\", visited: false, shortest_path: false };\n//         //     }\n//         //     else\n//         //     {\n//         //         dispatchedRemovedAdditionalDestination(current);    \n//         //     }\n//     for (let i = 0; i < weights.length; i++) {\n//         let current = weights[i]\n//         if (current[0] < grid_size && current[1] < grid_size) {\n//             shallow_copy[current[0]][current[1]] = { type: \"weight_node\", visited: false, shortest_path: false };\n//         }\n//         else {\n//             dispatchedRemovedWeight(current);\n//         }\n//     }\n//     for (let i = 0; i < walls.length; i++) {\n//         let current = walls[i]\n//         if (current[0] < grid_size && current[1] < grid_size) {\n//             shallow_copy[current[0]][current[1]] = { type: \"wall_node\", visited: false, shortest_path: false };\n//         }\n//         else {\n//             dispatchedRemovedWall(current);\n//         }\n//     }\n// }\n// dispatchedMovedStart()\n// dispatchedClearMatrix(shallow_copy);\n// dispatchedChangedNodeType(matrix)\n// }\n\nexport function clearPath() {\n  let grid = store.getState().grid;\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      var element = document.getElementById(i + \"-\" + j);\n      element.classList.remove(\"visited-true\");\n      element.classList.remove(\"shortest-path-true\");\n      element.classList.add(\"visited-false\");\n      element.classList.add(\"shortest-path-false\");\n    }\n  }\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/helpers/state-functions/clear-matrix.js"],"names":["getValueByElementId","generateMatrix","shallowCopy","dispatchedClearMatrix","store","dispatchedRemovedAdditionalDestination","dispatchedRemovedWeight","dispatchedRemovedWall","dispatchedMovedStart","dispatchedAddedWall","dispatchedMovedEnd","clearPath","grid","getState","i","length","j","element","document","getElementById","classList","remove","add"],"mappings":"AAAA,SAASA,mBAAT,QAAoC,sCAApC;AACA,OAAOC,cAAP,MAA2B,uCAA3B;AACA,OAAOC,WAAP,MAAwB,oCAAxB;AACA,SAASC,qBAAT,QAAsC,sCAAtC;AACA,OAAOC,KAAP,MAAkB,0BAAlB;AACA,SAASC,sCAAT,EAAiDC,uBAAjD,EAA0EC,qBAA1E,EAAiGC,oBAAjG,EAAuHC,mBAAvH,EAA4IC,kBAA5I,QAAsK,sCAAtK,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,SAAT,GAAqB;AACxB,MAAIC,IAAI,GAAGR,KAAK,CAACS,QAAN,GAAiBD,IAA5B;;AACA,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACG,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AAClC,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAAI,CAACG,MAAzB,EAAiCC,CAAC,EAAlC,EAAsC;AAClC,UAAIC,OAAO,GAAGC,QAAQ,CAACC,cAAT,CAAwBL,CAAC,GAAG,GAAJ,GAAUE,CAAlC,CAAd;AACAC,MAAAA,OAAO,CAACG,SAAR,CAAkBC,MAAlB,CAAyB,cAAzB;AACAJ,MAAAA,OAAO,CAACG,SAAR,CAAkBC,MAAlB,CAAyB,oBAAzB;AACAJ,MAAAA,OAAO,CAACG,SAAR,CAAkBE,GAAlB,CAAsB,eAAtB;AACAL,MAAAA,OAAO,CAACG,SAAR,CAAkBE,GAAlB,CAAsB,qBAAtB;AAEH;AACJ;AACJ","sourcesContent":["import { getValueByElementId } from \"../functions/get-value-by-element-id\";\nimport generateMatrix from \"../2d-array-functions/generate-matrix\";\nimport shallowCopy from \"../2d-array-functions/shallow-copy\";\nimport { dispatchedClearMatrix } from \"../../redux/dispatchs/grid-dispatchs\";\nimport store from \"../../redux/stores/store\";\nimport { dispatchedRemovedAdditionalDestination, dispatchedRemovedWeight, dispatchedRemovedWall, dispatchedMovedStart, dispatchedAddedWall, dispatchedMovedEnd } from \"../../redux/dispatchs/node-dispatchs\";\n\n// export function clearMatrix(isClearAll = true) \n// {\n//     // const size_of_matrix = getValueByElementId(\"size\");\n//     const grid_size = store.getState().grid.length;\n//     const matrix = generateMatrix(grid_size);\n//     const shallow_copy = shallowCopy(matrix);\n//     const start = store.getState().nodes.start_coordinates;\n//     const end = store.getState().nodes.end_coordinates;\n\n\n//     if ((start[0] < grid_size - 1) && (start[1] < grid_size - 1)) {\n//         shallow_copy[start[0]][start[1]] = { type: \"start_node\", visited: false, shortest_path: false };\n//     }\n//     else {\n//         dispatchedMovedStart([grid_size - 2, grid_size - 2])\n//         shallow_copy[grid_size - 2][grid_size - 2] = { type: \"start_node\", visited: false, shortest_path: false };\n//     }\n//     if (end[0] < grid_size - 1 && end[1] < grid_size - 1) {\n//         shallow_copy[end[0]][end[1]] = { type: \"end_node\", visited: false, shortest_path: false };\n//     }\n//     else {\n//         dispatchedMovedEnd([grid_size - 1, grid_size - 1])\n//         shallow_copy[grid_size - 1][grid_size - 1] = { type: \"end_node\", visited: false, shortest_path: false };\n\n//     }\n\n//     if (!isClearAll) {\n//         const weights = store.getState().nodes.weight_coordinates;\n//         const additional_locations = store.getState().nodes.additional_destination_coordinates;\n//         const walls = store.getState().nodes.wall_coordinates;\n\n//         while (Object.keys(additional_locations).length !== 0) {\n//             let keys = Object.keys(additional_locations);\n//             dispatchedRemovedAdditionalDestination(keys[0]);\n//         }\n//         // for (let i = 0; i < additional_locations.length; i++) {\n//         //     let current = additional_locations[i]\n//         //     if (current[0] < grid_size && current[1] < grid_size) {\n//         //         shallow_copy[current[0]][current[1]] = { type: \"additional_destination_node\", visited: false, shortest_path: false };\n//         //     }\n//         //     else\n//         //     {\n//         //         dispatchedRemovedAdditionalDestination(current);    \n//         //     }\n\n\n//     for (let i = 0; i < weights.length; i++) {\n//         let current = weights[i]\n//         if (current[0] < grid_size && current[1] < grid_size) {\n//             shallow_copy[current[0]][current[1]] = { type: \"weight_node\", visited: false, shortest_path: false };\n//         }\n//         else {\n//             dispatchedRemovedWeight(current);\n//         }\n//     }\n\n\n\n//     for (let i = 0; i < walls.length; i++) {\n//         let current = walls[i]\n//         if (current[0] < grid_size && current[1] < grid_size) {\n//             shallow_copy[current[0]][current[1]] = { type: \"wall_node\", visited: false, shortest_path: false };\n//         }\n//         else {\n//             dispatchedRemovedWall(current);\n//         }\n//     }\n\n\n// }\n\n// dispatchedMovedStart()\n// dispatchedClearMatrix(shallow_copy);\n// dispatchedChangedNodeType(matrix)\n// }\n\nexport function clearPath() {\n    let grid = store.getState().grid;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid.length; j++) {\n            var element = document.getElementById(i + \"-\" + j);\n            element.classList.remove(\"visited-true\");\n            element.classList.remove(\"shortest-path-true\");\n            element.classList.add(\"visited-false\");\n            element.classList.add(\"shortest-path-false\");\n\n        }\n    }\n}"]},"metadata":{},"sourceType":"module"}