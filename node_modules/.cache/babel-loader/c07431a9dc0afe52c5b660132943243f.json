{"ast":null,"code":"import _regeneratorRuntime from\"/home/steven/SWE/Code/path-finding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _toConsumableArray from\"/home/steven/SWE/Code/path-finding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";var _marked=/*#__PURE__*/_regeneratorRuntime.mark(depthFirstSearch);import shallowCopy from\"../helpers/2d-array-functions/shallow-copy\";import{updatetoVisited}from\"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";import{checkNeighbors}from\"./helpers/matrix-helpers/async-helpers/check-neighbors\";import{updateParent}from\"./helpers/matrix-helpers/setters-and-getters/update-parent\";// import coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport getShortestPath from\"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";export default function depthFirstSearch(){var matrix,start_node_coordinates,end_node_coordinates,additional_destinations,walls,stack,path,end_coordinates,additional_dest,visited_coordinates,visited,parent_matrix,found,vertex_coordinates,new_path,add_to_visited_nodes,add_to_path,generator,result,value,undefined_or_path,_args=arguments;return _regeneratorRuntime.wrap(function depthFirstSearch$(_context){while(1){switch(_context.prev=_context.next){case 0:matrix=_args.length>0&&_args[0]!==undefined?_args[0]:[[]];start_node_coordinates=_args.length>1&&_args[1]!==undefined?_args[1]:[2,2];end_node_coordinates=_args.length>2&&_args[2]!==undefined?_args[2]:[0,0];additional_destinations=_args.length>3?_args[3]:undefined;walls=_args.length>4?_args[4]:undefined;// data structure for storing next values\nstack=[];path=[];// let start_coordinates = [...start_node_coordinates];\nend_coordinates=_toConsumableArray(end_node_coordinates);additional_dest=Object.assign({},additional_destinations);// coordinates that have been visited\nvisited_coordinates=[];// matrix that shows if a node at index [i][j] has been visited\nvisited=shallowCopy(matrix,false);// stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\nparent_matrix=shallowCopy(matrix,null);// if end is found\nfound=false;// pushing the starting coordintes into the stack, this will be where we start our search.\nstack.push(_toConsumableArray(start_node_coordinates));// while stack is not empty\ncase 14:if(!(stack.length!==0&&!found)){_context.next=32;break;}// the current verticies.\nvertex_coordinates=stack.pop();visited_coordinates.push(vertex_coordinates);if(!(additional_dest[vertex_coordinates]!==undefined)){_context.next=29;break;}delete additional_dest[vertex_coordinates];new_path=depthFirstSearch(matrix,vertex_coordinates,end_coordinates,additional_dest,walls);add_to_visited_nodes=new_path.next().value;add_to_path=new_path.next().value;visited_coordinates=visited_coordinates.concat(add_to_visited_nodes);// console.log(\"in additional[dest] - path pre-concat: \", path)\n// if no path to finish line\nif(!(add_to_path===undefined)){_context.next=25;break;}return _context.abrupt(\"break\",32);case 25:path=path.concat(add_to_path);console.log(\"in additional[dest] - path post-concat: \",path);end_coordinates=vertex_coordinates;found=true;case 29:if(vertex_coordinates[0]===end_coordinates[0]&&vertex_coordinates[1]===end_coordinates[1]&&Object.keys(additional_dest).length===0){found=true;}else{updatetoVisited(vertex_coordinates,visited);generator=checkNeighbors(vertex_coordinates,visited);result=generator.next();while(!result.done){value=result.value;if(!visited[value[0]][value[1]]&&walls[value]===undefined){updateParent(vertex_coordinates,value,parent_matrix);stack.push(value);}result=generator.next();}}_context.next=14;break;case 32:_context.next=34;return visited_coordinates;case 34:// could be undefined or a path\nundefined_or_path=getShortestPath(end_coordinates,parent_matrix);// if it is undefined, return undefined (void)\nif(!(undefined_or_path===undefined)){_context.next=37;break;}return _context.abrupt(\"return\");case 37:path=undefined_or_path.concat(path);console.log(\"path: \",path);_context.next=41;return path;case 41:case\"end\":return _context.stop();}}},_marked);}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/depth-first-search.js"],"names":["depthFirstSearch","shallowCopy","updatetoVisited","checkNeighbors","updateParent","getShortestPath","matrix","start_node_coordinates","end_node_coordinates","additional_destinations","walls","stack","path","end_coordinates","additional_dest","Object","assign","visited_coordinates","visited","parent_matrix","found","push","length","vertex_coordinates","pop","undefined","new_path","add_to_visited_nodes","next","value","add_to_path","concat","console","log","keys","generator","result","done","undefined_or_path"],"mappings":"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","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\n// import coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\n\n\nexport default function* depthFirstSearch(matrix = [[]], start_node_coordinates = [2, 2], end_node_coordinates = [0, 0], additional_destinations, walls) {\n    // data structure for storing next values\n    let stack = [];\n    let path = [];\n    // let start_coordinates = [...start_node_coordinates];\n    let end_coordinates = [...end_node_coordinates];\n    let additional_dest = Object.assign({}, additional_destinations);\n    // coordinates that have been visited\n    let visited_coordinates = [];\n\n    // matrix that shows if a node at index [i][j] has been visited\n    let visited = shallowCopy(matrix, false);\n    // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n    let parent_matrix = shallowCopy(matrix, null);\n    // if end is found\n    let found = false;\n    // pushing the starting coordintes into the stack, this will be where we start our search.\n    stack.push([...start_node_coordinates]);\n    // while stack is not empty\n    while (stack.length !== 0 && !found) {\n        // the current verticies.\n        let vertex_coordinates = stack.pop();\n        visited_coordinates.push(vertex_coordinates);\n\n        if (additional_dest[vertex_coordinates] !== undefined) {\n            delete additional_dest[vertex_coordinates];\n            let new_path = depthFirstSearch(matrix, vertex_coordinates, end_coordinates, additional_dest, walls);\n            let add_to_visited_nodes = new_path.next().value\n            let add_to_path = new_path.next().value\n            visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n            // console.log(\"in additional[dest] - path pre-concat: \", path)\n            // if no path to finish line\n            if (add_to_path === undefined)\n                break;\n            path = path.concat(add_to_path);\n            console.log(\"in additional[dest] - path post-concat: \", path)\n\n\n            end_coordinates = vertex_coordinates;\n            found = true;\n\n        }\n        if (((vertex_coordinates[0] === end_coordinates[0]) && (vertex_coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n            found = true;\n        }\n        else {\n            updatetoVisited(vertex_coordinates, visited);\n\n\n            const generator = checkNeighbors(vertex_coordinates, visited);\n            let result = generator.next();\n\n            while (!result.done) {\n                let value = result.value\n\n                if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n                    updateParent(vertex_coordinates, value, parent_matrix);\n                    stack.push(value);\n                }\n\n                result = generator.next();\n            }\n        }\n    }\n\n\n    yield visited_coordinates;\n\n    // could be undefined or a path\n    let undefined_or_path = getShortestPath(end_coordinates, parent_matrix);\n    // if it is undefined, return undefined (void)\n    if (undefined_or_path === undefined) {\n        return;\n    }\n\n    path = undefined_or_path.concat(path);\n\n    console.log(\"path: \", path)\n    yield path\n}\n\n"]},"metadata":{},"sourceType":"module"}