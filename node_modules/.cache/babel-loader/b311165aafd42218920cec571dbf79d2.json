{"ast":null,"code":"// 1  function Dijkstra(Graph, source):\n// 2\n// 3      create vertex set Q\n// 4\n// 5      for each vertex v in Graph:             \n// 6          dist[v] ← INFINITY                  \n// 7          prev[v] ← UNDEFINED                 \n// 8          add v to Q                      \n// 10      dist[source] ← 0                        \n// 11      \n// 12      while Q is not empty:\n// 13          u ← vertex in Q with min dist[u]    \n// 14                                              \n// 15          remove u from Q \n// 16          \n// 17          for each neighbor v of u:           // only v that are still in Q\n// 18              alt ← dist[u] + length(u, v)\n// 19              if alt < dist[v]:               \n// 20                  dist[v] ← alt \n// 21                  prev[v] ← u \n// 22\n// 23      return dist[], prev[]\nexport default function* dijkstra(matrix = [[]], source = matrix[0][0], final = matrix[3][3]) {\n  let adjacency_matrix = [...matrix];\n  let cordinates_tuple = [0, 0];\n  let visited = {}; // let distance = {}\n  // let vertex_priority_queue = new \n  // let unvisited_nodes = new Array(matrix.length * matrix.length)\n  // console.log(\"unvisited: \", unvisited_nodes);\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      if (source === adjacency_matrix[row][col]) {\n        adjacency_matrix[row][col] = 0;\n        cordinates_tuple = [row, col];\n        visited[(row, col)] = true;\n      } else {\n        adjacency_matrix[row][col] = Infinity;\n        visited[(row, col)] = false;\n      }\n\n      console.log(\"visited: \", visited[(row, col)]);\n    }\n  }\n\n  while (true) {}\n}\n\nfunction update_distances(node_location) {\n  const RIGHT = column + 1;\n  const LEFT = column - 1;\n  const UP = row - 1;\n  const DOWN = row + 1;\n}\n\nfunction* check_neighbors(row = 0, column = 0, visited) {\n  const RIGHT = column + 1;\n  const LEFT = column - 1;\n  const UP = row - 1;\n  const DOWN = row + 1;\n\n  if (RIGHT >= 0 && !visited[row][RIGHT]) {\n    yield [row, RIGHT];\n  }\n\n  if (LEFT >= 0 && !visited[row][LEFT]) {\n    yield [row, LEFT];\n  }\n\n  if (UP >= 0 && !visited[UP][column]) {\n    yield [UP, column];\n  }\n\n  if (DOWN >= 0 && !visited[DOWN][column]) {\n    yield [DOWN, column];\n  }\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/dijkstra.js"],"names":["dijkstra","matrix","source","final","adjacency_matrix","cordinates_tuple","visited","row","length","col","Infinity","console","log","update_distances","node_location","RIGHT","column","LEFT","UP","DOWN","check_neighbors"],"mappings":"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","sourcesContent":["// 1  function Dijkstra(Graph, source):\n// 2\n// 3      create vertex set Q\n// 4\n// 5      for each vertex v in Graph:             \n// 6          dist[v] ← INFINITY                  \n// 7          prev[v] ← UNDEFINED                 \n// 8          add v to Q                      \n// 10      dist[source] ← 0                        \n// 11      \n// 12      while Q is not empty:\n// 13          u ← vertex in Q with min dist[u]    \n// 14                                              \n// 15          remove u from Q \n// 16          \n// 17          for each neighbor v of u:           // only v that are still in Q\n// 18              alt ← dist[u] + length(u, v)\n// 19              if alt < dist[v]:               \n// 20                  dist[v] ← alt \n// 21                  prev[v] ← u \n// 22\n// 23      return dist[], prev[]\n\nexport default function* dijkstra(matrix = [[]], source = matrix[0][0], final = matrix[3][3]) {\n    let adjacency_matrix = [...matrix]\n    let cordinates_tuple = [0, 0];\n    let visited = {};\n    // let distance = {}\n    // let vertex_priority_queue = new \n\n    // let unvisited_nodes = new Array(matrix.length * matrix.length)\n    // console.log(\"unvisited: \", unvisited_nodes);\n\n    for (let row = 0; row < matrix.length; row++) {\n        for (let col = 0; col < matrix[row].length; col++) {\n            if (source === adjacency_matrix[row][col]) {\n                adjacency_matrix[row][col] = 0;\n                cordinates_tuple = [row, col];\n                visited[row, col] = true;\n            }\n            else {\n                adjacency_matrix[row][col] = Infinity;\n                visited[row, col] = false;\n            }\n            console.log(\"visited: \", visited[row, col])\n\n        }\n    }\n\n\n\n    while (true) {\n\n    }\n\n\n}\n\nfunction update_distances(node_location) {\n    const RIGHT = column + 1;\n    const LEFT = column - 1;\n    const UP = row - 1;\n    const DOWN = row + 1;\n}\n\nfunction* check_neighbors(row = 0, column = 0, visited) {\n    const RIGHT = column + 1;\n    const LEFT = column - 1;\n    const UP = row - 1;\n    const DOWN = row + 1;\n\n    if (RIGHT >= 0 && !visited[row][RIGHT]) {\n        yield [row, RIGHT];\n    }\n    if (LEFT >= 0 && !visited[row][LEFT]) {\n        yield [row, LEFT];\n    }\n\n    if (UP >= 0 && !visited[UP][column]) {\n        yield [UP, column];\n    }\n    if (DOWN >= 0 && !visited[DOWN][column]) {\n        yield [DOWN, column];\n    }\n\n}"]},"metadata":{},"sourceType":"module"}