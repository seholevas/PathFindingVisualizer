{"ast":null,"code":"// 1  function Dijkstra(Graph, source):\n// 2\n// 3      create vertex set Q\n// 4\n// 5      for each vertex v in Graph:             \n// 6          dist[v] ← INFINITY                  \n// 7          prev[v] ← UNDEFINED                 \n// 8          add v to Q                      \n// 10      dist[source] ← 0                        \n// 11      \n// 12      while Q is not empty:\n// 13          u ← vertex in Q with min dist[u]    \n// 14                                              \n// 15          remove u from Q \n// 16          \n// 17          for each neighbor v of u:           // only v that are still in Q\n// 18              alt ← dist[u] + length(u, v)\n// 19              if alt < dist[v]:               \n// 20                  dist[v] ← alt \n// 21                  prev[v] ← u \n// 22\n// 23      return dist[], prev[]\nexport default function* dijkstra(matrix = [[]], source = matrix[0][0], final = matrix[3][3]) {\n  let adjacency_matrix = [...matrix];\n  let cordinates_tuple = [0, 0]; // let unvisited_nodes = new Array(matrix.length * matrix.length)\n  // console.log(\"unvisited: \", unvisited_nodes);\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      if (source === adjacency_matrix[row][col]) {\n        adjacency_matrix[row][col] = 0;\n        cordinates_tuple = [row, col];\n      } else {\n        adjacency_matrix[row][col] = Infinity;\n      }\n    }\n  } // yield [...adjacency_matrix]\n\n}\n\nfunction* check_neighbors(row = 0, column = 0) {\n  const RIGHT = column + 1;\n  const LEFT = column - 1;\n  const UP = row - 1;\n  const DOWN = row + 1;\n\n  if (RIGHT >= 0) {\n    yield [row, RIGHT];\n  }\n\n  if (LEFT >= 0) {\n    yield [row, LEFT];\n  }\n\n  if (UP >= 0) {\n    yield [UP, column];\n  }\n\n  if (DOWN >= 0) {\n    yield [DOWN, column];\n  }\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/dijkstra.js"],"names":["dijkstra","matrix","source","final","adjacency_matrix","cordinates_tuple","row","length","col","Infinity","check_neighbors","column","RIGHT","LEFT","UP","DOWN"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,eAAe,UAAUA,QAAV,CAAmBC,MAAM,GAAG,CAAC,EAAD,CAA5B,EAAkCC,MAAM,GAAGD,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,CAA3C,EAAyDE,KAAK,GAAGF,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,CAAjE,EAA+E;AAC1F,MAAIG,gBAAgB,GAAG,CAAC,GAAGH,MAAJ,CAAvB;AACA,MAAII,gBAAgB,GAAG,CAAC,CAAD,EAAG,CAAH,CAAvB,CAF0F,CAI1F;AACA;;AAEA,OAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGL,MAAM,CAACM,MAA/B,EAAuCD,GAAG,EAA1C,EAA8C;AAC1C,SAAK,IAAIE,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGP,MAAM,CAACK,GAAD,CAAN,CAAYC,MAApC,EAA4CC,GAAG,EAA/C,EAAmD;AAC/C,UAAIN,MAAM,KAAKE,gBAAgB,CAACE,GAAD,CAAhB,CAAsBE,GAAtB,CAAf,EAA2C;AACvCJ,QAAAA,gBAAgB,CAACE,GAAD,CAAhB,CAAsBE,GAAtB,IAA6B,CAA7B;AACAH,QAAAA,gBAAgB,GAAG,CAACC,GAAD,EAAME,GAAN,CAAnB;AACH,OAHD,MAIK;AACDJ,QAAAA,gBAAgB,CAACE,GAAD,CAAhB,CAAsBE,GAAtB,IAA6BC,QAA7B;AACH;AACJ;AACJ,GAjByF,CAkB1F;;AAGH;;AAED,UAAUC,eAAV,CAA0BJ,GAAG,GAAC,CAA9B,EAAgCK,MAAM,GAAC,CAAvC,EACA;AACI,QAAMC,KAAK,GAAGD,MAAM,GAAG,CAAvB;AACA,QAAME,IAAI,GAAGF,MAAM,GAAG,CAAtB;AACA,QAAMG,EAAE,GAAGR,GAAG,GAAE,CAAhB;AACA,QAAMS,IAAI,GAAGT,GAAG,GAAE,CAAlB;;AAEA,MAAGM,KAAK,IAAI,CAAZ,EACA;AACI,UAAM,CAACN,GAAD,EAAKM,KAAL,CAAN;AACH;;AACD,MAAGC,IAAI,IAAG,CAAV,EACA;AACI,UAAM,CAACP,GAAD,EAAMO,IAAN,CAAN;AACH;;AAED,MAAGC,EAAE,IAAG,CAAR,EACA;AACI,UAAM,CAACA,EAAD,EAAKH,MAAL,CAAN;AACH;;AACD,MAAGI,IAAI,IAAG,CAAV,EACA;AACI,UAAM,CAACA,IAAD,EAAOJ,MAAP,CAAN;AACH;AAEJ","sourcesContent":["// 1  function Dijkstra(Graph, source):\n// 2\n// 3      create vertex set Q\n// 4\n// 5      for each vertex v in Graph:             \n// 6          dist[v] ← INFINITY                  \n// 7          prev[v] ← UNDEFINED                 \n// 8          add v to Q                      \n// 10      dist[source] ← 0                        \n// 11      \n// 12      while Q is not empty:\n// 13          u ← vertex in Q with min dist[u]    \n// 14                                              \n// 15          remove u from Q \n// 16          \n// 17          for each neighbor v of u:           // only v that are still in Q\n// 18              alt ← dist[u] + length(u, v)\n// 19              if alt < dist[v]:               \n// 20                  dist[v] ← alt \n// 21                  prev[v] ← u \n// 22\n// 23      return dist[], prev[]\n\nexport default function* dijkstra(matrix = [[]], source = matrix[0][0], final = matrix[3][3]) {\n    let adjacency_matrix = [...matrix]\n    let cordinates_tuple = [0,0];\n\n    // let unvisited_nodes = new Array(matrix.length * matrix.length)\n    // console.log(\"unvisited: \", unvisited_nodes);\n\n    for (let row = 0; row < matrix.length; row++) {\n        for (let col = 0; col < matrix[row].length; col++) {\n            if (source === adjacency_matrix[row][col]) {\n                adjacency_matrix[row][col] = 0;\n                cordinates_tuple = [row, col];\n            }\n            else {\n                adjacency_matrix[row][col] = Infinity;\n            }\n        }\n    }\n    // yield [...adjacency_matrix]\n\n\n}\n\nfunction* check_neighbors(row=0,column=0)\n{\n    const RIGHT = column + 1;\n    const LEFT = column - 1;\n    const UP = row -1;\n    const DOWN = row +1;\n\n    if(RIGHT >= 0)\n    {\n        yield [row,RIGHT];\n    }\n    if(LEFT >=0)\n    {\n        yield [row, LEFT];\n    }\n\n    if(UP >=0)\n    {\n        yield [UP, column];\n    }\n    if(DOWN >=0)\n    {\n        yield [DOWN, column];\n    }\n\n}"]},"metadata":{},"sourceType":"module"}