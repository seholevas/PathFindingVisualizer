{"ast":null,"code":"import { getValueByElementId } from \"../functions/get-value-by-element-id\";\nimport generateMatrix from \"../2d-array-functions/generate-matrix\";\nimport shallowCopy from \"../2d-array-functions/shallow-copy\";\nimport { dispatchedClearMatrix, dispatchedChangedNodeType } from \"../../redux/dispatchs/grid-dispatchs\";\nimport store from \"../../redux/stores/store\";\nimport { dispatchedRemovedAdditionalDestination, dispatchedRemovedWeight, dispatchedRemovedWall, dispatchedMovedStart, dispatchedAddedWall, dispatchedMovedEnd } from \"../../redux/dispatchs/node-dispatchs\"; // export function clearMatrix(isClearAll = true) \n// {\n//     // const size_of_matrix = getValueByElementId(\"size\");\n//     const grid_size = store.getState().grid.length;\n//     const matrix = generateMatrix(grid_size);\n//     const shallow_copy = shallowCopy(matrix);\n//     const start = store.getState().nodes.start_coordinates;\n//     const end = store.getState().nodes.end_coordinates;\n//     if ((start[0] < grid_size - 1) && (start[1] < grid_size - 1)) {\n//         shallow_copy[start[0]][start[1]] = { type: \"start_node\", visited: false, shortest_path: false };\n//     }\n//     else {\n//         dispatchedMovedStart([grid_size - 2, grid_size - 2])\n//         shallow_copy[grid_size - 2][grid_size - 2] = { type: \"start_node\", visited: false, shortest_path: false };\n//     }\n//     if (end[0] < grid_size - 1 && end[1] < grid_size - 1) {\n//         shallow_copy[end[0]][end[1]] = { type: \"end_node\", visited: false, shortest_path: false };\n//     }\n//     else {\n//         dispatchedMovedEnd([grid_size - 1, grid_size - 1])\n//         shallow_copy[grid_size - 1][grid_size - 1] = { type: \"end_node\", visited: false, shortest_path: false };\n//     }\n//     if (!isClearAll) {\n//         const weights = store.getState().nodes.weight_coordinates;\n//         const additional_locations = store.getState().nodes.additional_destination_coordinates;\n//         const walls = store.getState().nodes.wall_coordinates;\n//         while (Object.keys(additional_locations).length !== 0) {\n//             let keys = Object.keys(additional_locations);\n//             dispatchedRemovedAdditionalDestination(keys[0]);\n//         }\n//         // for (let i = 0; i < additional_locations.length; i++) {\n//         //     let current = additional_locations[i]\n//         //     if (current[0] < grid_size && current[1] < grid_size) {\n//         //         shallow_copy[current[0]][current[1]] = { type: \"additional_destination_node\", visited: false, shortest_path: false };\n//         //     }\n//         //     else\n//         //     {\n//         //         dispatchedRemovedAdditionalDestination(current);    \n//         //     }\n//     for (let i = 0; i < weights.length; i++) {\n//         let current = weights[i]\n//         if (current[0] < grid_size && current[1] < grid_size) {\n//             shallow_copy[current[0]][current[1]] = { type: \"weight_node\", visited: false, shortest_path: false };\n//         }\n//         else {\n//             dispatchedRemovedWeight(current);\n//         }\n//     }\n//     for (let i = 0; i < walls.length; i++) {\n//         let current = walls[i]\n//         if (current[0] < grid_size && current[1] < grid_size) {\n//             shallow_copy[current[0]][current[1]] = { type: \"wall_node\", visited: false, shortest_path: false };\n//         }\n//         else {\n//             dispatchedRemovedWall(current);\n//         }\n//     }\n// }\n// dispatchedMovedStart()\n// dispatchedClearMatrix(shallow_copy);\n// dispatchedChangedNodeType(matrix)\n// }\n\nexport function clearPath() {\n  let grid = store.getState().grid;\n  let copy = shallowCopy(grid);\n\n  for (let i = 0; i < copy.length; i++) {\n    for (let j = 0; j < copy.length; j++) {\n      let node = copy[i][j];\n      node[\"visited\"] = false;\n      node[\"shortest_path\"] = false;\n      copy[i][j] = node;\n    }\n  }\n\n  dispatchedChangedNodeType(copy);\n}\nexport function clearAll() {\n  clearPath();\n  let grid = store.getState().grid;\n  let copy = shallowCopy(grid);\n\n  for (let i = 0; i < copy.length; i++) {\n    for (let j = 0; j < copy.length; j++) {\n      let node = copy[i][j];\n      var type = null;\n\n      if (node['type'] !== \"start_node\" && node[\"type\"] !== \"end_node\") {\n        type = node['type'];\n        node = {\n          type: \"empty_node\",\n          visited: false,\n          shortest_path: false\n        };\n        copy[i][j] = node;\n      }\n\n      switch (type) {\n        case \"additional_destination_node\":\n          dispatchedRemovedAdditionalDestination([i, j]);\n          break;\n\n        case \"weight_node\":\n          dispatchedRemovedWeight([i, j]);\n          break;\n\n        case \"wall_node\":\n          dispatchedRemovedWall([i, j]);\n          break;\n\n        default:\n          break;\n      }\n    }\n  }\n\n  dispatchedChangedNodeType(copy);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/helpers/state-functions/clear-matrix.js"],"names":["getValueByElementId","generateMatrix","shallowCopy","dispatchedClearMatrix","dispatchedChangedNodeType","store","dispatchedRemovedAdditionalDestination","dispatchedRemovedWeight","dispatchedRemovedWall","dispatchedMovedStart","dispatchedAddedWall","dispatchedMovedEnd","clearPath","grid","getState","copy","i","length","j","node","clearAll","type","visited","shortest_path"],"mappings":"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","sourcesContent":["import { getValueByElementId } from \"../functions/get-value-by-element-id\";\nimport generateMatrix from \"../2d-array-functions/generate-matrix\";\nimport shallowCopy from \"../2d-array-functions/shallow-copy\";\nimport { dispatchedClearMatrix, dispatchedChangedNodeType } from \"../../redux/dispatchs/grid-dispatchs\";\nimport store from \"../../redux/stores/store\";\nimport { dispatchedRemovedAdditionalDestination, dispatchedRemovedWeight, dispatchedRemovedWall, dispatchedMovedStart, dispatchedAddedWall, dispatchedMovedEnd } from \"../../redux/dispatchs/node-dispatchs\";\n\n// export function clearMatrix(isClearAll = true) \n// {\n//     // const size_of_matrix = getValueByElementId(\"size\");\n//     const grid_size = store.getState().grid.length;\n//     const matrix = generateMatrix(grid_size);\n//     const shallow_copy = shallowCopy(matrix);\n//     const start = store.getState().nodes.start_coordinates;\n//     const end = store.getState().nodes.end_coordinates;\n\n\n//     if ((start[0] < grid_size - 1) && (start[1] < grid_size - 1)) {\n//         shallow_copy[start[0]][start[1]] = { type: \"start_node\", visited: false, shortest_path: false };\n//     }\n//     else {\n//         dispatchedMovedStart([grid_size - 2, grid_size - 2])\n//         shallow_copy[grid_size - 2][grid_size - 2] = { type: \"start_node\", visited: false, shortest_path: false };\n//     }\n//     if (end[0] < grid_size - 1 && end[1] < grid_size - 1) {\n//         shallow_copy[end[0]][end[1]] = { type: \"end_node\", visited: false, shortest_path: false };\n//     }\n//     else {\n//         dispatchedMovedEnd([grid_size - 1, grid_size - 1])\n//         shallow_copy[grid_size - 1][grid_size - 1] = { type: \"end_node\", visited: false, shortest_path: false };\n\n//     }\n\n//     if (!isClearAll) {\n//         const weights = store.getState().nodes.weight_coordinates;\n//         const additional_locations = store.getState().nodes.additional_destination_coordinates;\n//         const walls = store.getState().nodes.wall_coordinates;\n\n//         while (Object.keys(additional_locations).length !== 0) {\n//             let keys = Object.keys(additional_locations);\n//             dispatchedRemovedAdditionalDestination(keys[0]);\n//         }\n//         // for (let i = 0; i < additional_locations.length; i++) {\n//         //     let current = additional_locations[i]\n//         //     if (current[0] < grid_size && current[1] < grid_size) {\n//         //         shallow_copy[current[0]][current[1]] = { type: \"additional_destination_node\", visited: false, shortest_path: false };\n//         //     }\n//         //     else\n//         //     {\n//         //         dispatchedRemovedAdditionalDestination(current);    \n//         //     }\n\n\n//     for (let i = 0; i < weights.length; i++) {\n//         let current = weights[i]\n//         if (current[0] < grid_size && current[1] < grid_size) {\n//             shallow_copy[current[0]][current[1]] = { type: \"weight_node\", visited: false, shortest_path: false };\n//         }\n//         else {\n//             dispatchedRemovedWeight(current);\n//         }\n//     }\n\n\n\n//     for (let i = 0; i < walls.length; i++) {\n//         let current = walls[i]\n//         if (current[0] < grid_size && current[1] < grid_size) {\n//             shallow_copy[current[0]][current[1]] = { type: \"wall_node\", visited: false, shortest_path: false };\n//         }\n//         else {\n//             dispatchedRemovedWall(current);\n//         }\n//     }\n\n\n// }\n\n// dispatchedMovedStart()\n// dispatchedClearMatrix(shallow_copy);\n// dispatchedChangedNodeType(matrix)\n// }\n\nexport function clearPath() {\n    let grid = store.getState().grid;\n    let copy = shallowCopy(grid);\n    for (let i = 0; i < copy.length; i++) {\n        for (let j = 0; j < copy.length; j++) {\n            let node = copy[i][j]\n            node[\"visited\"] = false;\n            node[\"shortest_path\"] = false;\n            copy[i][j] = node;\n\n        }\n    }\n    dispatchedChangedNodeType(copy);\n}\n\nexport function clearAll()\n{\n    clearPath();\n    let grid = store.getState().grid;\n    let copy = shallowCopy(grid);\n    for (let i = 0; i < copy.length; i++) {\n        for (let j = 0; j < copy.length; j++) {\n            let node = copy[i][j]\n            var type = null;\n            if(node['type'] !== \"start_node\" && node[\"type\"] !== \"end_node\")\n            {\n               type = node['type']\n               node = { type: \"empty_node\", visited: false, shortest_path: false} \n               copy[i][j] = node;\n            }\n\n            switch(type)\n            {\n                case \"additional_destination_node\":\n                    dispatchedRemovedAdditionalDestination([i,j]);\n                    break;\n                case \"weight_node\":\n                    dispatchedRemovedWeight([i,j]);\n                    break;\n                case \"wall_node\":\n                    dispatchedRemovedWall([i,j]);\n                    break;\n                default:\n                    break;\n            }\n\n        }\n        \n    }\n    dispatchedChangedNodeType(copy);\n}"]},"metadata":{},"sourceType":"module"}