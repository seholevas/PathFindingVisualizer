{"ast":null,"code":"// 1  procedure BFS(G, root) is\n// 2      let Q be a queue\n// 3      label root as discovered\n// 4      Q.enqueue(root)\n// 5      while Q is not empty do\n// 6          v := Q.dequeue()\n// 7          if v is the goal then\n// 8              return v\n// 9          for all edges from v to w in G.adjacentEdges(v) do\n// 10             if w is not labeled as discovered then\n// 11                 label w as discovered\n// 12                 w.parent := v\n// 13                 Q.enqueue(w)\nimport shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nexport function* breadthFirstSearch(matrix = [[]], start_coordinates = [2, 2], end_coordinates = [3, 3]) {\n  yield start_coordinates;\n  let queue = [];\n  let visited = shallowCopy(matrix, false);\n  let parent_matrix = shallowCopy(matrix, null);\n  console.log(\"visited: \", visited);\n  visited[start_coordinates[0]][start_coordinates[1]] = true;\n  queue.push(start_coordinates);\n\n  while (queue.length !== 0) {\n    let vertex_coordinates = queue.pop();\n\n    if (vertex_coordinates == end_coordinates) {\n      return vertex_coordinates;\n    } // f\n\n  } // console.log(visited);\n\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/breadth-first-search.js"],"names":["shallowCopy","breadthFirstSearch","matrix","start_coordinates","end_coordinates","queue","visited","parent_matrix","console","log","push","length","vertex_coordinates","pop"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,WAAP,MAAwB,4CAAxB;AAEA,OAAO,UAAUC,kBAAV,CAA6BC,MAAM,GAAC,CAAC,EAAD,CAApC,EAA0CC,iBAAiB,GAAG,CAAC,CAAD,EAAG,CAAH,CAA9D,EAAqEC,eAAe,GAAC,CAAC,CAAD,EAAG,CAAH,CAArF,EACP;AACI,QAAMD,iBAAN;AAEA,MAAIE,KAAK,GAAG,EAAZ;AACA,MAAIC,OAAO,GAAGN,WAAW,CAACE,MAAD,EAAS,KAAT,CAAzB;AACA,MAAIK,aAAa,GAAGP,WAAW,CAACE,MAAD,EAAS,IAAT,CAA/B;AACAM,EAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyBH,OAAzB;AACAA,EAAAA,OAAO,CAACH,iBAAiB,CAAC,CAAD,CAAlB,CAAP,CAA8BA,iBAAiB,CAAC,CAAD,CAA/C,IAAsD,IAAtD;AACAE,EAAAA,KAAK,CAACK,IAAN,CAAWP,iBAAX;;AAGA,SAAME,KAAK,CAACM,MAAN,KAAiB,CAAvB,EACA;AACI,QAAIC,kBAAkB,GAAGP,KAAK,CAACQ,GAAN,EAAzB;;AACA,QAAGD,kBAAkB,IAAIR,eAAzB,EACA;AACI,aAAOQ,kBAAP;AACH,KALL,CAOI;;AACH,GApBL,CAqBI;;AACH","sourcesContent":["// 1  procedure BFS(G, root) is\n// 2      let Q be a queue\n// 3      label root as discovered\n// 4      Q.enqueue(root)\n// 5      while Q is not empty do\n// 6          v := Q.dequeue()\n// 7          if v is the goal then\n// 8              return v\n// 9          for all edges from v to w in G.adjacentEdges(v) do\n// 10             if w is not labeled as discovered then\n// 11                 label w as discovered\n// 12                 w.parent := v\n// 13                 Q.enqueue(w)\n\nimport shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\n\nexport function* breadthFirstSearch(matrix=[[]], start_coordinates = [2,2], end_coordinates=[3,3])\n{\n    yield start_coordinates;\n\n    let queue = [];\n    let visited = shallowCopy(matrix, false);\n    let parent_matrix = shallowCopy(matrix, null);\n    console.log(\"visited: \", visited);\n    visited[start_coordinates[0]][start_coordinates[1]] = true;\n    queue.push(start_coordinates);\n    \n\n    while(queue.length !== 0)\n    {\n        let vertex_coordinates = queue.pop();\n        if(vertex_coordinates == end_coordinates)\n        {\n            return vertex_coordinates;\n        }\n\n        // f\n    }\n    // console.log(visited);\n}"]},"metadata":{},"sourceType":"module"}