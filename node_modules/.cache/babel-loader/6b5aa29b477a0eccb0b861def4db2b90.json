{"ast":null,"code":"import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nexport default function* depthFirstSearch(matrix = [[]], start_node_coordinates = [2, 2], end_node_coordinates = [0, 0], additional_destinations, walls) {\n  // data structure for storing next values\n  let stack = [];\n  let start_coordinates = [...start_node_coordinates];\n  let end_coordinates = [...end_node_coordinates];\n  let additional_dest = Object.assign({}, additional_destinations); // coordinates that have been visited\n\n  let visited_coordinates = []; // matrix that shows if a node at index [i][j] has been visited\n\n  let visited = shallowCopy(matrix, false); // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n\n  let parent_matrix = shallowCopy(matrix, null); // if end is found\n\n  let found = false; // pushing the starting coordintes into the stack, this will be where we start our search.\n\n  stack.push([...start_node_coordinates]); // while stack is not empty\n\n  while (stack.length !== 0 && !found) {\n    // the current verticies.\n    let vertex_coordinates = stack.pop();\n    visited_coordinates.push(vertex_coordinates);\n\n    if (additional_dest[vertex_coordinates] !== undefined) {\n      delete additional_dest[vertex_coordinates];\n      let new_path = depthFirstSearch(matrix, vertex_coordinates, end_coordinates, additional_dest, walls);\n      let add_to_visited_nodes = new_path.next().value;\n      let add_to_path = new_path.next().value;\n      visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n      console.log(\"in additional[dest] - path pre-concat: \", path); // if no path to finish line\n\n      if (add_to_path === undefined) break;\n      path = path.concat(add_to_path);\n      console.log(\"in additional[dest] - path post-concat: \", path);\n      end_coordinates = vertex_coordinates;\n      found = true;\n    }\n\n    if (vertex_coordinates[0] === end_coordinates[0] && vertex_coordinates[1] === end_coordinates[1] && Object.keys(additional_dest).length === 0) {\n      found = true;\n    } else {\n      updatetoVisited(vertex_coordinates, visited);\n      const generator = checkNeighbors(vertex_coordinates, visited);\n      let result = generator.next();\n\n      while (!result.done) {\n        let value = result.value;\n\n        if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n          updateParent(vertex_coordinates, value, parent_matrix);\n          stack.push(value);\n        }\n\n        result = generator.next();\n      }\n    } // if(coordinatesAreEqual(vertex_coordinates, end_node_coordinates))\n    // {\n    //     found = true;\n    //     yield visited_coordinates;\n    //     continue;\n    // }\n    // if (!visited[vertex_coordinates[0]][vertex_coordinates[1]] && !found) {\n    // }\n\n  } // yield* traverseShortestPath(end_node_coordinates, parent_matrix);\n\n\n  yield getShortestPath(end_node_coordinates, parent_matrix);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/depth-first-search.js"],"names":["shallowCopy","updatetoVisited","checkNeighbors","updateParent","coordinatesAreEqual","getShortestPath","depthFirstSearch","matrix","start_node_coordinates","end_node_coordinates","additional_destinations","walls","stack","start_coordinates","end_coordinates","additional_dest","Object","assign","visited_coordinates","visited","parent_matrix","found","push","length","vertex_coordinates","pop","undefined","new_path","add_to_visited_nodes","next","value","add_to_path","concat","console","log","path","keys","generator","result","done"],"mappings":"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","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\n\n\nexport default function* depthFirstSearch(matrix = [[]], start_node_coordinates = [2, 2], end_node_coordinates = [0, 0], additional_destinations, walls) {\n    // data structure for storing next values\n    let stack = [];\n    let start_coordinates = [...start_node_coordinates];\n    let end_coordinates = [...end_node_coordinates];\n    let additional_dest = Object.assign({}, additional_destinations);\n    // coordinates that have been visited\n    let visited_coordinates = [];\n\n    // matrix that shows if a node at index [i][j] has been visited\n    let visited = shallowCopy(matrix, false);\n    // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n    let parent_matrix = shallowCopy(matrix, null);\n    // if end is found\n    let found = false;\n    // pushing the starting coordintes into the stack, this will be where we start our search.\n    stack.push([...start_node_coordinates]);\n    // while stack is not empty\n    while (stack.length !== 0 && !found) {\n        // the current verticies.\n        let vertex_coordinates = stack.pop();\n        visited_coordinates.push(vertex_coordinates);\n\n        if (additional_dest[vertex_coordinates] !== undefined) {\n            delete additional_dest[vertex_coordinates];\n            let new_path = depthFirstSearch(matrix, vertex_coordinates, end_coordinates, additional_dest, walls);\n            let add_to_visited_nodes = new_path.next().value\n            let add_to_path = new_path.next().value\n            visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n            console.log(\"in additional[dest] - path pre-concat: \", path)\n            // if no path to finish line\n            if (add_to_path === undefined)\n                break;\n            path = path.concat(add_to_path);\n            console.log(\"in additional[dest] - path post-concat: \", path)\n\n\n            end_coordinates = vertex_coordinates;\n            found = true;\n\n        }\n        if (((vertex_coordinates[0] === end_coordinates[0]) && (vertex_coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n            found = true;\n        }\n        else {\n            updatetoVisited(vertex_coordinates, visited);\n\n\n            const generator = checkNeighbors(vertex_coordinates, visited);\n            let result = generator.next();\n\n            while (!result.done) {\n                let value = result.value\n\n                if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n                    updateParent(vertex_coordinates, value, parent_matrix);\n                    stack.push(value);\n                }\n\n                result = generator.next();\n            }\n        }\n\n\n\n        // if(coordinatesAreEqual(vertex_coordinates, end_node_coordinates))\n        // {\n        //     found = true;\n        //     yield visited_coordinates;\n        //     continue;\n        // }\n\n        // if (!visited[vertex_coordinates[0]][vertex_coordinates[1]] && !found) {\n\n        // }\n    }\n\n    // yield* traverseShortestPath(end_node_coordinates, parent_matrix);\n\n    yield getShortestPath(end_node_coordinates, parent_matrix);\n}\n\n"]},"metadata":{},"sourceType":"module"}