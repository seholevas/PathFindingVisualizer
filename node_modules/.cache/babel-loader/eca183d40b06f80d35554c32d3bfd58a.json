{"ast":null,"code":"// procedure DFS_iterative(G, v) is\n//     let S be a stack\n//     S.push(v)\n//     while S is not empty do\n//         v = S.pop()\n//         if v is not labeled as discovered then\n//             label v as discovered\n//             for all edges from v to w in G.adjacentEdges(v) do \n//                 S.push(w)\nimport shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nexport default function* depthFirstSearch(adjacency_matrix = [[]], start_node_coordinates = [2, 2], end_node_coordinates = [3, 3]) {\n  // data structure for storing next values\n  let stack = []; // matrix that shows if a node at index [i][j] has been visited\n\n  let visited = shallowCopy(adjacency_matrix, false); // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n\n  let parent_matrix = shallowCopy(adjacency_matrix, null); // if end is found\n\n  let found = false; // pushing the starting coordintes into the stack, this will be where we start our search.\n\n  stack.push([...start_node_coordinates]); // while stack is not empty\n\n  while (stack.length !== 0 && !found) {\n    // the current verticies.\n    let vertex_coordinates = stack.pop(); // yielding the coordinates\n\n    yield [...vertex_coordinates];\n    if (coordinatesAreEqual(vertex_coordinates, end_node_coordinates)) if (!visited[vertex_coordinates[0]][vertex_coordinates[1]]) {\n      updatetoVisited(vertex_coordinates, visited);\n      const generator = checkNeighbors(vertex_coordinates, visited);\n      let result = generator.next();\n\n      while (!result.done) {\n        let value = result.value;\n\n        if (!visited[value[0]][value[1]]) {\n          updateParent(vertex_coordinates, value, parent_matrix);\n          stack.push(value);\n        }\n\n        result = generator.next();\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/depth-first-search.js"],"names":["shallowCopy","updatetoVisited","checkNeighbors","updateParent","coordinatesAreEqual","depthFirstSearch","adjacency_matrix","start_node_coordinates","end_node_coordinates","stack","visited","parent_matrix","found","push","length","vertex_coordinates","pop","generator","result","next","done","value"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,WAAP,MAAwB,4CAAxB;AACA,SAASC,eAAT,QAAgC,gEAAhC;AACA,SAASC,cAAT,QAA+B,wDAA/B;AACA,SAASC,YAAT,QAA6B,4DAA7B;AACA,OAAOC,mBAAP,MAAgC,oEAAhC;AAGA,eAAe,UAAUC,gBAAV,CAA2BC,gBAAgB,GAAG,CAAC,EAAD,CAA9C,EAAoDC,sBAAsB,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA7E,EAAqFC,oBAAoB,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA5G,EAAoH;AAC/H;AACA,MAAIC,KAAK,GAAG,EAAZ,CAF+H,CAG/H;;AACA,MAAIC,OAAO,GAAGV,WAAW,CAACM,gBAAD,EAAmB,KAAnB,CAAzB,CAJ+H,CAK/H;;AACA,MAAIK,aAAa,GAAGX,WAAW,CAACM,gBAAD,EAAmB,IAAnB,CAA/B,CAN+H,CAO/H;;AACA,MAAIM,KAAK,GAAG,KAAZ,CAR+H,CAS/H;;AACAH,EAAAA,KAAK,CAACI,IAAN,CAAW,CAAC,GAAGN,sBAAJ,CAAX,EAV+H,CAW/H;;AACA,SAAOE,KAAK,CAACK,MAAN,KAAiB,CAAjB,IAAsB,CAACF,KAA9B,EAAqC;AACjC;AACA,QAAIG,kBAAkB,GAAGN,KAAK,CAACO,GAAN,EAAzB,CAFiC,CAGjC;;AACA,UAAM,CAAC,GAAGD,kBAAJ,CAAN;AAEA,QAAGX,mBAAmB,CAACW,kBAAD,EAAqBP,oBAArB,CAAtB,EACA,IAAI,CAACE,OAAO,CAACK,kBAAkB,CAAC,CAAD,CAAnB,CAAP,CAA+BA,kBAAkB,CAAC,CAAD,CAAjD,CAAL,EAA4D;AACxDd,MAAAA,eAAe,CAACc,kBAAD,EAAqBL,OAArB,CAAf;AAGA,YAAMO,SAAS,GAAGf,cAAc,CAACa,kBAAD,EAAqBL,OAArB,CAAhC;AACA,UAAIQ,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAb;;AAEA,aAAO,CAACD,MAAM,CAACE,IAAf,EAAqB;AACjB,YAAIC,KAAK,GAAGH,MAAM,CAACG,KAAnB;;AAEA,YAAI,CAACX,OAAO,CAACW,KAAK,CAAC,CAAD,CAAN,CAAP,CAAkBA,KAAK,CAAC,CAAD,CAAvB,CAAL,EAAkC;AAC9BlB,UAAAA,YAAY,CAACY,kBAAD,EAAqBM,KAArB,EAA4BV,aAA5B,CAAZ;AACAF,UAAAA,KAAK,CAACI,IAAN,CAAWQ,KAAX;AACH;;AAEDH,QAAAA,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAT;AACH;AACJ;AAGJ;AACJ","sourcesContent":["// procedure DFS_iterative(G, v) is\n//     let S be a stack\n//     S.push(v)\n//     while S is not empty do\n//         v = S.pop()\n//         if v is not labeled as discovered then\n//             label v as discovered\n//             for all edges from v to w in G.adjacentEdges(v) do \n//                 S.push(w)\n\nimport shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\n\n\nexport default function* depthFirstSearch(adjacency_matrix = [[]], start_node_coordinates = [2, 2], end_node_coordinates = [3, 3]) {\n    // data structure for storing next values\n    let stack = [];\n    // matrix that shows if a node at index [i][j] has been visited\n    let visited = shallowCopy(adjacency_matrix, false);\n    // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n    let parent_matrix = shallowCopy(adjacency_matrix, null);\n    // if end is found\n    let found = false;\n    // pushing the starting coordintes into the stack, this will be where we start our search.\n    stack.push([...start_node_coordinates]);\n    // while stack is not empty\n    while (stack.length !== 0 && !found) {\n        // the current verticies.\n        let vertex_coordinates = stack.pop();\n        // yielding the coordinates\n        yield [...vertex_coordinates];\n\n        if(coordinatesAreEqual(vertex_coordinates, end_node_coordinates))\n        if (!visited[vertex_coordinates[0]][vertex_coordinates[1]]) {\n            updatetoVisited(vertex_coordinates, visited);\n\n\n            const generator = checkNeighbors(vertex_coordinates, visited);\n            let result = generator.next();\n\n            while (!result.done) {\n                let value = result.value\n\n                if (!visited[value[0]][value[1]]) {\n                    updateParent(vertex_coordinates, value, parent_matrix);\n                    stack.push(value);\n                }\n\n                result = generator.next();\n            }\n        }\n\n\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}