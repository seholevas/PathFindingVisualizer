{"ast":null,"code":"import { getValueByElementId } from \"../functions/get-value-by-element-id\";\nimport generateMatrix from \"../2d-array-functions/generate-matrix\";\nimport shallowCopy from \"../2d-array-functions/shallow-copy\";\nimport { dispatchedClearMatrix } from \"../../redux/dispatchs/grid-dispatchs\";\nimport store from \"../../redux/stores/store\";\nexport function clearMatrix(isClearAll = true) {\n  const size_of_matrix = getValueByElementId(\"size\");\n  const matrix = generateMatrix(size_of_matrix);\n  const shallow_copy = shallowCopy(matrix);\n  const start = store.getState().nodes.start_coordinates;\n  const end = store.getState().nodes.end_coordinates;\n  shallow_copy[start[0]][start[1]] = {\n    type: \"start_node\",\n    visited: false,\n    shortest_path: false\n  };\n  shallow_copy[end[0]][end[1]] = {\n    type: \"end_node\",\n    visited: false,\n    shortest_path: false\n  };\n\n  if (!isClearAll) {\n    const weights = store.getState().nodes.weight_coordinates;\n    const additional_locations = store.getState().nodes.additional_destination_coordinates;\n    const walls = store.getState().nodes.wall_coordinates;\n\n    for (let i = 0; i < weights; i++) {\n      let current = weights[i];\n    }\n  }\n\n  dispatchedClearMatrix(shallow_copy); // dispatchedChangedNodeType(matrix)\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/helpers/state-functions/clear-matrix.js"],"names":["getValueByElementId","generateMatrix","shallowCopy","dispatchedClearMatrix","store","clearMatrix","isClearAll","size_of_matrix","matrix","shallow_copy","start","getState","nodes","start_coordinates","end","end_coordinates","type","visited","shortest_path","weights","weight_coordinates","additional_locations","additional_destination_coordinates","walls","wall_coordinates","i","current"],"mappings":"AAAA,SAASA,mBAAT,QAAoC,sCAApC;AACA,OAAOC,cAAP,MAA2B,uCAA3B;AACA,OAAOC,WAAP,MAAwB,oCAAxB;AACA,SAASC,qBAAT,QAAsC,sCAAtC;AACA,OAAOC,KAAP,MAAkB,0BAAlB;AAEA,OAAO,SAASC,WAAT,CAAqBC,UAAU,GAAG,IAAlC,EACP;AACI,QAAMC,cAAc,GAAGP,mBAAmB,CAAC,MAAD,CAA1C;AACA,QAAMQ,MAAM,GAAGP,cAAc,CAACM,cAAD,CAA7B;AACA,QAAME,YAAY,GAAGP,WAAW,CAACM,MAAD,CAAhC;AACA,QAAME,KAAK,GAAGN,KAAK,CAACO,QAAN,GAAiBC,KAAjB,CAAuBC,iBAArC;AACA,QAAMC,GAAG,GAAGV,KAAK,CAACO,QAAN,GAAiBC,KAAjB,CAAuBG,eAAnC;AACAN,EAAAA,YAAY,CAACC,KAAK,CAAC,CAAD,CAAN,CAAZ,CAAuBA,KAAK,CAAC,CAAD,CAA5B,IAAmC;AAAEM,IAAAA,IAAI,EAAE,YAAR;AAAsBC,IAAAA,OAAO,EAAE,KAA/B;AAAsCC,IAAAA,aAAa,EAAE;AAArD,GAAnC;AACAT,EAAAA,YAAY,CAACK,GAAG,CAAC,CAAD,CAAJ,CAAZ,CAAqBA,GAAG,CAAC,CAAD,CAAxB,IAA+B;AAAEE,IAAAA,IAAI,EAAE,UAAR;AAAoBC,IAAAA,OAAO,EAAE,KAA7B;AAAoCC,IAAAA,aAAa,EAAE;AAAnD,GAA/B;;AAEA,MAAG,CAACZ,UAAJ,EACA;AACI,UAAMa,OAAO,GAAGf,KAAK,CAACO,QAAN,GAAiBC,KAAjB,CAAuBQ,kBAAvC;AACA,UAAMC,oBAAoB,GAAGjB,KAAK,CAACO,QAAN,GAAiBC,KAAjB,CAAuBU,kCAApD;AACA,UAAMC,KAAK,GAAGnB,KAAK,CAACO,QAAN,GAAiBC,KAAjB,CAAuBY,gBAArC;;AAEA,SAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGN,OAAnB,EAA4BM,CAAC,EAA7B,EACA;AACI,UAAIC,OAAO,GAAGP,OAAO,CAACM,CAAD,CAArB;AACH;AAGJ;;AAGDtB,EAAAA,qBAAqB,CAACM,YAAD,CAArB,CAxBJ,CAyBI;AACH","sourcesContent":["import { getValueByElementId } from \"../functions/get-value-by-element-id\";\nimport generateMatrix from \"../2d-array-functions/generate-matrix\";\nimport shallowCopy from \"../2d-array-functions/shallow-copy\";\nimport { dispatchedClearMatrix } from \"../../redux/dispatchs/grid-dispatchs\";\nimport store from \"../../redux/stores/store\";\n\nexport function clearMatrix(isClearAll = true)\n{\n    const size_of_matrix = getValueByElementId(\"size\");\n    const matrix = generateMatrix(size_of_matrix);\n    const shallow_copy = shallowCopy(matrix);\n    const start = store.getState().nodes.start_coordinates;\n    const end = store.getState().nodes.end_coordinates;\n    shallow_copy[start[0]][start[1]] = { type: \"start_node\", visited: false, shortest_path: false};\n    shallow_copy[end[0]][end[1]] = { type: \"end_node\", visited: false, shortest_path: false};\n    \n    if(!isClearAll)\n    {\n        const weights = store.getState().nodes.weight_coordinates;\n        const additional_locations = store.getState().nodes.additional_destination_coordinates;\n        const walls = store.getState().nodes.wall_coordinates;\n\n        for(let i = 0; i < weights; i++)\n        {\n            let current = weights[i]\n        } \n\n\n    }\n\n\n    dispatchedClearMatrix(shallow_copy);\n    // dispatchedChangedNodeType(matrix)\n}"]},"metadata":{},"sourceType":"module"}