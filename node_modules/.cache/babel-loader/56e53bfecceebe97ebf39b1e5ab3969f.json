{"ast":null,"code":"import _regeneratorRuntime from\"/home/steven/SWE/Code/path-finding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _toConsumableArray from\"/home/steven/SWE/Code/path-finding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";var _marked=/*#__PURE__*/_regeneratorRuntime.mark(aStar);import shallowCopy from\"../helpers/2d-array-functions/shallow-copy\";import{checkNeighbors}from\"./helpers/matrix-helpers/async-helpers/check-neighbors\";// import { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport{PriorityQueue}from\"../data-structures/priority-queue\";import{updatetoVisited}from\"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";import getShortestPath from\"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";// import { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nimport{calculateWeight}from\"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";import{updateParent}from\"./helpers/matrix-helpers/setters-and-getters/update-parent\";import{updateDistance}from\"./helpers/matrix-helpers/setters-and-getters/update-distance\";export default function aStar(){var matrix,start,end,additional_destinations,walls,weights,found,start_coordinates,end_coordinates,priority_queue,visited_coordinates,path,parent_matrix,visited,distance_matrix,q_item,current_coordinates,keys,next_dest,new_path,add_to_visited_nodes,add_shortest_path,generator,result,neighbor_coordinates,have_visited,cost_from_current_node,f_cost,is_current_cost_less,is_neighbor_in_priority_queue,undefined_or_path,_args=arguments;return _regeneratorRuntime.wrap(function aStar$(_context){while(1){switch(_context.prev=_context.next){case 0:matrix=_args.length>0&&_args[0]!==undefined?_args[0]:[[]];start=_args.length>1&&_args[1]!==undefined?_args[1]:[0,0];end=_args.length>2&&_args[2]!==undefined?_args[2]:[3,3];additional_destinations=_args.length>3&&_args[3]!==undefined?_args[3]:{};walls=_args.length>4&&_args[4]!==undefined?_args[4]:{};weights=_args.length>5&&_args[5]!==undefined?_args[5]:{};found=false;start_coordinates=_toConsumableArray(start);end_coordinates=_toConsumableArray(end);priority_queue=new PriorityQueue();// let additional_dest = Object.assign({}, additional_destinations);\nvisited_coordinates=[];path=[];parent_matrix=shallowCopy(matrix,null);visited=shallowCopy(matrix,false);distance_matrix=shallowCopy(matrix,Infinity);distance_matrix[start_coordinates[0]][start_coordinates[1]]=0;// updatetoVisited(start_coordinates, visited);\n// visited_coordinates.push(start_coordinates)\npriority_queue.enqueue(_toConsumableArray(start_coordinates),manhattanDistance(start_coordinates,end_coordinates));while(!priority_queue.isEmpty()&&!found){q_item=priority_queue.dequeue();// let f_cost = tuple[0];\ncurrent_coordinates=q_item.element;if(!visited[current_coordinates[0]][current_coordinates[1]]){updatetoVisited(current_coordinates,visited);visited_coordinates.push(current_coordinates);}if(Object.keys(additional_destinations).length!==0){keys=Object.keys(additional_destinations);next_dest=additional_destinations[keys[0]];// console.log(additional_destinations[keys[0]])\ndelete additional_destinations[keys[0]];console.log(\"current coordinates: \",current_coordinates,\"end coordinates: \",next_dest);new_path=aStar(matrix,current_coordinates,next_dest,additional_destinations,walls,weights);add_to_visited_nodes=new_path.next().value;add_shortest_path=new_path.next().value;visited_coordinates=visited_coordinates.concat(add_to_visited_nodes);// if (add_shortest_path === undefined)\n//     break;\npath=path.concat(add_shortest_path);console.log(\"path: \",path);current_coordinates=_toConsumableArray(next_dest);end_coordinates=_toConsumableArray(end);new_path=aStar(matrix,current_coordinates,end_coordinates,additional_destinations,walls,weights);add_to_visited_nodes=new_path.next().value;add_shortest_path=new_path.next().value;visited_coordinates=visited_coordinates.concat(add_to_visited_nodes);// if (add_shortest_path === undefined)\n//     break;\npath=path.concat(add_shortest_path);// end_coordinates = current_coordinates;\n// found = true;\n}if(current_coordinates[0]===end_coordinates[0]&&current_coordinates[1]===end_coordinates[1]&&Object.keys(additional_destinations).length===0){found=true;}// yield [...current_coordinates];\n// if(coordinatesAreEqual(current_coordinates,end_coordinates))\n// {\n//     break;\n// }\ngenerator=checkNeighbors(current_coordinates,visited);result=generator.next();while(!result.done&&!found){neighbor_coordinates=result.value;have_visited=visited[neighbor_coordinates[0]][neighbor_coordinates[1]];// EDIT: needs to change once weight and walls are added in.\ncost_from_current_node=calculateWeight(distance_matrix[current_coordinates[0]][current_coordinates[1]],neighbor_coordinates,weights);f_cost=cost_from_current_node+manhattanDistance(neighbor_coordinates,end_coordinates);// cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates) \nis_current_cost_less=f_cost<distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]];is_neighbor_in_priority_queue=priority_queue.items.includes([f_cost,neighbor_coordinates]);// if (!have_visited && is_neighbor_in_priority_queue && is_current_cost_less) {\n//     const index = priority_queue.items.indexOf([f_cost, neighbor_coordinates]);\n//     priority_queue.items.splice(index);\n// }\nif(!have_visited&&is_current_cost_less&&!is_neighbor_in_priority_queue&&walls[neighbor_coordinates]===undefined){// update the distance of the neighbor_node\nupdateDistance(f_cost,neighbor_coordinates,distance_matrix);// distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n// update the parent node of the neighbor node to the current node\nupdateParent(current_coordinates,neighbor_coordinates,parent_matrix);priority_queue.enqueue(neighbor_coordinates,calculateWeight(manhattanDistance(neighbor_coordinates,end_coordinates),neighbor_coordinates,weights));}result=generator.next();}}_context.next=20;return visited_coordinates;case 20:// could be undefined or a path\nundefined_or_path=getShortestPath(end_coordinates,parent_matrix);// if it is undefined, return undefined (void)\nif(!(undefined_or_path===undefined)){_context.next=23;break;}return _context.abrupt(\"return\",path);case 23:path=path.concat(undefined_or_path);_context.next=26;return path;case 26:case\"end\":return _context.stop();}}},_marked);}function manhattanDistance(){var coordinates1=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var coordinates2=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];return Math.abs(coordinates1[0]-coordinates2[0])+Math.abs(coordinates1[1]-coordinates2[1]);}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/a-star.js"],"names":["aStar","shallowCopy","checkNeighbors","PriorityQueue","updatetoVisited","getShortestPath","calculateWeight","updateParent","updateDistance","matrix","start","end","additional_destinations","walls","weights","found","start_coordinates","end_coordinates","priority_queue","visited_coordinates","path","parent_matrix","visited","distance_matrix","Infinity","enqueue","manhattanDistance","isEmpty","q_item","dequeue","current_coordinates","element","push","Object","keys","length","next_dest","console","log","new_path","add_to_visited_nodes","next","value","add_shortest_path","concat","generator","result","done","neighbor_coordinates","have_visited","cost_from_current_node","f_cost","is_current_cost_less","is_neighbor_in_priority_queue","items","includes","undefined","undefined_or_path","coordinates1","coordinates2","Math","abs"],"mappings":"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","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\"\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\n// import { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { PriorityQueue } from \"../data-structures/priority-queue\"\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\n// import { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\n\nexport default function* aStar(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations = {}, walls = {}, weights = {}) {\n    let found = false;\n    let start_coordinates = [...start]\n    let end_coordinates = [...end]\n    var priority_queue = new PriorityQueue();\n    // let additional_dest = Object.assign({}, additional_destinations);\n    let visited_coordinates = [];\n    let path = [];\n    let parent_matrix = shallowCopy(matrix, null);\n    let visited = shallowCopy(matrix, false);\n    let distance_matrix = shallowCopy(matrix, Infinity);\n\n\n    distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n    // updatetoVisited(start_coordinates, visited);\n    // visited_coordinates.push(start_coordinates)\n\n    priority_queue.enqueue([...start_coordinates], manhattanDistance(start_coordinates, end_coordinates));\n    while (!priority_queue.isEmpty() && !found) {\n        let q_item = priority_queue.dequeue();\n        // let f_cost = tuple[0];\n        let current_coordinates = q_item.element;\n        if (!visited[current_coordinates[0]][current_coordinates[1]]) {\n            updatetoVisited(current_coordinates, visited);\n            visited_coordinates.push(current_coordinates);\n        }\n        if (Object.keys(additional_destinations).length !== 0) {\n            let keys = Object.keys(additional_destinations);\n            let next_dest = additional_destinations[keys[0]]\n            // console.log(additional_destinations[keys[0]])\n            delete additional_destinations[keys[0]];\n            console.log(\"current coordinates: \", current_coordinates, \"end coordinates: \", next_dest)\n            let new_path = aStar(matrix, current_coordinates, next_dest, additional_destinations, walls, weights);\n            let add_to_visited_nodes = new_path.next().value;\n            let add_shortest_path = new_path.next().value;\n            visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n            // if (add_shortest_path === undefined)\n            //     break;\n            path = path.concat(add_shortest_path);\n            console.log(\"path: \", path);\n            current_coordinates = [...next_dest];\n            end_coordinates = [...end]\n            new_path = aStar(matrix, current_coordinates, end_coordinates, additional_destinations, walls, weights);\n            add_to_visited_nodes = new_path.next().value;\n            add_shortest_path = new_path.next().value;\n            visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n            // if (add_shortest_path === undefined)\n            //     break;\n            path = path.concat(add_shortest_path);\n            // end_coordinates = current_coordinates;\n            // found = true;\n\n\n        }\n        if (((current_coordinates[0] === end_coordinates[0]) && (current_coordinates[1] === end_coordinates[1])) && Object.keys(additional_destinations).length === 0) {\n            found = true;\n        }\n        // yield [...current_coordinates];\n\n        // if(coordinatesAreEqual(current_coordinates,end_coordinates))\n        // {\n        //     break;\n        // }\n\n        const generator = checkNeighbors(current_coordinates, visited);\n        let result = generator.next();\n\n        while (!result.done && !found) {\n            let neighbor_coordinates = result.value\n            let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]];\n            // EDIT: needs to change once weight and walls are added in.\n            let cost_from_current_node = calculateWeight(distance_matrix[current_coordinates[0]][current_coordinates[1]], neighbor_coordinates, weights);\n\n            let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates);\n            // cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates) \n\n            let is_current_cost_less = f_cost < distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]];\n            let is_neighbor_in_priority_queue = priority_queue.items.includes([f_cost, neighbor_coordinates]);\n\n            // if (!have_visited && is_neighbor_in_priority_queue && is_current_cost_less) {\n            //     const index = priority_queue.items.indexOf([f_cost, neighbor_coordinates]);\n            //     priority_queue.items.splice(index);\n\n            // }\n            if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_queue && walls[neighbor_coordinates] === undefined) {\n                // update the distance of the neighbor_node\n                updateDistance(f_cost, neighbor_coordinates, distance_matrix)\n                // distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n                // update the parent node of the neighbor node to the current node\n                updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n                priority_queue.enqueue(neighbor_coordinates, calculateWeight(manhattanDistance(neighbor_coordinates, end_coordinates), neighbor_coordinates, weights))\n            }\n\n            result = generator.next();\n        }\n    }\n    yield visited_coordinates;\n    // could be undefined or a path\n    let undefined_or_path = getShortestPath(end_coordinates, parent_matrix);\n    // if it is undefined, return undefined (void)\n    if (undefined_or_path === undefined) {\n        // return;\n        return path;\n    }\n\n    path = path.concat(undefined_or_path);\n\n\n    yield path\n    // yield getShortestPath(end_coordinates, parent_matrix);\n    // yield* traverseShortestPath(end_coordinates,parent_matrix);\n\n\n\n\n}\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n    return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}"]},"metadata":{},"sourceType":"module"}