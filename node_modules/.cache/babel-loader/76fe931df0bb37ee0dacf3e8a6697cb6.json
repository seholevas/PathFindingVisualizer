{"ast":null,"code":"import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nexport default function* depthFirstSearch(adjacency_matrix = [[]], start_node_coordinates = [2, 2], end_node_coordinates = [0, 0], additional_destinations, walls) {\n  // data structure for storing next values\n  let stack = [];\n  let start_coordinates = [...start_node_coordinates];\n  let end_coordinates = [...end_node_coordinates];\n  let additional_dest = Object.assign({}, additional_destinations); // coordinates that have been visited\n\n  let visited_coordinates = []; // matrix that shows if a node at index [i][j] has been visited\n\n  let visited = shallowCopy(adjacency_matrix, false); // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n\n  let parent_matrix = shallowCopy(adjacency_matrix, null); // if end is found\n\n  let found = false; // pushing the starting coordintes into the stack, this will be where we start our search.\n\n  stack.push([...start_node_coordinates]); // while stack is not empty\n\n  while (stack.length !== 0 && !found) {\n    // the current verticies.\n    let vertex_coordinates = stack.pop();\n    visited_coordinates.push(vertex_coordinates);\n\n    if (additional_dest[vertex_coordinates] !== undefined) {\n      delete additional_dest[vertex_coordinates];\n      let new_path = depthFirstSearch(matrix, vertex_coordinates, end_coordinates, additional_dest, walls);\n      let add_to_visited_nodes = new_path.next().value;\n      let add_to_path = new_path.next().value;\n      visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n      console.log(\"in additional[dest] - path pre-concat: \", path); // if no path to finish line\n\n      if (add_to_path === undefined) break;\n      path = path.concat(add_to_path);\n      console.log(\"in additional[dest] - path post-concat: \", path);\n      end_coordinates = vertex_coordinates;\n      found = true;\n    } // \n    // if((vertex_coordinates[0] === end_coordinates[0] && vertex_coordinates[1] === end_coordinates[1]))\n    //\n    // if(coordinatesAreEqual(vertex_coordinates, end_node_coordinates))\n    // {\n    //     found = true;\n    //     yield visited_coordinates;\n    //     continue;\n    // }\n    // if (!visited[vertex_coordinates[0]][vertex_coordinates[1]] && !found) {\n\n\n    updatetoVisited(vertex_coordinates, visited);\n    const generator = checkNeighbors(vertex_coordinates, visited);\n    let result = generator.next();\n\n    while (!result.done) {\n      let value = result.value;\n\n      if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n        updateParent(vertex_coordinates, value, parent_matrix);\n        stack.push(value);\n      }\n\n      result = generator.next();\n    } // }\n\n  } // yield* traverseShortestPath(end_node_coordinates, parent_matrix);\n\n\n  yield getShortestPath(end_node_coordinates, parent_matrix);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/depth-first-search.js"],"names":["shallowCopy","updatetoVisited","checkNeighbors","updateParent","coordinatesAreEqual","getShortestPath","depthFirstSearch","adjacency_matrix","start_node_coordinates","end_node_coordinates","additional_destinations","walls","stack","start_coordinates","end_coordinates","additional_dest","Object","assign","visited_coordinates","visited","parent_matrix","found","push","length","vertex_coordinates","pop","undefined","new_path","matrix","add_to_visited_nodes","next","value","add_to_path","concat","console","log","path","generator","result","done"],"mappings":"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","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\n\n\nexport default function* depthFirstSearch(adjacency_matrix = [[]], start_node_coordinates = [2, 2], end_node_coordinates = [0, 0],additional_destinations, walls) {\n    // data structure for storing next values\n    let stack = [];\n    let start_coordinates = [...start_node_coordinates];\n    let end_coordinates = [...end_node_coordinates];\n    let additional_dest = Object.assign({}, additional_destinations);\n    // coordinates that have been visited\n    let visited_coordinates = [];\n\n    // matrix that shows if a node at index [i][j] has been visited\n    let visited = shallowCopy(adjacency_matrix, false);\n    // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n    let parent_matrix = shallowCopy(adjacency_matrix, null);\n    // if end is found\n    let found = false;\n    // pushing the starting coordintes into the stack, this will be where we start our search.\n    stack.push([...start_node_coordinates]);\n    // while stack is not empty\n    while (stack.length !== 0 && !found) {\n        // the current verticies.\n        let vertex_coordinates = stack.pop();\n        visited_coordinates.push(vertex_coordinates);\n        \n        if (additional_dest[vertex_coordinates] !== undefined) {\n            delete additional_dest[vertex_coordinates];\n            let new_path = depthFirstSearch(matrix, vertex_coordinates, end_coordinates, additional_dest, walls);\n            let add_to_visited_nodes = new_path.next().value\n            let add_to_path = new_path.next().value\n            visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n            console.log(\"in additional[dest] - path pre-concat: \", path)\n            // if no path to finish line\n            if (add_to_path === undefined)\n                break;\n            path = path.concat(add_to_path);\n            console.log(\"in additional[dest] - path post-concat: \", path)\n\n\n            end_coordinates = vertex_coordinates;\n            found = true;\n\n        }\n        // \n        // if((vertex_coordinates[0] === end_coordinates[0] && vertex_coordinates[1] === end_coordinates[1]))\n        //\n        \n        \n\n        // if(coordinatesAreEqual(vertex_coordinates, end_node_coordinates))\n        // {\n        //     found = true;\n        //     yield visited_coordinates;\n        //     continue;\n        // }\n\n        // if (!visited[vertex_coordinates[0]][vertex_coordinates[1]] && !found) {\n            updatetoVisited(vertex_coordinates, visited);\n\n\n            const generator = checkNeighbors(vertex_coordinates, visited);\n            let result = generator.next();\n\n            while (!result.done) {\n                let value = result.value\n\n                if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n                    updateParent(vertex_coordinates, value, parent_matrix);\n                    stack.push(value);\n                }\n\n                result = generator.next();\n            }\n        // }\n    }\n\n    // yield* traverseShortestPath(end_node_coordinates, parent_matrix);\n\n    yield getShortestPath(end_node_coordinates, parent_matrix);\n}\n\n"]},"metadata":{},"sourceType":"module"}