{"ast":null,"code":"export default function getShortestPath(end_node_coordinates = [], parent_coordinates_matrix = [[]]) {\n  let path = [];\n  let row = end_node_coordinates[0];\n  let column = end_node_coordinates[1];\n  let current = parent_coordinates_matrix[row][column];\n\n  if (current === null) {\n    return [];\n  }\n\n  path.push(end_node_coordinates);\n\n  do {\n    path.push(current);\n    row = current[0];\n    column = current[1];\n    current = parent_coordinates_matrix[row][column];\n  } while (current !== null);\n\n  path = path.reverse(); // for (let i = 0; i < path.length; i++) {\n  //     yield path[i];\n  // }\n\n  return [...path];\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/helpers/matrix-helpers/setters-and-getters/get-shortest-path.js"],"names":["getShortestPath","end_node_coordinates","parent_coordinates_matrix","path","row","column","current","push","reverse"],"mappings":"AAAA,eAAe,SAASA,eAAT,CAAyBC,oBAAoB,GAAG,EAAhD,EAAoDC,yBAAyB,GAAG,CAAC,EAAD,CAAhF,EAAsF;AACjG,MAAIC,IAAI,GAAG,EAAX;AACA,MAAIC,GAAG,GAAGH,oBAAoB,CAAC,CAAD,CAA9B;AACA,MAAII,MAAM,GAAGJ,oBAAoB,CAAC,CAAD,CAAjC;AACA,MAAIK,OAAO,GAAGJ,yBAAyB,CAACE,GAAD,CAAzB,CAA+BC,MAA/B,CAAd;;AAEA,MAAGC,OAAO,KAAK,IAAf,EACA;AACI,WAAO,EAAP;AACH;;AAEDH,EAAAA,IAAI,CAACI,IAAL,CAAUN,oBAAV;;AACA,KACA;AACIE,IAAAA,IAAI,CAACI,IAAL,CAAUD,OAAV;AACAF,IAAAA,GAAG,GAAGE,OAAO,CAAC,CAAD,CAAb;AACAD,IAAAA,MAAM,GAAGC,OAAO,CAAC,CAAD,CAAhB;AACAA,IAAAA,OAAO,GAAGJ,yBAAyB,CAACE,GAAD,CAAzB,CAA+BC,MAA/B,CAAV;AACH,GAND,QAOOC,OAAO,KAAK,IAPnB;;AAQAH,EAAAA,IAAI,GAAGA,IAAI,CAACK,OAAL,EAAP,CApBiG,CAqBjG;AACA;AACA;;AACA,SAAO,CAAC,GAAGL,IAAJ,CAAP;AAEH","sourcesContent":["export default function getShortestPath(end_node_coordinates = [], parent_coordinates_matrix = [[]]) {\n    let path = []\n    let row = end_node_coordinates[0];\n    let column = end_node_coordinates[1]\n    let current = parent_coordinates_matrix[row][column];\n    \n    if(current === null)\n    {\n        return [] \n    }\n\n    path.push(end_node_coordinates);\n    do \n    {\n        path.push(current);\n        row = current[0]\n        column = current[1]\n        current = parent_coordinates_matrix[row][column];\n    }\n    while (current !== null)\n    path = path.reverse();\n    // for (let i = 0; i < path.length; i++) {\n    //     yield path[i];\n    // }\n    return [...path];\n\n}"]},"metadata":{},"sourceType":"module"}