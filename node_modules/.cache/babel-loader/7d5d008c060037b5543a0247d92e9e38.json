{"ast":null,"code":"import { getValueByElementId } from \"../functions/get-value-by-element-id\";\nimport generateMatrix from \"../2d-array-functions/generate-matrix\";\nimport shallowCopy from \"../2d-array-functions/shallow-copy\";\nimport { dispatchedClearMatrix } from \"../../redux/dispatchs/grid-dispatchs\";\nimport store from \"../../redux/stores/store\";\nimport { dispatchedRemovedAdditionalDestination, dispatchedRemovedWeight, dispatchedRemovedWall, dispatchedMovedStart, dispatchedAddedWall, dispatchedMovedEnd } from \"../../redux/dispatchs/node-dispatchs\";\nexport function clearMatrix(isClearAll = true) {\n  // const size_of_matrix = getValueByElementId(\"size\");\n  const grid_size = store.getState().grid.length;\n  const matrix = generateMatrix(grid_size);\n  const shallow_copy = shallowCopy(matrix);\n  const start = store.getState().nodes.start_coordinates;\n  const end = store.getState().nodes.end_coordinates;\n\n  if (start[0] < grid_size - 1 && start[1] < grid_size - 1) {\n    shallow_copy[start[0]][start[1]] = {\n      type: \"start_node\",\n      visited: false,\n      shortest_path: false\n    };\n  } else {\n    dispatchedMovedStart([grid_size - 2, grid_size - 2]);\n    shallow_copy[grid_size - 2][grid_size - 2] = {\n      type: \"start_node\",\n      visited: false,\n      shortest_path: false\n    };\n  }\n\n  if (end[0] < grid_size - 1 && end[1] < grid_size - 1) {\n    shallow_copy[end[0]][end[1]] = {\n      type: \"end_node\",\n      visited: false,\n      shortest_path: false\n    };\n  } else {\n    dispatchedMovedEnd([grid_size - 1, grid_size - 1]);\n    shallow_copy[grid_size - 1][grid_size - 1] = {\n      type: \"end_node\",\n      visited: false,\n      shortest_path: false\n    };\n  }\n\n  if (!isClearAll) {\n    const weights = store.getState().nodes.weight_coordinates;\n    const additional_locations = store.getState().nodes.additional_destination_coordinates;\n    const walls = store.getState().nodes.wall_coordinates;\n\n    while (Object.keys(additional_locations).length !== 0) {\n      let keys = Object.keys(additional_locations);\n      dispatchedRemovedAdditionalDestination(current);\n    } // for (let i = 0; i < additional_locations.length; i++) {\n    //     let current = additional_locations[i]\n    //     if (current[0] < grid_size && current[1] < grid_size) {\n    //         shallow_copy[current[0]][current[1]] = { type: \"additional_destination_node\", visited: false, shortest_path: false };\n    //     }\n    //     else\n    //     {\n    //         dispatchedRemovedAdditionalDestination(current);    \n    //     }\n\n\n    for (let i = 0; i < weights.length; i++) {\n      let current = weights[i];\n\n      if (current[0] < grid_size && current[1] < grid_size) {\n        shallow_copy[current[0]][current[1]] = {\n          type: \"weight_node\",\n          visited: false,\n          shortest_path: false\n        };\n      } else {\n        dispatchedRemovedWeight(current);\n      }\n    }\n\n    for (let i = 0; i < walls.length; i++) {\n      let current = walls[i];\n\n      if (current[0] < grid_size && current[1] < grid_size) {\n        shallow_copy[current[0]][current[1]] = {\n          type: \"wall_node\",\n          visited: false,\n          shortest_path: false\n        };\n      } else {\n        dispatchedRemovedWall(current);\n      }\n    }\n  }\n\n  dispatchedMovedStart();\n  dispatchedClearMatrix(shallow_copy); // dispatchedChangedNodeType(matrix)\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/helpers/state-functions/clear-matrix.js"],"names":["getValueByElementId","generateMatrix","shallowCopy","dispatchedClearMatrix","store","dispatchedRemovedAdditionalDestination","dispatchedRemovedWeight","dispatchedRemovedWall","dispatchedMovedStart","dispatchedAddedWall","dispatchedMovedEnd","clearMatrix","isClearAll","grid_size","getState","grid","length","matrix","shallow_copy","start","nodes","start_coordinates","end","end_coordinates","type","visited","shortest_path","weights","weight_coordinates","additional_locations","additional_destination_coordinates","walls","wall_coordinates","Object","keys","current","i"],"mappings":"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","sourcesContent":["import { getValueByElementId } from \"../functions/get-value-by-element-id\";\nimport generateMatrix from \"../2d-array-functions/generate-matrix\";\nimport shallowCopy from \"../2d-array-functions/shallow-copy\";\nimport { dispatchedClearMatrix } from \"../../redux/dispatchs/grid-dispatchs\";\nimport store from \"../../redux/stores/store\";\nimport { dispatchedRemovedAdditionalDestination, dispatchedRemovedWeight, dispatchedRemovedWall, dispatchedMovedStart, dispatchedAddedWall, dispatchedMovedEnd } from \"../../redux/dispatchs/node-dispatchs\";\n\nexport function clearMatrix(isClearAll = true) {\n    // const size_of_matrix = getValueByElementId(\"size\");\n    const grid_size = store.getState().grid.length;\n    const matrix = generateMatrix(grid_size);\n    const shallow_copy = shallowCopy(matrix);\n    const start = store.getState().nodes.start_coordinates;\n    const end = store.getState().nodes.end_coordinates;\n\n\n    if ((start[0] < grid_size - 1) && (start[1] < grid_size - 1)) {\n        shallow_copy[start[0]][start[1]] = { type: \"start_node\", visited: false, shortest_path: false };\n    }\n    else {\n        dispatchedMovedStart([grid_size - 2, grid_size - 2])\n        shallow_copy[grid_size - 2][grid_size - 2] = { type: \"start_node\", visited: false, shortest_path: false };\n    }\n    if (end[0] < grid_size - 1 && end[1] < grid_size - 1) {\n        shallow_copy[end[0]][end[1]] = { type: \"end_node\", visited: false, shortest_path: false };\n    }\n    else {\n        dispatchedMovedEnd([grid_size - 1, grid_size - 1])\n        shallow_copy[grid_size - 1][grid_size - 1] = { type: \"end_node\", visited: false, shortest_path: false };\n\n    }\n\n    if (!isClearAll) {\n        const weights = store.getState().nodes.weight_coordinates;\n        const additional_locations = store.getState().nodes.additional_destination_coordinates;\n        const walls = store.getState().nodes.wall_coordinates;\n\n        while (Object.keys(additional_locations).length !== 0) {\n            let keys = Object.keys(additional_locations)\n            dispatchedRemovedAdditionalDestination(current);\n        }\n        // for (let i = 0; i < additional_locations.length; i++) {\n        //     let current = additional_locations[i]\n        //     if (current[0] < grid_size && current[1] < grid_size) {\n        //         shallow_copy[current[0]][current[1]] = { type: \"additional_destination_node\", visited: false, shortest_path: false };\n        //     }\n        //     else\n        //     {\n        //         dispatchedRemovedAdditionalDestination(current);    \n        //     }\n    \n\n    for (let i = 0; i < weights.length; i++) {\n        let current = weights[i]\n        if (current[0] < grid_size && current[1] < grid_size) {\n            shallow_copy[current[0]][current[1]] = { type: \"weight_node\", visited: false, shortest_path: false };\n        }\n        else {\n            dispatchedRemovedWeight(current);\n        }\n    }\n\n\n\n    for (let i = 0; i < walls.length; i++) {\n        let current = walls[i]\n        if (current[0] < grid_size && current[1] < grid_size) {\n            shallow_copy[current[0]][current[1]] = { type: \"wall_node\", visited: false, shortest_path: false };\n        }\n        else {\n            dispatchedRemovedWall(current);\n        }\n    }\n\n\n}\n\ndispatchedMovedStart()\ndispatchedClearMatrix(shallow_copy);\n    // dispatchedChangedNodeType(matrix)\n}"]},"metadata":{},"sourceType":"module"}