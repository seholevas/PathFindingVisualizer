{"ast":null,"code":"import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nexport function* breadthFirstSearch(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations, walls) {\n  let visited_coordinates = [];\n  let queue = [];\n  let path = [];\n  let start_coordinates = [...start];\n  let end_coordinates = [...end];\n  let visited = shallowCopy(matrix, false);\n  let found = false;\n  let additional_dest = Object.assign({}, additional_destinations);\n  let parent_matrix = shallowCopy(matrix, null); // console.log(\"visited: \", visited);\n\n  visited[start_coordinates[0]][start_coordinates[1]] = true;\n  visited_coordinates.push(start_coordinates);\n  queue.push(start_coordinates);\n\n  while (queue.length !== 0 && !found) {\n    let vertex_coordinates = queue.shift();\n\n    if (additional_dest[vertex_coordinates] !== undefined) {\n      delete additional_dest[vertex_coordinates];\n      let new_path = breadthFirstSearch(matrix, vertex_coordinates, end_coordinates, additional_dest, walls);\n      let add_to_visited_nodes = new_path.next().value;\n      let add_to_path = new_path.next().value;\n      visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n      console.log(\"in additional[dest] - path pre-concat: \", path); // if no path to finish line\n\n      if (add_to_path === undefined) break;\n      path = path.concat(add_to_path);\n      console.log(\"in additional[dest] - path post-concat: \", path);\n      end_coordinates = vertex_coordinates;\n      found = true;\n    }\n\n    if (vertex_coordinates[0] === end_coordinates[0] && vertex_coordinates[1] === end_coordinates[1] && Object.keys(additional_dest).length === 0) {\n      found = true;\n    } else {\n      const generator = checkNeighbors(vertex_coordinates, visited);\n      let result = generator.next();\n\n      while (!result.done) {\n        let value = result.value;\n\n        if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n          // yield value;\n          updatetoVisited(value, visited);\n          updateParent(vertex_coordinates, value, parent_matrix);\n          queue.push(value);\n          visited_coordinates.push(value);\n        }\n\n        result = generator.next();\n      }\n    }\n  }\n\n  yield visited_coordinates; // could be undefined or a path\n\n  let undefined_or_path = getShortestPath(end_coordinates, parent_matrix); // if it is undefined, return undefined (void)\n\n  if (undefined_or_path === undefined) {\n    return;\n  }\n\n  path = undefined_or_path.concat(path);\n  yield path;\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/breadth-first-search.js"],"names":["shallowCopy","checkNeighbors","updatetoVisited","updateParent","getShortestPath","coordinatesAreEqual","breadthFirstSearch","matrix","start","end","additional_destinations","walls","visited_coordinates","queue","path","start_coordinates","end_coordinates","visited","found","additional_dest","Object","assign","parent_matrix","push","length","vertex_coordinates","shift","undefined","new_path","add_to_visited_nodes","next","value","add_to_path","concat","console","log","keys","generator","result","done","undefined_or_path"],"mappings":"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","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\"\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nexport function* breadthFirstSearch(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations, walls) {\n    let visited_coordinates = [];\n    let queue = [];\n    let path = []\n    let start_coordinates = [...start];\n    let end_coordinates = [...end];\n    let visited = shallowCopy(matrix, false);\n    let found = false;\n    let additional_dest = Object.assign({}, additional_destinations);\n    let parent_matrix = shallowCopy(matrix, null);\n    // console.log(\"visited: \", visited);\n    visited[start_coordinates[0]][start_coordinates[1]] = true;\n    visited_coordinates.push(start_coordinates);\n    queue.push(start_coordinates);\n\n\n    while (queue.length !== 0 && !found) {\n        let vertex_coordinates = queue.shift();\n        if (additional_dest[vertex_coordinates] !== undefined) {\n            delete additional_dest[vertex_coordinates];\n            let new_path = breadthFirstSearch(matrix, vertex_coordinates, end_coordinates, additional_dest, walls)\n            let add_to_visited_nodes = new_path.next().value\n            let add_to_path = new_path.next().value\n            visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n            console.log(\"in additional[dest] - path pre-concat: \", path)\n            // if no path to finish line\n            if (add_to_path === undefined)\n                break;\n            path = path.concat(add_to_path);\n            console.log(\"in additional[dest] - path post-concat: \", path)\n\n\n            end_coordinates = vertex_coordinates;\n            found = true;\n\n        }\n        if (((vertex_coordinates[0] === end_coordinates[0]) && (vertex_coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n            found = true;\n        }\n        else {\n            const generator = checkNeighbors(vertex_coordinates, visited);\n            let result = generator.next();\n\n            while (!result.done) {\n                let value = result.value\n\n                if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n                    // yield value;\n                    updatetoVisited(value, visited);\n                    updateParent(vertex_coordinates, value, parent_matrix);\n                    queue.push(value);\n                    visited_coordinates.push(value);\n                }\n                result = generator.next();\n            }\n        }\n    }\n\n    yield visited_coordinates;\n\n    // could be undefined or a path\n    let undefined_or_path = getShortestPath(end_coordinates, parent_matrix);\n    // if it is undefined, return undefined (void)\n    if (undefined_or_path === undefined) {\n        return;\n    }\n\n    path = undefined_or_path.concat(path);\n\n\n    yield path\n}"]},"metadata":{},"sourceType":"module"}