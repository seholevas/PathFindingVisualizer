{"ast":null,"code":"import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\"; // import { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\n\nimport { PriorityQueue } from \"../data-structures/priority-queue\"; // import { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\n\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\"; // import { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\n\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nexport default function* aStar(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations = {}, walls = {}, weights = {}) {\n  let found = false;\n  let start_coordinates = [...start];\n  let end_coordinates = [...end];\n  var priority_open_set = new Priorityopen_set();\n  let additional_dest = Object.assign({}, additional_destinations);\n  let visited_coordinates = [];\n  let path = [];\n  let parent_matrix = shallowCopy(matrix, null);\n  let visited = shallowCopy(matrix, false);\n  let distance_matrix = shallowCopy(matrix, Infinity);\n  distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n  priority_open_set.enopen_set([...start_coordinates], manhattanDistance(start_coordinates, end_coordinates));\n\n  while (!priority_open_set.isEmpty() && !found) {\n    let q_item = priority_open_set.deopen_set(); // let f_cost = tuple[0];\n\n    let current_coordinates = q_item.element;\n    updatetoVisited(current_coordinates, visited);\n    visited_coordinates.push(current_coordinates);\n\n    if (additional_dest[current_coordinates] !== undefined) {\n      delete additional_dest[current_coordinates];\n      let new_path = aStar(matrix, current_coordinates, end_coordinates, additional_dest, walls);\n      let add_to_visited_nodes = new_path.next().value;\n      let add_to_path = new_path.next().value;\n      visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n      console.log(\"in additional[dest] - path pre-concat: \", path); // if no path to finish line\n\n      if (add_to_path === undefined) break;\n      path = path.concat(add_to_path);\n      console.log(\"in additional[dest] - path post-concat: \", path);\n      end_coordinates = current_coordinates;\n      found = true;\n    }\n\n    if (current_coordinates[0] === end_coordinates[0] && current_coordinates[1] === end_coordinates[1] && Object.keys(additional_dest).length === 0) {\n      found = true;\n    } // yield [...current_coordinates];\n    // if(coordinatesAreEqual(current_coordinates,end_coordinates))\n    // {\n    //     break;\n    // }\n\n\n    const generator = checkNeighbors(current_coordinates, visited);\n    let result = generator.next();\n\n    while (!result.done) {\n      let neighbor_coordinates = result.value;\n      let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]]; // EDIT: needs to change once weight and walls are added in.\n\n      let cost_from_current_node = calculateWeight(distance_matrix[current_coordinates[0]][current_coordinates[1]], neighbor_coordinates, weights);\n      let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates); // cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates) \n\n      let is_current_cost_less = distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] > cost_from_current_node;\n      let is_neighbor_in_priority_open_set = priority_open_set.items.includes([f_cost, neighbor_coordinates]);\n\n      if (!have_visited && is_neighbor_in_priority_open_set && is_current_cost_less) {\n        const index = priority_open_set.items.indexOf([f_cost, neighbor_coordinates]);\n        priority_open_set.items.splice(index);\n      }\n\n      if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_open_set) {\n        // update the distance of the neighbor_node\n        updateDistance(cost_from_current_node, neighbor_coordinates, distance_matrix); // distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n        // update the parent node of the neighbor node to the current node\n\n        updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n        priority_open_set.enopen_set(neighbor_coordinates, manhattanDistance(neighbor_coordinates, end_coordinates));\n      }\n\n      result = generator.next();\n    }\n  }\n\n  yield visited_coordinates; // could be undefined or a path\n\n  let undefined_or_path = getShortestPath(end_coordinates, parent_matrix); // if it is undefined, return undefined (void)\n\n  if (undefined_or_path === undefined) {\n    return;\n  }\n\n  path = undefined_or_path.concat(path);\n  yield path; // yield getShortestPath(end_coordinates, parent_matrix);\n  // yield* traverseShortestPath(end_coordinates,parent_matrix);\n} // export default function* aStar(matrix = [[]], start = [5, 5], end = [9, 9], additional_destinations = {}, walls = {}, weights = {}) {\n//     let start_coordinates = [...start];\n//     let end_coordinates = [...end];\n//     // let open_set = new Set();\n//     let open_set = new PriorityQueue();\n//     let visited_coordinates = [];\n//     let path = [];\n//     let came_from = shallowCopy(matrix, null);\n//     let visited = shallowCopy(matrix, false);\n//     let g_score = shallowCopy(matrix, Infinity);\n//     let f_score = shallowCopy(matrix, Infinity);\n//     let found = false;\n//     g_score[start_coordinates[0]][start_coordinates[1]] = 0;\n//     f_score[start_coordinates[0]][start_coordinates[1]] = manhattanDistance(start_coordinates, end_coordinates) + calculateWeight(0, start_coordinates, weights);\n//     open_set.enqueue(start_coordinates, f_score[start_coordinates[0]][start_coordinates[1]]);\n//     while (!open_set.isEmpty() && !found) {\n//         let current = open_set.dequeue().element;\n//         console.log(\"dequeued current: \", current)\n//         visited_coordinates.push(current);\n//         if (current[0] === end[0] && current[1] === end[1]) {\n//             found = true;\n//         }\n//         else {\n//             console.log(\"in else\")\n//             const generator = checkNeighbors(current, visited);\n//             let result = generator.next();\n//             console.log(\"generator: \", generator, \" result done?: \", result.done)\n//             while (!result.done) {\n//                 let neighbor = result.value\n//                 let tentative_g_score = g_score[current[0]][current[1]] + calculateWeight(g_score[current[0]][current[1]], neighbor, weights);\n//                 if (tentative_g_score < g_score[neighbor[0]][neighbor[1]] && walls[neighbor] === undefined) {\n//                     updateParent(current, neighbor, came_from);\n//                     // g_score[neighbor[1]][neighbor[2]] = tentative_g_score;\n//                     // f_score[neighbor[0]][neighbor[1]] = tentative_g_score + manhattanDistance(neighbor, end);\n//                     // console.log(\"enqueued current: \", neighbor)\n//                     updateDistance(tentative_g_score,neighbor,g_score);\n//                     updateDistance(tentative_g_score + manhattanDistance(neighbor,end), neighbor, f_score);\n//                     open_set.enqueue(neighbor, f_score[neighbor[0]][neighbor[1]]);\n//                 }\n//                 result = generator.next();\n//             }\n//         }\n//     }\n//     yield visited_coordinates;\n//     // could be undefined or a path\n//     let undefined_or_path = getShortestPath(end_coordinates, came_from);\n//     // if it is undefined, return undefined (void)\n//     if (undefined_or_path === undefined) {\n//         return;\n//     }\n//     path = undefined_or_path.concat(path);\n//     yield path\n// }\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n  return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/a-star.js"],"names":["shallowCopy","checkNeighbors","PriorityQueue","getShortestPath","calculateWeight","updateParent","updateDistance","aStar","matrix","start","end","additional_destinations","walls","weights","found","start_coordinates","end_coordinates","priority_open_set","Priorityopen_set","additional_dest","Object","assign","visited_coordinates","path","parent_matrix","visited","distance_matrix","Infinity","enopen_set","manhattanDistance","isEmpty","q_item","deopen_set","current_coordinates","element","updatetoVisited","push","undefined","new_path","add_to_visited_nodes","next","value","add_to_path","concat","console","log","keys","length","generator","result","done","neighbor_coordinates","have_visited","cost_from_current_node","f_cost","is_current_cost_less","is_neighbor_in_priority_open_set","items","includes","index","indexOf","splice","undefined_or_path","coordinates1","coordinates2","Math","abs"],"mappings":"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","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\"\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\n// import { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { PriorityQueue } from \"../data-structures/priority-queue\"\n// import { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\n// import { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\n\nexport default function* aStar(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations ={}, walls={}, weights={}) {\n    let found = false;\n    let start_coordinates =[...start]\n    let end_coordinates = [...end]\n    var priority_open_set = new Priorityopen_set();\n    let additional_dest = Object.assign({}, additional_destinations);\n    let visited_coordinates = [];\n    let path = [];\n    let parent_matrix = shallowCopy(matrix, null);\n    let visited = shallowCopy(matrix, false);\n    let distance_matrix = shallowCopy(matrix, Infinity);\n\n\n    distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n\n    priority_open_set.enopen_set([...start_coordinates], manhattanDistance(start_coordinates, end_coordinates));\n    while (!priority_open_set.isEmpty() && !found) {\n        let q_item = priority_open_set.deopen_set();\n        // let f_cost = tuple[0];\n        let current_coordinates = q_item.element;\n        updatetoVisited(current_coordinates,visited);\n        visited_coordinates.push(current_coordinates);\n\n        if (additional_dest[current_coordinates] !== undefined) {\n            delete additional_dest[current_coordinates];\n            let new_path = aStar(matrix, current_coordinates, end_coordinates, additional_dest, walls)\n            let add_to_visited_nodes = new_path.next().value\n            let add_to_path = new_path.next().value\n            visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n            console.log(\"in additional[dest] - path pre-concat: \", path)\n            // if no path to finish line\n            if (add_to_path === undefined)\n                break;\n            path = path.concat(add_to_path);\n            console.log(\"in additional[dest] - path post-concat: \", path)\n\n\n            end_coordinates = current_coordinates;\n            found = true;\n\n        }\n        if (((current_coordinates[0] === end_coordinates[0]) && (current_coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n            found = true;\n        }\n        // yield [...current_coordinates];\n\n        // if(coordinatesAreEqual(current_coordinates,end_coordinates))\n        // {\n        //     break;\n        // }\n\n        const generator = checkNeighbors(current_coordinates, visited);\n        let result = generator.next();\n\n        while (!result.done) {\n            let neighbor_coordinates = result.value\n            let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]];\n            // EDIT: needs to change once weight and walls are added in.\n            let cost_from_current_node = calculateWeight(distance_matrix[current_coordinates[0]][current_coordinates[1]],neighbor_coordinates,weights);\n\n            let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates,end_coordinates);\n            // cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates) \n\n            let is_current_cost_less = distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] > cost_from_current_node\n            let is_neighbor_in_priority_open_set = priority_open_set.items.includes([f_cost, neighbor_coordinates]);\n\n            if (!have_visited && is_neighbor_in_priority_open_set && is_current_cost_less) {\n                const index = priority_open_set.items.indexOf([f_cost, neighbor_coordinates]);\n                priority_open_set.items.splice(index);\n\n            }\n            if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_open_set) {\n                // update the distance of the neighbor_node\n                updateDistance(cost_from_current_node,neighbor_coordinates,distance_matrix)\n                // distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n                // update the parent node of the neighbor node to the current node\n                updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n                priority_open_set.enopen_set(neighbor_coordinates, manhattanDistance(neighbor_coordinates, end_coordinates))\n            }\n\n            result = generator.next();\n        }\n    }\n    yield visited_coordinates;\n    // could be undefined or a path\n    let undefined_or_path = getShortestPath(end_coordinates, parent_matrix);\n    // if it is undefined, return undefined (void)\n    if (undefined_or_path === undefined) {\n        return;\n    }\n\n    path = undefined_or_path.concat(path);\n\n\n    yield path\n    // yield getShortestPath(end_coordinates, parent_matrix);\n    // yield* traverseShortestPath(end_coordinates,parent_matrix);\n\n\n\n\n}\n\n// export default function* aStar(matrix = [[]], start = [5, 5], end = [9, 9], additional_destinations = {}, walls = {}, weights = {}) {\n//     let start_coordinates = [...start];\n//     let end_coordinates = [...end];\n//     // let open_set = new Set();\n//     let open_set = new PriorityQueue();\n//     let visited_coordinates = [];\n//     let path = [];\n//     let came_from = shallowCopy(matrix, null);\n//     let visited = shallowCopy(matrix, false);\n//     let g_score = shallowCopy(matrix, Infinity);\n//     let f_score = shallowCopy(matrix, Infinity);\n//     let found = false;\n//     g_score[start_coordinates[0]][start_coordinates[1]] = 0;\n//     f_score[start_coordinates[0]][start_coordinates[1]] = manhattanDistance(start_coordinates, end_coordinates) + calculateWeight(0, start_coordinates, weights);\n\n//     open_set.enqueue(start_coordinates, f_score[start_coordinates[0]][start_coordinates[1]]);\n\n//     while (!open_set.isEmpty() && !found) {\n//         let current = open_set.dequeue().element;\n//         console.log(\"dequeued current: \", current)\n//         visited_coordinates.push(current);\n\n//         if (current[0] === end[0] && current[1] === end[1]) {\n//             found = true;\n//         }\n//         else {\n//             console.log(\"in else\")\n//             const generator = checkNeighbors(current, visited);\n//             let result = generator.next();\n//             console.log(\"generator: \", generator, \" result done?: \", result.done)\n\n//             while (!result.done) {\n//                 let neighbor = result.value\n//                 let tentative_g_score = g_score[current[0]][current[1]] + calculateWeight(g_score[current[0]][current[1]], neighbor, weights);\n//                 if (tentative_g_score < g_score[neighbor[0]][neighbor[1]] && walls[neighbor] === undefined) {\n//                     updateParent(current, neighbor, came_from);\n//                     // g_score[neighbor[1]][neighbor[2]] = tentative_g_score;\n//                     // f_score[neighbor[0]][neighbor[1]] = tentative_g_score + manhattanDistance(neighbor, end);\n//                     // console.log(\"enqueued current: \", neighbor)\n//                     updateDistance(tentative_g_score,neighbor,g_score);\n//                     updateDistance(tentative_g_score + manhattanDistance(neighbor,end), neighbor, f_score);\n//                     open_set.enqueue(neighbor, f_score[neighbor[0]][neighbor[1]]);\n\n\n                \n//                 }\n//                 result = generator.next();\n//             }\n//         }\n\n\n//     }\n\n//     yield visited_coordinates;\n//     // could be undefined or a path\n//     let undefined_or_path = getShortestPath(end_coordinates, came_from);\n//     // if it is undefined, return undefined (void)\n//     if (undefined_or_path === undefined) {\n//         return;\n//     }\n\n//     path = undefined_or_path.concat(path);\n\n\n//     yield path\n\n\n\n\n// }\n\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n    return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}"]},"metadata":{},"sourceType":"module"}