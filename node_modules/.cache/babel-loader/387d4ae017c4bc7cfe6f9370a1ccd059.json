{"ast":null,"code":"import shallowCopy from \"../../../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./async-helpers/check-neighbors\";\nimport { updateParent } from \"./setters-and-getters/update-parent\";\nexport default function* aStar(adjacency_matrix = [[]], start_coordinates = [0, 0], end_cordinates = [3, 3]) {\n  let queue = [];\n  let parent_matrix = shallowCopy(adjacency_matrix, null);\n  let final_cost_matrix = shallowCopy(adjacency_matrix, Infinity);\n  let visited = shallowCopy(adjacency_matrix, false);\n  queue.push([Infinity, [...start_coordinates]]);\n\n  while (queue.lenth !== 0) {\n    let tuple = queue.shift();\n    let f_cost = tuple[0];\n    let current_vertex_coordinates = tuple[1];\n    yield [...current_vertex_coordinates];\n    visited[current_vertex_coordinates[0]][current_vertex_coordinates[1]] = true;\n    const generator = checkNeighbors(current_vertex_coordinates, visited);\n    let result = generator.next();\n\n    while (!result.done) {\n      let value = result.value;\n      let g_cost = manhattanDistance(value, start_coordinates);\n      let h_cost = manhattanDistance(value, end_cordinates);\n      f_cost = g_cost + h_cost;\n\n      if (f_cost < final_cost_matrix[value[0]][value[1]]) {\n        final_cost_matrix[value[0]][value[1]] = f_cost;\n        updateParent(current_vertex_coordinates, value, parent_matrix);\n      }\n\n      queue.push([final_cost_matrix[value[0]][value[1]], value]);\n      result = generator.next();\n    }\n\n    queue.sort(function (tuple1, tuple2) {\n      if (tuple1[0] < tuple2[0]) {\n        return -1;\n      } else {\n        return 1;\n      }\n    });\n  }\n}\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n  return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/helpers/matrix-helpers/a-star.js"],"names":["shallowCopy","checkNeighbors","updateParent","aStar","adjacency_matrix","start_coordinates","end_cordinates","queue","parent_matrix","final_cost_matrix","Infinity","visited","push","lenth","tuple","shift","f_cost","current_vertex_coordinates","generator","result","next","done","value","g_cost","manhattanDistance","h_cost","sort","tuple1","tuple2","coordinates1","coordinates2","Math","abs"],"mappings":"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","sourcesContent":["import shallowCopy from \"../../../helpers/2d-array-functions/shallow-copy\"\nimport { checkNeighbors } from \"./async-helpers/check-neighbors\";\nimport { updateParent } from \"./setters-and-getters/update-parent\";\n\nexport default function* aStar(adjacency_matrix = [[]], start_coordinates = [0, 0], end_cordinates = [3, 3]) {\n    let queue = []\n    let parent_matrix = shallowCopy(adjacency_matrix, null);\n    let final_cost_matrix = shallowCopy(adjacency_matrix, Infinity);\n    let visited = shallowCopy(adjacency_matrix, false);\n    queue.push([Infinity, [...start_coordinates]]);\n\n    while (queue.lenth !== 0) {\n        let tuple = queue.shift();\n        let f_cost = tuple[0];\n        let current_vertex_coordinates = tuple[1];\n        yield [...current_vertex_coordinates];\n        visited[current_vertex_coordinates[0]][current_vertex_coordinates[1]] = true;\n        const generator = checkNeighbors(current_vertex_coordinates, visited);\n        let result = generator.next();\n\n        while (!result.done) {\n            let value = result.value\n            let g_cost = manhattanDistance(value, start_coordinates);\n            let h_cost = manhattanDistance(value, end_cordinates);\n            f_cost = g_cost + h_cost;\n            \n            if(f_cost < final_cost_matrix[value[0]][value[1]])\n            {\n                final_cost_matrix[value[0]][value[1]] = f_cost;\n                updateParent(current_vertex_coordinates, value, parent_matrix);\n            }\n\n            queue.push([final_cost_matrix[value[0]][value[1]], value]);\n\n            result = generator.next();\n        }\n\n        queue.sort(function (tuple1, tuple2) {\n            if (tuple1[0] < tuple2[0]) {\n                return -1\n            }\n            else {\n                return 1;\n            }\n        });\n    }\n\n}\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n    return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1])\n}"]},"metadata":{},"sourceType":"module"}