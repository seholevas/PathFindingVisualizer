{"ast":null,"code":"import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\"; // import { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\n\nimport { PriorityQueue } from \"../data-structures/priority-queue\"; // import { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\n\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\"; // import { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\n\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\"; // export default function* aStar(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations ={}, walls={}, weights={}) {\n//     let found = false;\n//     let start_coordinates =[...start]\n//     let end_coordinates = [...end]\n//     var priority_open_set = new Priorityopen_set();\n//     let additional_dest = Object.assign({}, additional_destinations);\n//     let visited_coordinates = [];\n//     let path = [];\n//     let parent_matrix = shallowCopy(matrix, null);\n//     let visited = shallowCopy(matrix, false);\n//     let distance_matrix = shallowCopy(matrix, Infinity);\n//     distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n//     priority_open_set.enopen_set([...start_coordinates], manhattanDistance(start_coordinates, end_coordinates));\n//     while (!priority_open_set.isEmpty() && !found) {\n//         let q_item = priority_open_set.deopen_set();\n//         // let f_cost = tuple[0];\n//         let current_coordinates = q_item.element;\n//         updatetoVisited(current_coordinates,visited);\n//         visited_coordinates.push(current_coordinates);\n//         if (additional_dest[current_coordinates] !== undefined) {\n//             delete additional_dest[current_coordinates];\n//             let new_path = aStar(matrix, current_coordinates, end_coordinates, additional_dest, walls)\n//             let add_to_visited_nodes = new_path.next().value\n//             let add_to_path = new_path.next().value\n//             visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n//             console.log(\"in additional[dest] - path pre-concat: \", path)\n//             // if no path to finish line\n//             if (add_to_path === undefined)\n//                 break;\n//             path = path.concat(add_to_path);\n//             console.log(\"in additional[dest] - path post-concat: \", path)\n//             end_coordinates = current_coordinates;\n//             found = true;\n//         }\n//         if (((current_coordinates[0] === end_coordinates[0]) && (current_coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n//             found = true;\n//         }\n//         // yield [...current_coordinates];\n//         // if(coordinatesAreEqual(current_coordinates,end_coordinates))\n//         // {\n//         //     break;\n//         // }\n//         const generator = checkNeighbors(current_coordinates, visited);\n//         let result = generator.next();\n//         while (!result.done) {\n//             let neighbor_coordinates = result.value\n//             let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]];\n//             // EDIT: needs to change once weight and walls are added in.\n//             let cost_from_current_node = calculateWeight(distance_matrix[current_coordinates[0]][current_coordinates[1]],neighbor_coordinates,weights);\n//             let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates,end_coordinates);\n//             // cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates) \n//             let is_current_cost_less = distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] > cost_from_current_node\n//             let is_neighbor_in_priority_open_set = priority_open_set.items.includes([f_cost, neighbor_coordinates]);\n//             if (!have_visited && is_neighbor_in_priority_open_set && is_current_cost_less) {\n//                 const index = priority_open_set.items.indexOf([f_cost, neighbor_coordinates]);\n//                 priority_open_set.items.splice(index);\n//             }\n//             if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_open_set) {\n//                 // update the distance of the neighbor_node\n//                 updateDistance(cost_from_current_node,neighbor_coordinates,distance_matrix)\n//                 // distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n//                 // update the parent node of the neighbor node to the current node\n//                 updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n//                 priority_open_set.enopen_set(neighbor_coordinates, manhattanDistance(neighbor_coordinates, end_coordinates))\n//             }\n//             result = generator.next();\n//         }\n//     }\n//     yield visited_coordinates;\n//     // could be undefined or a path\n//     let undefined_or_path = getShortestPath(end_coordinates, parent_matrix);\n//     // if it is undefined, return undefined (void)\n//     if (undefined_or_path === undefined) {\n//         return;\n//     }\n//     path = undefined_or_path.concat(path);\n//     yield path\n//     // yield getShortestPath(end_coordinates, parent_matrix);\n//     // yield* traverseShortestPath(end_coordinates,parent_matrix);\n// }\n\nexport default function* aStar(matrix = [[]], start = [5, 5], end = [9, 9], additional_destinations = {}, walls = {}, weights = {}) {\n  let start_coordinates = [...start];\n  let end_coordinates = [...end]; // let open_set = new Set();\n\n  let open_set = new PriorityQueue();\n  let visited_coordinates = [];\n  let path = [];\n  let came_from = shallowCopy(matrix, null);\n  let visited = shallowCopy(matrix, false);\n  let g_score = shallowCopy(matrix, Infinity);\n  let f_score = shallowCopy(matrix, Infinity);\n  let found = false;\n  g_score[start_coordinates[0]][start_coordinates[1]] = 0;\n  f_score[start_coordinates[0]][start_coordinates[1]] = manhattanDistance(start_coordinates, end_coordinates) + calculateWeight(0, start_coordinates, weights);\n  open_set.enqueue(start_coordinates, f_score[start_coordinates[0]][start_coordinates[1]]);\n\n  while (!open_set.isEmpty() && !found) {\n    let current = open_set.dequeue().element;\n    console.log(\"dequeued current: \", current);\n    visited_coordinates.push(current);\n\n    if (current[0] === end[0] && current[1] === end[1]) {\n      found = true;\n    }\n\n    console.log(\"in else\");\n    const generator = checkNeighbors(current, visited);\n    let result = generator.next();\n    console.log(\"generator: \", generator, \" result done?: \", result.done);\n\n    while (!result.done) {\n      let neighbor = result.value;\n      let tentative_g_score = g_score[current[0]][current[1]] + calculateWeight(g_score[current[0]][current[1]], neighbor, weights);\n\n      if (tentative_g_score < g_score[neighbor[0]][neighbor[1]] && walls[neighbor] === undefined) {\n        updateParent(current, neighbor, came_from);\n        g_score[neighbor[1]][neighbor[2]] = tentative_g_score;\n        f_score[neighbor[0]][neighbor[1]] = tentative_g_score + manhattanDistance(neighbor, end);\n        console.log(\"enqueued current: \", neighbor);\n        open_set.enqueue(neighbor, f_score[neighbor[0]][neighbor[1]]); // if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n        //     // yield value;\n        //     updatetoVisited(value, visited);\n        //     updateParent(current, value, came_from);\n        //     open_set.push(value);\n        //     visited_coordinates.push(value);\n        // }\n\n        result = generator.next();\n      }\n    }\n  }\n\n  yield visited_coordinates; // could be undefined or a path\n\n  let undefined_or_path = getShortestPath(end_coordinates, came_from); // if it is undefined, return undefined (void)\n\n  if (undefined_or_path === undefined) {\n    return;\n  }\n\n  path = undefined_or_path.concat(path);\n  yield path;\n}\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n  return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/a-star.js"],"names":["shallowCopy","checkNeighbors","PriorityQueue","getShortestPath","calculateWeight","updateParent","aStar","matrix","start","end","additional_destinations","walls","weights","start_coordinates","end_coordinates","open_set","visited_coordinates","path","came_from","visited","g_score","Infinity","f_score","found","manhattanDistance","enqueue","isEmpty","current","dequeue","element","console","log","push","generator","result","next","done","neighbor","value","tentative_g_score","undefined","undefined_or_path","concat","coordinates1","coordinates2","Math","abs"],"mappings":"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","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\"\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\n// import { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { PriorityQueue } from \"../data-structures/priority-queue\"\n// import { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\n// import { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\n\n// export default function* aStar(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations ={}, walls={}, weights={}) {\n//     let found = false;\n//     let start_coordinates =[...start]\n//     let end_coordinates = [...end]\n//     var priority_open_set = new Priorityopen_set();\n//     let additional_dest = Object.assign({}, additional_destinations);\n//     let visited_coordinates = [];\n//     let path = [];\n//     let parent_matrix = shallowCopy(matrix, null);\n//     let visited = shallowCopy(matrix, false);\n//     let distance_matrix = shallowCopy(matrix, Infinity);\n\n\n//     distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n\n//     priority_open_set.enopen_set([...start_coordinates], manhattanDistance(start_coordinates, end_coordinates));\n//     while (!priority_open_set.isEmpty() && !found) {\n//         let q_item = priority_open_set.deopen_set();\n//         // let f_cost = tuple[0];\n//         let current_coordinates = q_item.element;\n//         updatetoVisited(current_coordinates,visited);\n//         visited_coordinates.push(current_coordinates);\n\n//         if (additional_dest[current_coordinates] !== undefined) {\n//             delete additional_dest[current_coordinates];\n//             let new_path = aStar(matrix, current_coordinates, end_coordinates, additional_dest, walls)\n//             let add_to_visited_nodes = new_path.next().value\n//             let add_to_path = new_path.next().value\n//             visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n//             console.log(\"in additional[dest] - path pre-concat: \", path)\n//             // if no path to finish line\n//             if (add_to_path === undefined)\n//                 break;\n//             path = path.concat(add_to_path);\n//             console.log(\"in additional[dest] - path post-concat: \", path)\n\n\n//             end_coordinates = current_coordinates;\n//             found = true;\n\n//         }\n//         if (((current_coordinates[0] === end_coordinates[0]) && (current_coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n//             found = true;\n//         }\n//         // yield [...current_coordinates];\n\n//         // if(coordinatesAreEqual(current_coordinates,end_coordinates))\n//         // {\n//         //     break;\n//         // }\n\n//         const generator = checkNeighbors(current_coordinates, visited);\n//         let result = generator.next();\n\n//         while (!result.done) {\n//             let neighbor_coordinates = result.value\n//             let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]];\n//             // EDIT: needs to change once weight and walls are added in.\n//             let cost_from_current_node = calculateWeight(distance_matrix[current_coordinates[0]][current_coordinates[1]],neighbor_coordinates,weights);\n\n//             let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates,end_coordinates);\n//             // cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates) \n\n//             let is_current_cost_less = distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] > cost_from_current_node\n//             let is_neighbor_in_priority_open_set = priority_open_set.items.includes([f_cost, neighbor_coordinates]);\n\n//             if (!have_visited && is_neighbor_in_priority_open_set && is_current_cost_less) {\n//                 const index = priority_open_set.items.indexOf([f_cost, neighbor_coordinates]);\n//                 priority_open_set.items.splice(index);\n\n//             }\n//             if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_open_set) {\n//                 // update the distance of the neighbor_node\n//                 updateDistance(cost_from_current_node,neighbor_coordinates,distance_matrix)\n//                 // distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n//                 // update the parent node of the neighbor node to the current node\n//                 updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n//                 priority_open_set.enopen_set(neighbor_coordinates, manhattanDistance(neighbor_coordinates, end_coordinates))\n//             }\n\n//             result = generator.next();\n//         }\n//     }\n//     yield visited_coordinates;\n//     // could be undefined or a path\n//     let undefined_or_path = getShortestPath(end_coordinates, parent_matrix);\n//     // if it is undefined, return undefined (void)\n//     if (undefined_or_path === undefined) {\n//         return;\n//     }\n\n//     path = undefined_or_path.concat(path);\n\n\n//     yield path\n//     // yield getShortestPath(end_coordinates, parent_matrix);\n//     // yield* traverseShortestPath(end_coordinates,parent_matrix);\n\n\n\n\n// }\n\nexport default function* aStar(matrix = [[]], start = [5, 5], end = [9, 9], additional_destinations = {}, walls = {}, weights = {}) {\n    let start_coordinates = [...start];\n    let end_coordinates = [...end];\n    // let open_set = new Set();\n    let open_set = new PriorityQueue();\n    let visited_coordinates = [];\n    let path = [];\n    let came_from = shallowCopy(matrix, null);\n    let visited = shallowCopy(matrix, false);\n    let g_score = shallowCopy(matrix, Infinity);\n    let f_score = shallowCopy(matrix, Infinity);\n    let found = false;\n    g_score[start_coordinates[0]][start_coordinates[1]] = 0;\n    f_score[start_coordinates[0]][start_coordinates[1]] = manhattanDistance(start_coordinates, end_coordinates) + calculateWeight(0, start_coordinates, weights);\n\n    open_set.enqueue(start_coordinates, f_score[start_coordinates[0]][start_coordinates[1]]);\n\n    while (!open_set.isEmpty() && !found) {\n        let current = open_set.dequeue().element;\n        console.log(\"dequeued current: \", current)\n        visited_coordinates.push(current);\n\n        if (current[0]===end[0] && current[1]===end[1]) {\n            found = true;\n        }\n            console.log(\"in else\")\n            const generator = checkNeighbors(current, visited);\n            let result = generator.next();\n            console.log(\"generator: \",generator,\" result done?: \",result.done)\n\n            while (!result.done) {\n                let neighbor = result.value\n                let tentative_g_score = g_score[current[0]][current[1]] + calculateWeight(g_score[current[0]][current[1]], neighbor, weights);\n                if (tentative_g_score < g_score[neighbor[0]][neighbor[1]] && walls[neighbor] === undefined) {\n                    updateParent(current, neighbor, came_from);\n                    g_score[neighbor[1]][neighbor[2]] = tentative_g_score;\n                    f_score[neighbor[0]][neighbor[1]] = tentative_g_score + manhattanDistance(neighbor, end);\n                    console.log(\"enqueued current: \", neighbor)\n                    open_set.enqueue(neighbor, f_score[neighbor[0]][neighbor[1]]);\n                \n\n                // if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n                //     // yield value;\n                //     updatetoVisited(value, visited);\n                //     updateParent(current, value, came_from);\n                //     open_set.push(value);\n                //     visited_coordinates.push(value);\n                // }\n                result = generator.next();\n            }\n        }\n\n\n    }\n\n    yield visited_coordinates;\n    // could be undefined or a path\n    let undefined_or_path = getShortestPath(end_coordinates, came_from);\n    // if it is undefined, return undefined (void)\n    if (undefined_or_path === undefined) {\n        return;\n    }\n\n    path = undefined_or_path.concat(path);\n\n\n    yield path\n\n\n\n\n}\n\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n    return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}"]},"metadata":{},"sourceType":"module"}