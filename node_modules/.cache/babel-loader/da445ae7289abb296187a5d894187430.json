{"ast":null,"code":"// 1  function Dijkstra(Graph, source):\n// 2\n// 3      create vertex set Q\n// 4\n// 5      for each vertex v in Graph:             \n// 6          dist[v] ← INFINITY                  \n// 7          prev[v] ← UNDEFINED                 \n// 8          add v to Q                      \n// 10      dist[source] ← 0                        \n// 11      \n// 12      while Q is not empty:\n// 13          u ← vertex in Q with min dist[u]    \n// 14                                              \n// 15          remove u from Q \n// 16          \n// 17          for each neighbor v of u:           // only v that are still in Q\n// 18              alt ← dist[u] + length(u, v)\n// 19              if alt < dist[v]:               \n// 20                  dist[v] ← alt \n// 21                  prev[v] ← u \n// 22\n// 23      return dist[], prev[]\nexport default function* dijkstra(grid = [[]], source = grid[0][0]) {\n  adjacency_matrix = [...grid];\n  yield [...grid];\n\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {}\n  }\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/dijkstra.js"],"names":["dijkstra","grid","source","adjacency_matrix","row","length","col"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,eAAe,UAAUA,QAAV,CAAmBC,IAAI,GAAC,CAAC,EAAD,CAAxB,EAA8BC,MAAM,GAACD,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAArC,EACf;AACIE,EAAAA,gBAAgB,GAAG,CAAC,GAAGF,IAAJ,CAAnB;AACA,QAAM,CAAC,GAAGA,IAAJ,CAAN;;AACA,OAAK,IAAIG,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,IAAI,CAACI,MAA7B,EAAqCD,GAAG,EAAxC,EAA4C;AACxC,SAAK,IAAIE,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGL,IAAI,CAACG,GAAD,CAAJ,CAAUC,MAAlC,EAA0CC,GAAG,EAA7C,EAAiD,CAEhD;AACJ;AACJ","sourcesContent":["// 1  function Dijkstra(Graph, source):\n// 2\n// 3      create vertex set Q\n// 4\n// 5      for each vertex v in Graph:             \n// 6          dist[v] ← INFINITY                  \n// 7          prev[v] ← UNDEFINED                 \n// 8          add v to Q                      \n// 10      dist[source] ← 0                        \n// 11      \n// 12      while Q is not empty:\n// 13          u ← vertex in Q with min dist[u]    \n// 14                                              \n// 15          remove u from Q \n// 16          \n// 17          for each neighbor v of u:           // only v that are still in Q\n// 18              alt ← dist[u] + length(u, v)\n// 19              if alt < dist[v]:               \n// 20                  dist[v] ← alt \n// 21                  prev[v] ← u \n// 22\n// 23      return dist[], prev[]\n\nexport default function* dijkstra(grid=[[]], source=grid[0][0])\n{\n    adjacency_matrix = [...grid]\n    yield [...grid]\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[row].length; col++) {\n            \n        }\n    }\n}"]},"metadata":{},"sourceType":"module"}