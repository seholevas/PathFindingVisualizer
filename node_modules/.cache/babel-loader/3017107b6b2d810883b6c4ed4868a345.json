{"ast":null,"code":"// 1  function Dijkstra(Graph, source):\n// 2\n// 3      create vertex set Q\n// 4\n// 5      for each vertex v in Graph:             \n// 6          dist[v] ← INFINITY                  \n// 7          prev[v] ← UNDEFINED                 \n// 8          add v to Q                      \n// 10      dist[source] ← 0                        \n// 11      \n// 12      while Q is not empty:\n// 13          u ← vertex in Q with min dist[u]    \n// 14                                              \n// 15          remove u from Q \n// 16          \n// 17          for each neighbor v of u:           // only v that are still in Q\n// 18              alt ← dist[u] + length(u, v)\n// 19              if alt < dist[v]:               \n// 20                  dist[v] ← alt \n// 21                  prev[v] ← u \n// 22\n// 23      return dist[], prev[]\nexport default function* dijkstra(matrix = [[]], source = [2, 2], final = [0, 3]) {\n  let adjacency_matrix = [...matrix];\n  let path = [...matrix.length];\n  let visited = [...matrix];\n  let coordinates = source;\n  let queue = [];\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      if (source[0] === row && source[1] === col) {\n        path[row][col] = null;\n        adjacency_matrix[row][col] = 0;\n        coordinates = [row, col];\n        visited[row][col] = true;\n        queue.push(coordinates);\n      } else {\n        adjacency_matrix[row][col] = Infinity;\n        visited[row][col] = false;\n      } // console.log(\"visited: \", visited[row][col])\n\n    }\n  }\n\n  let found = false;\n\n  while (!found) {\n    coordinates = queue.shift();\n    const generator = check_neighbors(coordinates, visited);\n    let result = null;\n\n    do {\n      result = generator.next();\n      var neighbors_coordinates = result.value;\n\n      if (!result.done && !found) {\n        update_distance(adjacency_matrix[coordinates[0]][coordinates[1]], neighbors_coordinates, adjacency_matrix);\n        update_to_visited(neighbors_coordinates, visited);\n        queue.push(neighbors_coordinates);\n        found = isEqual(neighbors_coordinates, final);\n        yield [...neighbors_coordinates];\n      }\n    } while (!result.done); // found = isEqual(queue[0],final)\n\n  }\n\n  for (let i = 0; i < adjacency_matrix.length; i++) {\n    yield adjacency_matrix[i];\n  }\n}\n\nfunction update_distance(prev_value, node_location, adjacency_matrix) {\n  // let prev_row = prev_node_location[0];\n  // let prev_column = prev_node_location[1];\n  let row = node_location[0];\n  let column = node_location[1];\n  if (prev_value < adjacency_matrix[row][column]) adjacency_matrix[row][column] = prev_value + 1;\n}\n\nfunction isEqual(array1 = [], array2 = []) {\n  if (array1.length !== array2.length) return false;\n\n  for (let i = 0; i < array1.length; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction* check_neighbors(node_location, visited) {\n  let row = node_location[0];\n  let column = node_location[1];\n  const RIGHT = column + 1;\n  const LEFT = column - 1;\n  const UP = row - 1;\n  const DOWN = row + 1;\n\n  if (RIGHT >= 0 && RIGHT < visited.length && !visited[row][RIGHT]) {\n    yield [row, RIGHT];\n  }\n\n  if (LEFT >= 0 && !visited[row][LEFT]) {\n    yield [row, LEFT];\n  }\n\n  if (UP >= 0 && !visited[UP][column]) {\n    yield [UP, column];\n  }\n\n  if (DOWN >= 0 && DOWN < visited.length && !visited[DOWN][column]) {\n    yield [DOWN, column];\n  }\n}\n\nfunction update_to_visited(node_location, visited) {\n  let row = node_location[0];\n  let col = node_location[1];\n  visited[row][col] = true;\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/dijkstra.js"],"names":["dijkstra","matrix","source","final","adjacency_matrix","path","length","visited","coordinates","queue","row","col","push","Infinity","found","shift","generator","check_neighbors","result","next","neighbors_coordinates","value","done","update_distance","update_to_visited","isEqual","i","prev_value","node_location","column","array1","array2","RIGHT","LEFT","UP","DOWN"],"mappings":"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","sourcesContent":["// 1  function Dijkstra(Graph, source):\n// 2\n// 3      create vertex set Q\n// 4\n// 5      for each vertex v in Graph:             \n// 6          dist[v] ← INFINITY                  \n// 7          prev[v] ← UNDEFINED                 \n// 8          add v to Q                      \n// 10      dist[source] ← 0                        \n// 11      \n// 12      while Q is not empty:\n// 13          u ← vertex in Q with min dist[u]    \n// 14                                              \n// 15          remove u from Q \n// 16          \n// 17          for each neighbor v of u:           // only v that are still in Q\n// 18              alt ← dist[u] + length(u, v)\n// 19              if alt < dist[v]:               \n// 20                  dist[v] ← alt \n// 21                  prev[v] ← u \n// 22\n// 23      return dist[], prev[]\n\nexport default function* dijkstra(matrix = [[]], source = [2, 2], final = [0,3]) {\n    let adjacency_matrix = [...matrix]\n    let path = [...matrix.length];\n    let visited = [...matrix];\n    let coordinates = source;\n    let queue = [];\n\n    for (let row = 0; row < matrix.length; row++) {\n        for (let col = 0; col < matrix[row].length; col++) {\n            if (source[0] === row && source[1] === col) {\n                path[row][col] = null;\n                adjacency_matrix[row][col] = 0;\n                coordinates = [row, col];\n                visited[row][col] = true;\n                queue.push(coordinates);\n            }\n            else {\n                adjacency_matrix[row][col] = Infinity;\n                visited[row][col] = false;\n            }\n            // console.log(\"visited: \", visited[row][col])\n        }\n    }\n\n\n    let found = false;\n    while (!found) {\n        coordinates = queue.shift();\n        const generator = check_neighbors(coordinates, visited);\n        let result = null;\n        do {\n            result = generator.next();\n            var neighbors_coordinates = result.value;\n            if (!result.done && !found) {\n                update_distance(adjacency_matrix[coordinates[0]][coordinates[1]], neighbors_coordinates, adjacency_matrix);\n                update_to_visited(neighbors_coordinates, visited);\n                queue.push(neighbors_coordinates);\n                found = isEqual(neighbors_coordinates,final)\n\n                yield [...neighbors_coordinates];\n                \n            }\n        }\n        while (!result.done)\n\n        // found = isEqual(queue[0],final)\n\n    }\n\n    for (let i = 0; i < adjacency_matrix.length; i++) {\n        yield adjacency_matrix[i];\n    }\n\n\n}\n\nfunction update_distance(prev_value, node_location, adjacency_matrix) {\n    // let prev_row = prev_node_location[0];\n    // let prev_column = prev_node_location[1];\n    let row = node_location[0];\n    let column = node_location[1];\n    if (prev_value < adjacency_matrix[row][column])\n        adjacency_matrix[row][column] = prev_value + 1;\n}\n\nfunction isEqual(array1 = [], array2 = []) {\n    if (array1.length !== array2.length)\n        return false;\n\n    for (let i = 0; i < array1.length; i++) {\n        if (array1[i] !== array2[i])\n        {\n            return false\n        }\n    }\n    return true;\n}\n\n\nfunction* check_neighbors(node_location, visited) {\n    let row = node_location[0];\n    let column = node_location[1];\n    const RIGHT = column + 1;\n    const LEFT = column - 1;\n    const UP = row - 1;\n    const DOWN = row + 1;\n\n    if (RIGHT >= 0 && RIGHT < visited.length && !visited[row][RIGHT]) {\n        yield [row, RIGHT];\n    }\n    if (LEFT >= 0 && !visited[row][LEFT]) {\n        yield [row, LEFT];\n    }\n\n    if (UP >= 0  && !visited[UP][column]) {\n        yield [UP, column];\n    }\n    if (DOWN >= 0 && DOWN < visited.length && !visited[DOWN][column]) {\n        yield [DOWN, column];\n    }\n\n}\n\nfunction update_to_visited(node_location, visited) {\n    let row = node_location[0];\n    let col = node_location[1];\n    visited[row][col] = true;\n}"]},"metadata":{},"sourceType":"module"}