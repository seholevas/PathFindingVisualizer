{"ast":null,"code":"import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport { PriorityQueue } from \"../data-structures/priority-queue\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nexport default function* aStar(adjacency_matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations = {}, walls = {}, weights = {}) {\n  let start_coordinates = [...start];\n  let end_coordinates = [...end];\n  var priority_queue = new PriorityQueue();\n  let visited_coordinates = [];\n  let parent_matrix = shallowCopy(adjacency_matrix, null);\n  let visited = shallowCopy(adjacency_matrix, false);\n  let distance_matrix = shallowCopy(adjacency_matrix, Infinity);\n  distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n  priority_queue.enqueue([...start_coordinates], manhattanDistance(start_coordinates, end_coordinates));\n\n  while (!priority_queue.isEmpty()) {\n    let q_item = priority_queue.dequeue(); // let f_cost = tuple[0];\n\n    let current_coordinates = q_item.element;\n    updatetoVisited(current_coordinates, visited);\n    visited_coordinates.push(current_coordinates);\n\n    if (additional_dest[vertex_coordinates] !== undefined) {\n      delete additional_dest[vertex_coordinates];\n      let new_path = breadthFirstSearch(matrix, vertex_coordinates, end_coordinates, additional_dest, walls);\n      let add_to_visited_nodes = new_path.next().value;\n      let add_to_path = new_path.next().value;\n      visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n      console.log(\"in additional[dest] - path pre-concat: \", path); // if no path to finish line\n\n      if (add_to_path === undefined) break;\n      path = path.concat(add_to_path);\n      console.log(\"in additional[dest] - path post-concat: \", path);\n      end_coordinates = vertex_coordinates;\n      found = true;\n    }\n\n    if (vertex_coordinates[0] === end_coordinates[0] && vertex_coordinates[1] === end_coordinates[1] && Object.keys(additional_dest).length === 0) {\n      found = true;\n    } // yield [...current_coordinates];\n\n\n    if (coordinatesAreEqual(current_coordinates, end_coordinates)) {\n      break;\n    }\n\n    const generator = checkNeighbors(current_coordinates, visited);\n    let result = generator.next();\n\n    while (!result.done) {\n      let neighbor_coordinates = result.value;\n      let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]]; // EDIT: needs to change once weight and walls are added in.\n\n      let cost_from_current_node = distance_matrix[current_coordinates[0]][current_coordinates[1]] + 1;\n      let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates);\n      let is_current_cost_less = distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] > cost_from_current_node;\n      let is_neighbor_in_priority_queue = priority_queue.items.includes([f_cost, neighbor_coordinates]);\n\n      if (!have_visited && is_neighbor_in_priority_queue && is_current_cost_less) {\n        const index = priority_queue.items.indexOf([f_cost, neighbor_coordinates]);\n        priority_queue.items.splice(index);\n      }\n\n      if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_queue) {\n        // update the distance of the neighbor_node\n        distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node; // update the parent node of the neighbor node to the current node\n\n        updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n        priority_queue.enqueue(neighbor_coordinates, manhattanDistance(neighbor_coordinates, end_coordinates));\n      }\n\n      result = generator.next();\n    }\n  }\n\n  yield visited_coordinates;\n  yield getShortestPath(end_coordinates, parent_matrix); // yield* traverseShortestPath(end_coordinates,parent_matrix);\n}\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n  return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/a-star.js"],"names":["shallowCopy","checkNeighbors","updateParent","coordinatesAreEqual","PriorityQueue","updatetoVisited","getShortestPath","aStar","adjacency_matrix","start","end","additional_destinations","walls","weights","start_coordinates","end_coordinates","priority_queue","visited_coordinates","parent_matrix","visited","distance_matrix","Infinity","enqueue","manhattanDistance","isEmpty","q_item","dequeue","current_coordinates","element","push","additional_dest","vertex_coordinates","undefined","new_path","breadthFirstSearch","matrix","add_to_visited_nodes","next","value","add_to_path","concat","console","log","path","found","Object","keys","length","generator","result","done","neighbor_coordinates","have_visited","cost_from_current_node","f_cost","is_current_cost_less","is_neighbor_in_priority_queue","items","includes","index","indexOf","splice","coordinates1","coordinates2","Math","abs"],"mappings":"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","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\"\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport {PriorityQueue} from \"../data-structures/priority-queue\"\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\n\nexport default function* aStar(adjacency_matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations ={}, walls={}, weights={}) {\n    \n    let start_coordinates =[...start]\n    let end_coordinates = [...end]\n    var priority_queue = new PriorityQueue();\n    let visited_coordinates = [];\n    let parent_matrix = shallowCopy(adjacency_matrix, null);\n    let visited = shallowCopy(adjacency_matrix, false);\n    let distance_matrix = shallowCopy(adjacency_matrix, Infinity);\n\n\n    distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n\n    priority_queue.enqueue([...start_coordinates], manhattanDistance(start_coordinates, end_coordinates));\n    while (!priority_queue.isEmpty()) {\n        let q_item = priority_queue.dequeue();\n        // let f_cost = tuple[0];\n        let current_coordinates = q_item.element;\n        updatetoVisited(current_coordinates,visited);\n        visited_coordinates.push(current_coordinates);\n\n        if (additional_dest[vertex_coordinates] !== undefined) {\n            delete additional_dest[vertex_coordinates];\n            let new_path = breadthFirstSearch(matrix, vertex_coordinates, end_coordinates, additional_dest, walls)\n            let add_to_visited_nodes = new_path.next().value\n            let add_to_path = new_path.next().value\n            visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n            console.log(\"in additional[dest] - path pre-concat: \", path)\n            // if no path to finish line\n            if (add_to_path === undefined)\n                break;\n            path = path.concat(add_to_path);\n            console.log(\"in additional[dest] - path post-concat: \", path)\n\n\n            end_coordinates = vertex_coordinates;\n            found = true;\n\n        }\n        if (((vertex_coordinates[0] === end_coordinates[0]) && (vertex_coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n            found = true;\n        }\n        // yield [...current_coordinates];\n\n        if(coordinatesAreEqual(current_coordinates,end_coordinates))\n        {\n            break;\n        }\n\n        const generator = checkNeighbors(current_coordinates, visited);\n        let result = generator.next();\n\n        while (!result.done) {\n            let neighbor_coordinates = result.value\n            let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]];\n            // EDIT: needs to change once weight and walls are added in.\n            let cost_from_current_node = distance_matrix[current_coordinates[0]][current_coordinates[1]] + 1;\n\n            let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates)\n\n            let is_current_cost_less = distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] > cost_from_current_node\n            let is_neighbor_in_priority_queue = priority_queue.items.includes([f_cost, neighbor_coordinates]);\n\n            if (!have_visited && is_neighbor_in_priority_queue && is_current_cost_less) {\n                const index = priority_queue.items.indexOf([f_cost, neighbor_coordinates]);\n                priority_queue.items.splice(index);\n\n            }\n            if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_queue) {\n                // update the distance of the neighbor_node\n                distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n                // update the parent node of the neighbor node to the current node\n                updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n                priority_queue.enqueue(neighbor_coordinates, manhattanDistance(neighbor_coordinates, end_coordinates))\n            }\n            \n            result = generator.next();\n        }\n    }\n    yield visited_coordinates;\n    yield getShortestPath(end_coordinates, parent_matrix);\n    // yield* traverseShortestPath(end_coordinates,parent_matrix);\n\n\n\n\n}\n\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n    return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}"]},"metadata":{},"sourceType":"module"}