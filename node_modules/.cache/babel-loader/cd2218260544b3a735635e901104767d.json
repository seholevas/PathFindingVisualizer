{"ast":null,"code":"import _regeneratorRuntime from\"/home/steven/SWE/Code/path-finding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/home/steven/SWE/Code/path-finding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"/home/steven/SWE/Code/path-finding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/steven/SWE/Code/path-finding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _inherits from\"/home/steven/SWE/Code/path-finding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/home/steven/SWE/Code/path-finding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import React,{Component}from'react';import Card from'../atoms/holders/card';import MasterCTA from'../atoms/controls/call-to-actions/abstractions/master-call-to-action';import\"../../css/text.css\";import\"../../css/image.css\";import\"../../css/grid.css\";import\"../../css/flex.css\";var AlgorithmsInstructionsPage=/*#__PURE__*/function(_Component){_inherits(AlgorithmsInstructionsPage,_Component);var _super=_createSuper(AlgorithmsInstructionsPage);function AlgorithmsInstructionsPage(){_classCallCheck(this,AlgorithmsInstructionsPage);return _super.apply(this,arguments);}_createClass(AlgorithmsInstructionsPage,[{key:\"render\",value:function render(){var _this=this;return/*#__PURE__*/React.createElement(Card,{className:\"grid\"},/*#__PURE__*/React.createElement(\"div\",{className:\"flex row text-block\"},/*#__PURE__*/React.createElement(\"h1\",null,\"Say Hello To The Algorithms\")),/*#__PURE__*/React.createElement(\"div\",{className:\"flex row text-block\"},/*#__PURE__*/React.createElement(\"h2\",null,\"What are the algorithms involved?\")),/*#__PURE__*/React.createElement(\"div\",{className:\"flex row img center\"},/*#__PURE__*/React.createElement(\"img\",{src:require('../../images/algorithms.png')})),/*#__PURE__*/React.createElement(\"div\",{className:\"flex row text-block\"}),/*#__PURE__*/React.createElement(\"div\",{className:\"flex column text-block\"},/*#__PURE__*/React.createElement(\"ul\",null,/*#__PURE__*/React.createElement(\"li\",null,/*#__PURE__*/React.createElement(\"span\",null,\"A* Search\"),\" (weighted): arguably the best algorithm; guarentee's the shortest path. \"),/*#__PURE__*/React.createElement(\"li\",null,/*#__PURE__*/React.createElement(\"span\",null,\"Dijkstra's Algorithm\"),\" (weighted): the father of algorithms; It will guarentee the shortest path. \"),/*#__PURE__*/React.createElement(\"li\",null,/*#__PURE__*/React.createElement(\"span\",null,\"Bredth First Search\"),\" (unweighted): dijkstra's carefree brother; gaurentee's the shortest path, but does not care about weights. \"),/*#__PURE__*/React.createElement(\"li\",null,/*#__PURE__*/React.createElement(\"span\",null,\"Depth First Search\"),\" (unweighted): the under achieving algorithm; It will not gaurentee the shortest path! \"))),/*#__PURE__*/React.createElement(\"div\",{className:\"flex row\"},/*#__PURE__*/React.createElement(MasterCTA,{type:\"button\",onClick:/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _this.props.history.push(\"/Play\");case 2:case\"end\":return _context.stop();}}},_callee);}))},\"Skip\"),/*#__PURE__*/React.createElement(MasterCTA,{type:\"button\",onClick:/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(){return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return _this.props.history.push(\"/\");case 2:case\"end\":return _context2.stop();}}},_callee2);}))},\"Previous\"),/*#__PURE__*/React.createElement(MasterCTA,{type:\"button\",onClick:/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(){return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return _this.props.history.push(\"/Items\");case 2:case\"end\":return _context3.stop();}}},_callee3);}))},\"Next\")));}}]);return AlgorithmsInstructionsPage;}(Component);export{AlgorithmsInstructionsPage as default};","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/react/pages/algorithms-instruction-page.js"],"names":["React","Component","Card","MasterCTA","AlgorithmsInstructionsPage","require","props","history","push"],"mappings":"q8BAAA,MAAOA,CAAAA,KAAP,EAAgBC,SAAhB,KAAiC,OAAjC,CACA,MAAOC,CAAAA,IAAP,KAAiB,uBAAjB,CACA,MAAOC,CAAAA,SAAP,KAAsB,sEAAtB,CACA,MAAO,oBAAP,CACA,MAAO,qBAAP,CACA,MAAO,oBAAP,CACA,MAAO,oBAAP,C,GAEqBC,CAAAA,0B,kVACR,gBACL,mBACI,oBAAC,IAAD,EAAM,SAAS,CAAE,MAAjB,eACQ,2BAAK,SAAS,CAAE,qBAAhB,eACI,4DADJ,CADR,cAKQ,2BAAK,SAAS,CAAE,qBAAhB,eACI,kEADJ,CALR,cAQQ,2BAAK,SAAS,CAAE,qBAAhB,eAAuC,2BAAK,GAAG,CAAEC,OAAO,CAAC,6BAAD,CAAjB,EAAvC,CARR,cAaQ,2BAAK,SAAS,CAAE,qBAAhB,EAbR,cAgBQ,2BAAK,SAAS,CAAE,wBAAhB,eACA,2CACA,2CAAI,4CAAJ,6EADA,cAEA,2CAAI,uDAAJ,gFAFA,cAGA,2CAAI,sDAAJ,gHAHA,cAIA,2CAAI,qDAAJ,2FAJA,CADA,CAhBR,cAyBQ,2BAAK,SAAS,CAAE,UAAhB,eACI,oBAAC,SAAD,EAAW,IAAI,CAAE,QAAjB,CAA2B,OAAO,sEAAE,yJAAiB,CAAA,KAAI,CAACC,KAAL,CAAWC,OAAX,CAAmBC,IAAnB,CAAwB,OAAxB,CAAjB,uDAAF,EAAlC,SADJ,cAEI,oBAAC,SAAD,EAAW,IAAI,CAAE,QAAjB,CAA2B,OAAO,sEAAE,+JAAgB,CAAA,KAAI,CAACF,KAAL,CAAWC,OAAX,CAAmBC,IAAnB,CAAwB,GAAxB,CAAhB,yDAAF,EAAlC,aAFJ,cAGI,oBAAC,SAAD,EAAW,IAAI,CAAE,QAAjB,CAA2B,OAAO,sEAAE,+JAAiB,CAAA,KAAI,CAACF,KAAL,CAAWC,OAAX,CAAmBC,IAAnB,CAAwB,QAAxB,CAAjB,yDAAF,EAAlC,SAHJ,CAzBR,CADJ,CAiCH,C,wCAnCmDP,S,SAAnCG,0B","sourcesContent":["import React, { Component } from 'react'\nimport Card from '../atoms/holders/card'\nimport MasterCTA from '../atoms/controls/call-to-actions/abstractions/master-call-to-action';\nimport \"../../css/text.css\"\nimport \"../../css/image.css\"\nimport \"../../css/grid.css\"\nimport \"../../css/flex.css\"\n\nexport default class AlgorithmsInstructionsPage extends Component {\n    render() {\n        return (\n            <Card className={\"grid\"}>\n                    <div className={\"flex row text-block\"}>\n                        <h1>Say Hello To The Algorithms</h1>\n                    </div>\n\n                    <div className={\"flex row text-block\"}>\n                        <h2>What are the algorithms involved?</h2>\n                    </div>\n                    <div className={\"flex row img center\"}><img src={require('../../images/algorithms.png')} /></div>\n                    {/* <div className={\"flex row text-block\"}>\n                        <p>Algorithm is just a fancy word for having thought out list of steps that you take in a specific order. For example, you wouldn't drive your car before you put in the keys, right? These are the algorithms that will help you figure out your path:</p>\n                    </div> */}\n                    \n                    <div className={\"flex row text-block\"}>\n                    </div>\n\n                    <div className={\"flex column text-block\"}>\n                    <ul>\n                    <li><span>A* Search</span> (weighted): arguably the best algorithm; guarentee's the shortest path. </li>\n                    <li><span>Dijkstra's Algorithm</span> (weighted): the father of algorithms; It will guarentee the shortest path. </li>\n                    <li><span>Bredth First Search</span> (unweighted): dijkstra's carefree brother; gaurentee's the shortest path, but does not care about weights. </li>\n                    <li><span>Depth First Search</span> (unweighted): the under achieving algorithm; It will not gaurentee the shortest path! </li>\n                    </ul>\n                    </div>\n\n                    <div className={\"flex row\"}>\n                        <MasterCTA type={\"button\"} onClick={async ()=>{await this.props.history.push(\"/Play\"); }}>Skip</MasterCTA>\n                        <MasterCTA type={\"button\"} onClick={async()=>{await this.props.history.push(\"/\")}}>Previous</MasterCTA>\n                        <MasterCTA type={\"button\"} onClick={async ()=>{await this.props.history.push(\"/Items\")}}>Next</MasterCTA>\n                    </div>\n            </Card>\n        )\n    }\n}"]},"metadata":{},"sourceType":"module"}