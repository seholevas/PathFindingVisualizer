{"ast":null,"code":"import _regeneratorRuntime from\"/home/steven/SWE/Code/path-finding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _toConsumableArray from\"/home/steven/SWE/Code/path-finding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";var _marked=/*#__PURE__*/_regeneratorRuntime.mark(dijkstra);import isEqual from\"../helpers/2d-array-functions/is-equal\";import shallowCopy from\"../helpers/2d-array-functions/shallow-copy\";import{checkNeighbors}from\"./helpers/matrix-helpers/async-helpers/check-neighbors\";// import { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport{updateParent}from\"./helpers/matrix-helpers/setters-and-getters/update-parent\";import{updateDistance}from\"./helpers/matrix-helpers/setters-and-getters/update-distance\";import getShortestPath from\"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";import{PriorityQueue}from\"../data-structures/priority-queue\";import{calculateWeight}from\"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";export default function dijkstra(){var matrix,source,end,additional_destinations,walls,weights,end_coordinates,visited_coordinates,path,adjacency_matrix,visited,parent_coordinates,coordinates,queue,additional_dest,row,col,found,new_path,add_to_visited_nodes,add_to_path,generator,result,neighbors_coordinates,alternative_weight,undefined_or_path,_args=arguments;return _regeneratorRuntime.wrap(function dijkstra$(_context){while(1){switch(_context.prev=_context.next){case 0:matrix=_args.length>0&&_args[0]!==undefined?_args[0]:[[]];source=_args.length>1&&_args[1]!==undefined?_args[1]:[2,2];end=_args.length>2&&_args[2]!==undefined?_args[2]:[0,3];additional_destinations=_args.length>3?_args[3]:undefined;walls=_args.length>4?_args[4]:undefined;weights=_args.length>5?_args[5]:undefined;// let start_coordinates = [...source];\nend_coordinates=_toConsumableArray(end);visited_coordinates=[];path=[];adjacency_matrix=shallowCopy(matrix);visited=shallowCopy(matrix,false);parent_coordinates=shallowCopy(matrix,null);coordinates=_toConsumableArray(source);queue=new PriorityQueue();additional_dest=Object.assign({},additional_destinations);adjacency_matrix[source[0]][source[1]]=0;coordinates=[source[0],source[1]];visited[source[0]][source[1]]=true;parent_coordinates[source[0]][source[1]]=null;queue.enqueue(coordinates,0);visited_coordinates.push(coordinates);for(row=0;row<matrix.length;row++){for(col=0;col<matrix[row].length;col++){if(!isEqual(source,[row,col])){parent_coordinates[row][col]=null;adjacency_matrix[row][col]=Infinity;visited[row][col]=false;}}}found=false;case 23:if(!(!found&&!queue.isEmpty())){_context.next=45;break;}coordinates=queue.dequeue().element;visited_coordinates.push(coordinates);// updatetoVisited(coordinates, visited);\nif(!(additional_dest[coordinates]!==undefined)){_context.next=39;break;}delete additional_dest[coordinates];new_path=dijkstra(matrix,coordinates,end,additional_dest,walls,weights);add_to_visited_nodes=new_path.next().value;add_to_path=new_path.next().value;visited_coordinates=visited_coordinates.concat(add_to_visited_nodes);console.log(\"in additional[dest] - path pre-concat: \",path);// if no path to finish line\nif(!(add_to_path===undefined)){_context.next=35;break;}return _context.abrupt(\"break\",45);case 35:path=path.concat(add_to_path);console.log(\"in additional[dest] - path post-concat: \",path);end_coordinates=coordinates;found=true;case 39:if(coordinates[0]===end_coordinates[0]&&coordinates[1]===end_coordinates[1]&&Object.keys(additional_dest).length===0){found=true;}generator=checkNeighbors(coordinates,visited);result=null;do{result=generator.next();neighbors_coordinates=result.value;if(!result.done&&!found&&walls[neighbors_coordinates]===undefined){alternative_weight=calculateWeight(adjacency_matrix[coordinates[0]][coordinates[1]],neighbors_coordinates,weights);if(alternative_weight<adjacency_matrix[neighbors_coordinates[0]][neighbors_coordinates[1]]){updateDistance(alternative_weight,neighbors_coordinates,adjacency_matrix);queue.enqueue(neighbors_coordinates,alternative_weight);updateParent(coordinates,neighbors_coordinates,parent_coordinates);}}}while(!result.done);_context.next=23;break;case 45:_context.next=47;return visited_coordinates;case 47:// could be undefined or a path\nundefined_or_path=getShortestPath(end_coordinates,parent_coordinates);// if it is undefined, return undefined (void)\nif(!(undefined_or_path===undefined)){_context.next=50;break;}return _context.abrupt(\"return\");case 50:path=undefined_or_path.concat(path);_context.next=53;return path;case 53:case\"end\":return _context.stop();}}},_marked);}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/dijkstra.js"],"names":["dijkstra","isEqual","shallowCopy","checkNeighbors","updateParent","updateDistance","getShortestPath","PriorityQueue","calculateWeight","matrix","source","end","additional_destinations","walls","weights","end_coordinates","visited_coordinates","path","adjacency_matrix","visited","parent_coordinates","coordinates","queue","additional_dest","Object","assign","enqueue","push","row","length","col","Infinity","found","isEmpty","dequeue","element","undefined","new_path","add_to_visited_nodes","next","value","add_to_path","concat","console","log","keys","generator","result","neighbors_coordinates","done","alternative_weight","undefined_or_path"],"mappings":"yXAYyBA,Q,EAZzB,MAAOC,CAAAA,OAAP,KAAoB,wCAApB,CACA,MAAOC,CAAAA,WAAP,KAAwB,4CAAxB,CACA,OAASC,cAAT,KAA+B,wDAA/B,CACA;AACA,OAASC,YAAT,KAA6B,4DAA7B,CACA,OAASC,cAAT,KAA+B,8DAA/B,CACA,MAAOC,CAAAA,eAAP,KAA4B,gEAA5B,CACA,OAASC,aAAT,KAA8B,mCAA9B,CACA,OAASC,eAAT,KAAgC,+DAAhC,CAIA,cAAe,SAAUR,CAAAA,QAAV,2bAAmBS,MAAnB,+CAA4B,CAAC,EAAD,CAA5B,CAAkCC,MAAlC,+CAA2C,CAAC,CAAD,CAAI,CAAJ,CAA3C,CAAmDC,GAAnD,+CAAyD,CAAC,CAAD,CAAI,CAAJ,CAAzD,CAAiEC,uBAAjE,mCAA0FC,KAA1F,mCAAiGC,OAAjG,mCACX;AACIC,eAFO,oBAEeJ,GAFf,EAGPK,mBAHO,CAGe,EAHf,CAIPC,IAJO,CAIA,EAJA,CAKPC,gBALO,CAKYhB,WAAW,CAACO,MAAD,CALvB,CAMPU,OANO,CAMGjB,WAAW,CAACO,MAAD,CAAS,KAAT,CANd,CAOPW,kBAPO,CAOclB,WAAW,CAACO,MAAD,CAAS,IAAT,CAPzB,CAQPY,WARO,oBAQWX,MARX,EASPY,KATO,CASC,GAAIf,CAAAA,aAAJ,EATD,CAUPgB,eAVO,CAUWC,MAAM,CAACC,MAAP,CAAc,EAAd,CAAkBb,uBAAlB,CAVX,CAWXM,gBAAgB,CAACR,MAAM,CAAC,CAAD,CAAP,CAAhB,CAA4BA,MAAM,CAAC,CAAD,CAAlC,EAAyC,CAAzC,CACAW,WAAW,CAAG,CAACX,MAAM,CAAC,CAAD,CAAP,CAAYA,MAAM,CAAC,CAAD,CAAlB,CAAd,CACAS,OAAO,CAACT,MAAM,CAAC,CAAD,CAAP,CAAP,CAAmBA,MAAM,CAAC,CAAD,CAAzB,EAAgC,IAAhC,CACAU,kBAAkB,CAACV,MAAM,CAAC,CAAD,CAAP,CAAlB,CAA8BA,MAAM,CAAC,CAAD,CAApC,EAA2C,IAA3C,CACAY,KAAK,CAACI,OAAN,CAAcL,WAAd,CAA2B,CAA3B,EACAL,mBAAmB,CAACW,IAApB,CAAyBN,WAAzB,EAIA,IAASO,GAAT,CAAe,CAAf,CAAkBA,GAAG,CAAGnB,MAAM,CAACoB,MAA/B,CAAuCD,GAAG,EAA1C,CAA8C,CAC1C,IAASE,GAAT,CAAe,CAAf,CAAkBA,GAAG,CAAGrB,MAAM,CAACmB,GAAD,CAAN,CAAYC,MAApC,CAA4CC,GAAG,EAA/C,CAAmD,CAC/C,GAAI,CAAC7B,OAAO,CAACS,MAAD,CAAS,CAACkB,GAAD,CAAME,GAAN,CAAT,CAAZ,CAAkC,CAC9BV,kBAAkB,CAACQ,GAAD,CAAlB,CAAwBE,GAAxB,EAA+B,IAA/B,CACAZ,gBAAgB,CAACU,GAAD,CAAhB,CAAsBE,GAAtB,EAA6BC,QAA7B,CACAZ,OAAO,CAACS,GAAD,CAAP,CAAaE,GAAb,EAAoB,KAApB,CACH,CACJ,CACJ,CAGGE,KA/BO,CA+BC,KA/BD,cAgCJ,CAACA,KAAD,EAAU,CAACV,KAAK,CAACW,OAAN,EAhCP,2BAiCPZ,WAAW,CAAGC,KAAK,CAACY,OAAN,GAAgBC,OAA9B,CACAnB,mBAAmB,CAACW,IAApB,CAAyBN,WAAzB,EACA;AAnCO,KAoCHE,eAAe,CAACF,WAAD,CAAf,GAAiCe,SApC9B,2BAqCH,MAAOb,CAAAA,eAAe,CAACF,WAAD,CAAtB,CACIgB,QAtCD,CAsCYrC,QAAQ,CAACS,MAAD,CAASY,WAAT,CAAsBV,GAAtB,CAA2BY,eAA3B,CAA4CV,KAA5C,CAAmDC,OAAnD,CAtCpB,CAuCCwB,oBAvCD,CAuCwBD,QAAQ,CAACE,IAAT,GAAgBC,KAvCxC,CAwCCC,WAxCD,CAwCeJ,QAAQ,CAACE,IAAT,GAAgBC,KAxC/B,CAyCHxB,mBAAmB,CAAGA,mBAAmB,CAAC0B,MAApB,CAA2BJ,oBAA3B,CAAtB,CACAK,OAAO,CAACC,GAAR,CAAY,yCAAZ,CAAuD3B,IAAvD,EACA;AA3CG,KA4CCwB,WAAW,GAAKL,SA5CjB,sEA8CHnB,IAAI,CAAGA,IAAI,CAACyB,MAAL,CAAYD,WAAZ,CAAP,CACAE,OAAO,CAACC,GAAR,CAAY,0CAAZ,CAAwD3B,IAAxD,EACAF,eAAe,CAAGM,WAAlB,CACAW,KAAK,CAAG,IAAR,CAjDG,QAmDP,GAAMX,WAAW,CAAC,CAAD,CAAX,GAAmBN,eAAe,CAAC,CAAD,CAAnC,EAA4CM,WAAW,CAAC,CAAD,CAAX,GAAmBN,eAAe,CAAC,CAAD,CAA/E,EAAwFS,MAAM,CAACqB,IAAP,CAAYtB,eAAZ,EAA6BM,MAA7B,GAAwC,CAApI,CAAuI,CACnIG,KAAK,CAAG,IAAR,CACH,CAEKc,SAvDC,CAuDW3C,cAAc,CAACkB,WAAD,CAAcF,OAAd,CAvDzB,CAwDH4B,MAxDG,CAwDM,IAxDN,CA0DP,EAAG,CACCA,MAAM,CAAGD,SAAS,CAACP,IAAV,EAAT,CACIS,qBAFL,CAE6BD,MAAM,CAACP,KAFpC,CAGC,GAAI,CAACO,MAAM,CAACE,IAAR,EAAgB,CAACjB,KAAjB,EAA0BnB,KAAK,CAACmC,qBAAD,CAAL,GAAiCZ,SAA/D,CAA0E,CAClEc,kBADkE,CAC7C1C,eAAe,CAACU,gBAAgB,CAACG,WAAW,CAAC,CAAD,CAAZ,CAAhB,CAAiCA,WAAW,CAAC,CAAD,CAA5C,CAAD,CAAmD2B,qBAAnD,CAA0ElC,OAA1E,CAD8B,CAEtE,GAAIoC,kBAAkB,CAAGhC,gBAAgB,CAAC8B,qBAAqB,CAAC,CAAD,CAAtB,CAAhB,CAA2CA,qBAAqB,CAAC,CAAD,CAAhE,CAAzB,CAA+F,CAC3F3C,cAAc,CAAC6C,kBAAD,CAAqBF,qBAArB,CAA4C9B,gBAA5C,CAAd,CACAI,KAAK,CAACI,OAAN,CAAcsB,qBAAd,CAAqCE,kBAArC,EACA9C,YAAY,CAACiB,WAAD,CAAc2B,qBAAd,CAAqC5B,kBAArC,CAAZ,CACH,CACJ,CACJ,CAXD,MAYO,CAAC2B,MAAM,CAACE,IAZf,EA1DO,gDAwEX,MAAMjC,CAAAA,mBAAN,CAxEW,QAyEX;AACImC,iBA1EO,CA0Ea7C,eAAe,CAACS,eAAD,CAAkBK,kBAAlB,CA1E5B,CA2EX;AA3EW,KA4EP+B,iBAAiB,GAAKf,SA5Ef,oEAgFXnB,IAAI,CAAGkC,iBAAiB,CAACT,MAAlB,CAAyBzB,IAAzB,CAAP,CAhFW,iBAmFX,MAAMA,CAAAA,IAAN,CAnFW","sourcesContent":["import isEqual from \"../helpers/2d-array-functions/is-equal\";\nimport shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\n// import { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nimport { PriorityQueue } from \"../data-structures/priority-queue\";\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\n\n\n\nexport default function* dijkstra(matrix = [[]], source = [2, 2], end = [0, 3], additional_destinations, walls, weights) {\n    // let start_coordinates = [...source];\n    let end_coordinates = [...end];\n    let visited_coordinates = [];\n    let path = [];\n    let adjacency_matrix = shallowCopy(matrix);\n    let visited = shallowCopy(matrix, false);\n    let parent_coordinates = shallowCopy(matrix, null);\n    let coordinates = [...source];\n    let queue = new PriorityQueue();\n    let additional_dest = Object.assign({}, additional_destinations);\n    adjacency_matrix[source[0]][source[1]] = 0;\n    coordinates = [source[0], source[1]];\n    visited[source[0]][source[1]] = true;\n    parent_coordinates[source[0]][source[1]] = null;\n    queue.enqueue(coordinates, 0);\n    visited_coordinates.push(coordinates);\n\n\n\n    for (let row = 0; row < matrix.length; row++) {\n        for (let col = 0; col < matrix[row].length; col++) {\n            if (!isEqual(source, [row, col])) {\n                parent_coordinates[row][col] = null;\n                adjacency_matrix[row][col] = Infinity;\n                visited[row][col] = false;\n            }\n        }\n    }\n\n\n    let found = false;\n    while (!found && !queue.isEmpty()) {\n        coordinates = queue.dequeue().element;\n        visited_coordinates.push(coordinates);\n        // updatetoVisited(coordinates, visited);\n        if (additional_dest[coordinates] !== undefined) {\n            delete additional_dest[coordinates];\n            let new_path = dijkstra(matrix, coordinates, end, additional_dest, walls, weights);\n            let add_to_visited_nodes = new_path.next().value\n            let add_to_path = new_path.next().value\n            visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n            console.log(\"in additional[dest] - path pre-concat: \", path)\n            // if no path to finish line\n            if (add_to_path === undefined)\n                break;\n            path = path.concat(add_to_path);\n            console.log(\"in additional[dest] - path post-concat: \", path)\n            end_coordinates = coordinates;\n            found = true;\n        }\n        if (((coordinates[0] === end_coordinates[0]) && (coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n            found = true;\n        }\n\n        const generator = checkNeighbors(coordinates, visited);\n        let result = null;\n\n        do {\n            result = generator.next();\n            var neighbors_coordinates = result.value;\n            if (!result.done && !found && walls[neighbors_coordinates] === undefined) {\n                let alternative_weight = calculateWeight(adjacency_matrix[coordinates[0]][coordinates[1]], neighbors_coordinates, weights)\n                if (alternative_weight < adjacency_matrix[neighbors_coordinates[0]][neighbors_coordinates[1]]) {\n                    updateDistance(alternative_weight, neighbors_coordinates, adjacency_matrix);\n                    queue.enqueue(neighbors_coordinates, alternative_weight);\n                    updateParent(coordinates, neighbors_coordinates, parent_coordinates);\n                }\n            }\n        }\n        while (!result.done)\n    }\n    yield visited_coordinates;\n    // could be undefined or a path\n    let undefined_or_path = getShortestPath(end_coordinates, parent_coordinates);\n    // if it is undefined, return undefined (void)\n    if (undefined_or_path === undefined) {\n        return;\n    }\n\n    path = undefined_or_path.concat(path);\n\n\n    yield path\n    // yield* traverseShortestPath(end, parent_coordinates)\n\n}\n"]},"metadata":{},"sourceType":"module"}