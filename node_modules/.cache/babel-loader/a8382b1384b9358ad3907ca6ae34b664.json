{"ast":null,"code":"import isEqual from \"../helpers/2d-array-functions/is-equal\";\nimport shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport traverseShortestPath from \"./helpers/matrix-helpers/async-helpers/traverse-shortest-path\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nexport default function* dijkstra(matrix = [[]], source = [2, 2], end = [0, 3]) {\n  // yield [...source]\n  let visited_coordinates = [];\n  let adjacency_matrix = shallowCopy(matrix);\n  let visited = shallowCopy(matrix);\n  let parent_coordinates = shallowCopy(matrix);\n  let coordinates = source;\n  let queue = []; // setting all initial values for the source node within each data structure\n\n  adjacency_matrix[source[0]][source[1]] = 0;\n  coordinates = [source[0], source[1]];\n  visited[source[0]][source[1]] = true;\n  parent_coordinates[source[0]][source[1]] = null;\n  queue.push(coordinates);\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      if (!isEqual(source, [row, col])) {\n        parent_coordinates[row][col] = null;\n        adjacency_matrix[row][col] = Infinity;\n        visited[row][col] = false;\n      }\n    }\n  }\n\n  let found = false;\n\n  while (!found) {\n    coordinates = queue.shift();\n    const generator = checkNeighbors(coordinates, visited);\n    let result = null;\n\n    do {\n      result = generator.next();\n      var neighbors_coordinates = result.value;\n\n      if (!result.done && !found) {\n        updateDistance(adjacency_matrix[coordinates[0]][coordinates[1]], neighbors_coordinates, adjacency_matrix);\n        updatetoVisited(neighbors_coordinates, visited);\n        updateParent(coordinates, neighbors_coordinates, parent_coordinates);\n        queue.push(neighbors_coordinates);\n        found = isEqual(neighbors_coordinates, end);\n        yield [...neighbors_coordinates];\n      }\n    } while (!result.done);\n  }\n\n  yield* traverseShortestPath(end, parent_coordinates);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/dijkstra.js"],"names":["isEqual","shallowCopy","traverseShortestPath","checkNeighbors","updatetoVisited","updateParent","updateDistance","dijkstra","matrix","source","end","visited_coordinates","adjacency_matrix","visited","parent_coordinates","coordinates","queue","push","row","length","col","Infinity","found","shift","generator","result","next","neighbors_coordinates","value","done"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,wCAApB;AACA,OAAOC,WAAP,MAAwB,4CAAxB;AACA,OAAOC,oBAAP,MAAiC,+DAAjC;AACA,SAASC,cAAT,QAA+B,wDAA/B;AACA,SAASC,eAAT,QAAgC,gEAAhC;AACA,SAASC,YAAT,QAA6B,4DAA7B;AACA,SAASC,cAAT,QAA+B,8DAA/B;AAIA,eAAe,UAAUC,QAAV,CAAmBC,MAAM,GAAG,CAAC,EAAD,CAA5B,EAAkCC,MAAM,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA3C,EAAmDC,GAAG,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAzD,EAAiE;AAC5E;AACA,MAAIC,mBAAmB,GAAG,EAA1B;AACA,MAAIC,gBAAgB,GAAGX,WAAW,CAACO,MAAD,CAAlC;AACA,MAAIK,OAAO,GAAGZ,WAAW,CAACO,MAAD,CAAzB;AACA,MAAIM,kBAAkB,GAAGb,WAAW,CAACO,MAAD,CAApC;AACA,MAAIO,WAAW,GAAGN,MAAlB;AACA,MAAIO,KAAK,GAAG,EAAZ,CAP4E,CAS5E;;AACAJ,EAAAA,gBAAgB,CAACH,MAAM,CAAC,CAAD,CAAP,CAAhB,CAA4BA,MAAM,CAAC,CAAD,CAAlC,IAAyC,CAAzC;AACAM,EAAAA,WAAW,GAAG,CAACN,MAAM,CAAC,CAAD,CAAP,EAAYA,MAAM,CAAC,CAAD,CAAlB,CAAd;AACAI,EAAAA,OAAO,CAACJ,MAAM,CAAC,CAAD,CAAP,CAAP,CAAmBA,MAAM,CAAC,CAAD,CAAzB,IAAgC,IAAhC;AACAK,EAAAA,kBAAkB,CAACL,MAAM,CAAC,CAAD,CAAP,CAAlB,CAA8BA,MAAM,CAAC,CAAD,CAApC,IAA2C,IAA3C;AACAO,EAAAA,KAAK,CAACC,IAAN,CAAWF,WAAX;;AAGA,OAAK,IAAIG,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGV,MAAM,CAACW,MAA/B,EAAuCD,GAAG,EAA1C,EAA8C;AAC1C,SAAK,IAAIE,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGZ,MAAM,CAACU,GAAD,CAAN,CAAYC,MAApC,EAA4CC,GAAG,EAA/C,EAAmD;AAC/C,UAAI,CAACpB,OAAO,CAACS,MAAD,EAAS,CAACS,GAAD,EAAME,GAAN,CAAT,CAAZ,EAAkC;AAC9BN,QAAAA,kBAAkB,CAACI,GAAD,CAAlB,CAAwBE,GAAxB,IAA+B,IAA/B;AACAR,QAAAA,gBAAgB,CAACM,GAAD,CAAhB,CAAsBE,GAAtB,IAA6BC,QAA7B;AACAR,QAAAA,OAAO,CAACK,GAAD,CAAP,CAAaE,GAAb,IAAoB,KAApB;AACH;AACJ;AACJ;;AAGD,MAAIE,KAAK,GAAG,KAAZ;;AACA,SAAO,CAACA,KAAR,EAAe;AACXP,IAAAA,WAAW,GAAGC,KAAK,CAACO,KAAN,EAAd;AACA,UAAMC,SAAS,GAAGrB,cAAc,CAACY,WAAD,EAAcF,OAAd,CAAhC;AACA,QAAIY,MAAM,GAAG,IAAb;;AACA,OAAG;AACCA,MAAAA,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAT;AACA,UAAIC,qBAAqB,GAAGF,MAAM,CAACG,KAAnC;;AACA,UAAI,CAACH,MAAM,CAACI,IAAR,IAAgB,CAACP,KAArB,EAA4B;AACxBhB,QAAAA,cAAc,CAACM,gBAAgB,CAACG,WAAW,CAAC,CAAD,CAAZ,CAAhB,CAAiCA,WAAW,CAAC,CAAD,CAA5C,CAAD,EAAmDY,qBAAnD,EAA0Ef,gBAA1E,CAAd;AACAR,QAAAA,eAAe,CAACuB,qBAAD,EAAwBd,OAAxB,CAAf;AACAR,QAAAA,YAAY,CAACU,WAAD,EAAcY,qBAAd,EAAqCb,kBAArC,CAAZ;AACAE,QAAAA,KAAK,CAACC,IAAN,CAAWU,qBAAX;AACAL,QAAAA,KAAK,GAAGtB,OAAO,CAAC2B,qBAAD,EAAwBjB,GAAxB,CAAf;AACA,cAAM,CAAC,GAAGiB,qBAAJ,CAAN;AAEH;AACJ,KAZD,QAaO,CAACF,MAAM,CAACI,IAbf;AAcH;;AAED,SAAO3B,oBAAoB,CAACQ,GAAD,EAAMI,kBAAN,CAA3B;AAEH","sourcesContent":["import isEqual from \"../helpers/2d-array-functions/is-equal\";\nimport shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport traverseShortestPath from \"./helpers/matrix-helpers/async-helpers/traverse-shortest-path\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\n\n\n\nexport default function* dijkstra(matrix = [[]], source = [2, 2], end = [0, 3]) {\n    // yield [...source]\n    let visited_coordinates = [];\n    let adjacency_matrix = shallowCopy(matrix);\n    let visited = shallowCopy(matrix);\n    let parent_coordinates = shallowCopy(matrix);\n    let coordinates = source;\n    let queue = [];\n\n    // setting all initial values for the source node within each data structure\n    adjacency_matrix[source[0]][source[1]] = 0;\n    coordinates = [source[0], source[1]];\n    visited[source[0]][source[1]] = true;\n    parent_coordinates[source[0]][source[1]] = null;\n    queue.push(coordinates);\n\n\n    for (let row = 0; row < matrix.length; row++) {\n        for (let col = 0; col < matrix[row].length; col++) {\n            if (!isEqual(source, [row, col])) {\n                parent_coordinates[row][col] = null;\n                adjacency_matrix[row][col] = Infinity;\n                visited[row][col] = false;\n            }\n        }\n    }\n\n\n    let found = false;\n    while (!found) {\n        coordinates = queue.shift();\n        const generator = checkNeighbors(coordinates, visited);\n        let result = null;\n        do {\n            result = generator.next();\n            var neighbors_coordinates = result.value;\n            if (!result.done && !found) {\n                updateDistance(adjacency_matrix[coordinates[0]][coordinates[1]], neighbors_coordinates, adjacency_matrix);\n                updatetoVisited(neighbors_coordinates, visited);\n                updateParent(coordinates, neighbors_coordinates, parent_coordinates);\n                queue.push(neighbors_coordinates);\n                found = isEqual(neighbors_coordinates, end);\n                yield [...neighbors_coordinates];\n\n            }\n        }\n        while (!result.done)\n    }\n\n    yield* traverseShortestPath(end, parent_coordinates)\n\n}\n"]},"metadata":{},"sourceType":"module"}