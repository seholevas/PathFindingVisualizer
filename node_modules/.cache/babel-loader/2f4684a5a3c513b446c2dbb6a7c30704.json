{"ast":null,"code":"// 1  function Dijkstra(Graph, source):\n// 2\n// 3      create vertex set Q\n// 4\n// 5      for each vertex v in Graph:             \n// 6          dist[v] ← INFINITY                  \n// 7          prev[v] ← UNDEFINED                 \n// 8          add v to Q                      \n// 10      dist[source] ← 0                        \n// 11      \n// 12      while Q is not empty:\n// 13          u ← vertex in Q with min dist[u]    \n// 14                                              \n// 15          remove u from Q \n// 16          \n// 17          for each neighbor v of u:           // only v that are still in Q\n// 18              alt ← dist[u] + length(u, v)\n// 19              if alt < dist[v]:               \n// 20                  dist[v] ← alt \n// 21                  prev[v] ← u \n// 22\n// 23      return dist[], prev[]\nexport default function* dijkstra(matrix = [[]], source = [0, 0], final = matrix[(3, 3)]) {\n  let adjacency_matrix = [...matrix];\n  let coordinates = source;\n  let visited = {};\n  let queue = [];\n  let path = []; // let distance = {}\n  // let vertex_priority_queue = new \n  // let unvisited_nodes = new Array(matrix.length * matrix.length)\n  // console.log(\"unvisited: \", unvisited_nodes);\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      if (source[0] === row && source[1] === col) {\n        adjacency_matrix[row][col] = 0;\n        coordinates = [row, col];\n        visited[(row, col)] = true;\n        queue.push(coordinates);\n      } else {\n        adjacency_matrix[row][col] = Infinity;\n        visited[(row, col)] = false;\n      }\n\n      console.log(\"visited: \", visited[(row, col)]);\n    }\n  }\n\n  while (coordinates[0] !== final[0] && coordinates[1] !== final[1]) {\n    const generator = check_neighbors(coordinates, visited);\n    let result = null;\n\n    do {\n      result = generator.next();\n      let neighbors_coordinates = result.value;\n      update_distance(coordinates, neighbors_coordinates, adjacency_matrix);\n      update_to_visited(neighbors_coordinates, visited);\n      queue.push(neighbors_coordinates);\n      yield neighbors_coordinates;\n    } while (!result.done);\n  }\n\n  for (let i = 0; i < path.length; i++) {\n    yield path[i];\n  }\n}\n\nfunction update_distance(prev_value, node_location, adjacency_matrix) {\n  let row = node_location[0];\n  let column = node_location[1];\n  adjacency_matrix[row][column] = prev_value + 1;\n}\n\nfunction* check_neighbors(node_location, visited) {\n  let row = node_location[0];\n  let column = node_location[1];\n  const RIGHT = column + 1;\n  const LEFT = column - 1;\n  const UP = row - 1;\n  const DOWN = row + 1;\n\n  if (RIGHT >= 0 && !visited[row][RIGHT]) {\n    yield [row, RIGHT];\n  }\n\n  if (LEFT >= 0 && !visited[row][LEFT]) {\n    yield [row, LEFT];\n  }\n\n  if (UP >= 0 && !visited[UP][column]) {\n    yield [UP, column];\n  }\n\n  if (DOWN >= 0 && !visited[DOWN][column]) {\n    yield [DOWN, column];\n  }\n}\n\nfunction update_to_visited(node_location, visited) {\n  let row = node_location[0];\n  let col = node_location[1];\n  visited[(row, col)] = true;\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/dijkstra.js"],"names":["dijkstra","matrix","source","final","adjacency_matrix","coordinates","visited","queue","path","row","length","col","push","Infinity","console","log","generator","check_neighbors","result","next","neighbors_coordinates","value","update_distance","update_to_visited","done","i","prev_value","node_location","column","RIGHT","LEFT","UP","DOWN"],"mappings":"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","sourcesContent":["// 1  function Dijkstra(Graph, source):\n// 2\n// 3      create vertex set Q\n// 4\n// 5      for each vertex v in Graph:             \n// 6          dist[v] ← INFINITY                  \n// 7          prev[v] ← UNDEFINED                 \n// 8          add v to Q                      \n// 10      dist[source] ← 0                        \n// 11      \n// 12      while Q is not empty:\n// 13          u ← vertex in Q with min dist[u]    \n// 14                                              \n// 15          remove u from Q \n// 16          \n// 17          for each neighbor v of u:           // only v that are still in Q\n// 18              alt ← dist[u] + length(u, v)\n// 19              if alt < dist[v]:               \n// 20                  dist[v] ← alt \n// 21                  prev[v] ← u \n// 22\n// 23      return dist[], prev[]\n\nexport default function* dijkstra(matrix = [[]], source = [0,0], final = matrix[3,3]) {\n    let adjacency_matrix = [...matrix]\n    let coordinates = source;\n    let visited = {};\n    let queue = [] \n    let path = [];\n    // let distance = {}\n    // let vertex_priority_queue = new \n\n    // let unvisited_nodes = new Array(matrix.length * matrix.length)\n    // console.log(\"unvisited: \", unvisited_nodes);\n\n    for (let row = 0; row < matrix.length; row++) {\n        for (let col = 0; col < matrix[row].length; col++) {\n            if (source[0] === row && source[1] === col) {\n                adjacency_matrix[row][col] = 0;\n                coordinates = [row, col];\n                visited[row, col] = true;\n                queue.push(coordinates);\n            }\n            else {\n                adjacency_matrix[row][col] = Infinity;\n                visited[row, col] = false;\n            }\n            console.log(\"visited: \", visited[row, col])\n        }\n    }\n\n\n\n    while (coordinates[0] !== final[0] && coordinates[1] !== final[1]) \n    {\n\n        const generator = check_neighbors(coordinates,visited);\n        let result = null;\n        do\n        {\n            result = generator.next();\n            let neighbors_coordinates = result.value;\n            update_distance(coordinates, neighbors_coordinates, adjacency_matrix);\n            update_to_visited(neighbors_coordinates, visited);\n            queue.push(neighbors_coordinates);\n            yield neighbors_coordinates;\n        }\n        while(!result.done)\n\n    }\n\n    for(let i = 0; i < path.length; i++)\n    {\n        yield path[i];\n    }\n\n\n}\n\nfunction update_distance(prev_value, node_location, adjacency_matrix) {\n    let row = node_location[0];\n    let column = node_location[1];\n    adjacency_matrix[row][column] = prev_value + 1;\n}\n\n\n\nfunction* check_neighbors(node_location, visited) {\n    let row = node_location[0];\n    let column = node_location[1];\n    const RIGHT = column + 1;\n    const LEFT = column - 1;\n    const UP = row - 1;\n    const DOWN = row + 1;\n\n    if (RIGHT >= 0 && !visited[row][RIGHT]) {\n        yield [row, RIGHT];\n    }\n    if (LEFT >= 0 && !visited[row][LEFT]) {\n        yield [row, LEFT];\n    }\n\n    if (UP >= 0 && !visited[UP][column]) {\n        yield [UP, column];\n    }\n    if (DOWN >= 0 && !visited[DOWN][column]) {\n        yield [DOWN, column];\n    }\n\n}\n\nfunction update_to_visited(node_location, visited)\n{\n    let row = node_location[0];\n    let col = node_location[1];\n    visited[row,col] = true;\n}"]},"metadata":{},"sourceType":"module"}