{"ast":null,"code":"import shallowCopy from \"../../../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./async-helpers/check-neighbors\";\nimport { updateParent } from \"./setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./setters-and-getters/coordinates-are-equal\"; // import {PriorityQueue} from \"../../../data-structures/min-priority-queue\";\n\nexport default function* aStar(adjacency_matrix = [[]], start_coordinates = [0, 0], end_cordinates = [3, 3]) {\n  // let priority_queue = new PriorityQueue((a,b) => a[1] > b[1]);\n  var p_queue = new PriorityQueue();\n  console.log(p_queue.isEmpty());\n  let priority_queue = [];\n  let parent_matrix = shallowCopy(adjacency_matrix, null);\n  let visited = shallowCopy(adjacency_matrix, false);\n  let distance_matrix = shallowCopy(adjacency_matrix, Infinity);\n  distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0; // + manhattanDistance(start_coordinates, end_cordinates);\n\n  priority_queue.push([manhattanDistance(start_coordinates, end_cordinates), [...start_coordinates]]);\n\n  while (priority_queue.length !== 0) {\n    let tuple = priority_queue.shift(); // let f_cost = tuple[0];\n\n    let current_coordinates = tuple[1];\n    visited[current_coordinates[0]][current_coordinates[1]] = true;\n    yield [...current_coordinates];\n\n    if (coordinatesAreEqual(current_coordinates, end_cordinates)) {\n      break;\n    }\n\n    const generator = checkNeighbors(current_coordinates, visited);\n    let result = generator.next();\n\n    while (!result.done) {\n      let neighbor_coordinates = result.value;\n      let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]]; // EDIT: needs to change once weight and walls are added in.\n\n      let cost_from_current_node = distance_matrix[current_coordinates[0]][current_coordinates[1]] + 1;\n      let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates, end_cordinates);\n      let is_current_cost_less = distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] > cost_from_current_node;\n      let is_neighbor_in_priority_queue = priority_queue.includes([f_cost, neighbor_coordinates]);\n\n      if (!have_visited && is_neighbor_in_priority_queue && is_current_cost_less) {\n        const index = priority_queue.indexOf([f_cost, neighbor_coordinates]);\n        priority_queue.splice(index);\n      }\n\n      if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_queue) {\n        // update the distance of the neighbor_node\n        distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node; // update the parent node of the neighbor node to the current node\n\n        updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n        priority_queue.push([f_cost, neighbor_coordinates]);\n      }\n\n      priority_queue.sort((a, b) => {\n        if (a[0] < b[0]) {\n          return -1;\n        }\n\n        if (a[0] === b[0]) {\n          if (a[1][0] < b[1][0]) {\n            return -1;\n          } else if (a[1][0] > b[1][0]) {\n            return 1;\n          }\n\n          if (a[1][1] < b[1][1]) {\n            return -1;\n          } else if (a[1][1] > b[1][1]) {\n            return 1;\n          }\n\n          return 0;\n        }\n\n        return 1;\n      });\n      result = generator.next();\n    }\n  }\n}\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n  return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/helpers/matrix-helpers/a-star.js"],"names":["shallowCopy","checkNeighbors","updateParent","coordinatesAreEqual","aStar","adjacency_matrix","start_coordinates","end_cordinates","p_queue","PriorityQueue","console","log","isEmpty","priority_queue","parent_matrix","visited","distance_matrix","Infinity","push","manhattanDistance","length","tuple","shift","current_coordinates","generator","result","next","done","neighbor_coordinates","value","have_visited","cost_from_current_node","f_cost","is_current_cost_less","is_neighbor_in_priority_queue","includes","index","indexOf","splice","sort","a","b","coordinates1","coordinates2","Math","abs"],"mappings":"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","sourcesContent":["import shallowCopy from \"../../../helpers/2d-array-functions/shallow-copy\"\nimport { checkNeighbors } from \"./async-helpers/check-neighbors\";\nimport { updateParent } from \"./setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./setters-and-getters/coordinates-are-equal\";\n// import {PriorityQueue} from \"../../../data-structures/min-priority-queue\";\n\nexport default function* aStar(adjacency_matrix = [[]], start_coordinates = [0, 0], end_cordinates = [3, 3]) {\n    // let priority_queue = new PriorityQueue((a,b) => a[1] > b[1]);\n    var p_queue = new PriorityQueue();\n    console.log(p_queue.isEmpty());\n    let priority_queue = [];\n    let parent_matrix = shallowCopy(adjacency_matrix, null);\n    let visited = shallowCopy(adjacency_matrix, false);\n    let distance_matrix = shallowCopy(adjacency_matrix, Infinity);\n\n    distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n    // + manhattanDistance(start_coordinates, end_cordinates);\n    priority_queue.push([manhattanDistance(start_coordinates, end_cordinates), [...start_coordinates]])\n    while (priority_queue.length !== 0) {\n        let tuple = priority_queue.shift();\n        // let f_cost = tuple[0];\n        let current_coordinates = tuple[1];\n        visited[current_coordinates[0]][current_coordinates[1]] = true;\n        yield [...current_coordinates];\n\n        if(coordinatesAreEqual(current_coordinates,end_cordinates))\n        {\n            break;\n        }\n\n        const generator = checkNeighbors(current_coordinates, visited);\n        let result = generator.next();\n\n        while (!result.done) {\n            let neighbor_coordinates = result.value\n            let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]];\n            // EDIT: needs to change once weight and walls are added in.\n            let cost_from_current_node = distance_matrix[current_coordinates[0]][current_coordinates[1]] + 1;\n\n            let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates, end_cordinates)\n\n            let is_current_cost_less = distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] > cost_from_current_node\n            let is_neighbor_in_priority_queue = priority_queue.includes([f_cost, neighbor_coordinates]);\n\n            if (!have_visited && is_neighbor_in_priority_queue && is_current_cost_less) {\n                const index = priority_queue.indexOf([f_cost, neighbor_coordinates]);\n                priority_queue.splice(index);\n\n            }\n            if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_queue) {\n                // update the distance of the neighbor_node\n                distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n                // update the parent node of the neighbor node to the current node\n                updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n                priority_queue.push([f_cost, neighbor_coordinates])\n\n            }\n\n            priority_queue.sort((a, b) => {\n                if (a[0] < b[0]) \n                {\n                    return -1\n                }\n                if (a[0] === b[0]) \n                {\n                    if(a[1][0] < b[1][0])\n                    {\n                        return -1\n                    }\n                    else if(a[1][0]> b[1][0])\n                    {\n                        return 1\n                    }\n                    if(a[1][1] < b[1][1])\n                    {\n                        return -1\n                    }\n                    else if (a[1][1] > b[1][1])\n                    {\n                        return 1;\n                    }\n                    return 0;\n                }\n                return 1\n            });\n            \n            result = generator.next();\n        }\n    }\n\n\n\n\n}\n\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n    return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}"]},"metadata":{},"sourceType":"module"}