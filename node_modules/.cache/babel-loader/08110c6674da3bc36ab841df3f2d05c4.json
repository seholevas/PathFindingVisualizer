{"ast":null,"code":"import isEqual from \"../helpers/2d-array-functions/is-equal\";\nimport shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nimport { PriorityQueue } from \"../data-structures/priority-queue\";\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\nexport default function* dijkstra(matrix = [[]], source = [2, 2], end = [0, 3], additional_destinations, walls, weights) {\n  let start_coordinates = [...source];\n  let end_coordinates = [...end];\n  let visited_coordinates = [];\n  let path = [];\n  let adjacency_matrix = shallowCopy(matrix);\n  let visited = shallowCopy(matrix, false);\n  let parent_coordinates = shallowCopy(matrix, null);\n  let coordinates = [...source];\n  let queue = new PriorityQueue();\n  let additional_dest = Object.assign({}, additional_destinations);\n  adjacency_matrix[source[0]][source[1]] = 0;\n  coordinates = [source[0], source[1]];\n  visited[source[0]][source[1]] = true;\n  parent_coordinates[source[0]][source[1]] = null;\n  queue.enqueue(coordinates, 0);\n  visited_coordinates.push(coordinates);\n\n  for (let row = 0; row < matrix.length; row++) {\n    for (let col = 0; col < matrix[row].length; col++) {\n      if (!isEqual(source, [row, col])) {\n        parent_coordinates[row][col] = null;\n        adjacency_matrix[row][col] = Infinity;\n        visited[row][col] = false;\n      }\n    }\n  }\n\n  let found = false;\n\n  while (!found && !queue.isEmpty() && Object.keys(additional_dest).length === 0) {\n    coordinates = queue.dequeue().element;\n    visited_coordinates.push(coordinates); // updatetoVisited(coordinates, visited);\n\n    if (additional_dest[coordinates] !== undefined) {\n      delete additional_dest[coordinates];\n      let new_path = dijkstra(matrix, coordinates, end, additional_dest, walls, weights);\n      let add_to_visited_nodes = new_path.next().value;\n      let add_to_path = new_path.next().value;\n      visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n      console.log(\"in additional[dest] - path pre-concat: \", path); // if no path to finish line\n\n      if (add_to_path === undefined) break;\n      path = path.concat(add_to_path);\n      console.log(\"in additional[dest] - path post-concat: \", path);\n      end_coordinates = coordinates;\n      found = true;\n    }\n\n    if (vertex_coordinates[0] === end_coordinates[0] && vertex_coordinates[1] === end_coordinates[1] && Object.keys(additional_dest).length === 0) {\n      found = true;\n    }\n\n    const generator = checkNeighbors(coordinates, visited);\n    let result = null;\n\n    do {\n      result = generator.next();\n      var neighbors_coordinates = result.value;\n\n      if (!result.done && !found && walls[neighbors_coordinates] === undefined) {\n        let alternative_weight = calculateWeight(adjacency_matrix[coordinates[0]][coordinates[1]], neighbors_coordinates, weights);\n\n        if (alternative_weight < adjacency_matrix[neighbors_coordinates[0]][neighbors_coordinates[1]]) {\n          updateDistance(alternative_weight, neighbors_coordinates, adjacency_matrix);\n          queue.enqueue(neighbors_coordinates, alternative_weight);\n          updateParent(coordinates, neighbors_coordinates, parent_coordinates);\n        }\n      }\n    } while (!result.done);\n  }\n\n  yield visited_coordinates; // could be undefined or a path\n\n  let undefined_or_path = getShortestPath(end_coordinates, parent_coordinates); // if it is undefined, return undefined (void)\n\n  if (undefined_or_path === undefined) {\n    return;\n  }\n\n  path = undefined_or_path.concat(path);\n  yield path; // yield* traverseShortestPath(end, parent_coordinates)\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/dijkstra.js"],"names":["isEqual","shallowCopy","checkNeighbors","updatetoVisited","updateParent","updateDistance","getShortestPath","PriorityQueue","calculateWeight","dijkstra","matrix","source","end","additional_destinations","walls","weights","start_coordinates","end_coordinates","visited_coordinates","path","adjacency_matrix","visited","parent_coordinates","coordinates","queue","additional_dest","Object","assign","enqueue","push","row","length","col","Infinity","found","isEmpty","keys","dequeue","element","undefined","new_path","add_to_visited_nodes","next","value","add_to_path","concat","console","log","vertex_coordinates","generator","result","neighbors_coordinates","done","alternative_weight","undefined_or_path"],"mappings":"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","sourcesContent":["import isEqual from \"../helpers/2d-array-functions/is-equal\";\nimport shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nimport { PriorityQueue } from \"../data-structures/priority-queue\";\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\n\n\n\nexport default function* dijkstra(matrix = [[]], source = [2, 2], end = [0, 3], additional_destinations, walls, weights) {\n    let start_coordinates = [...source];\n    let end_coordinates = [...end];\n    let visited_coordinates = [];\n    let path = [];\n    let adjacency_matrix = shallowCopy(matrix);\n    let visited = shallowCopy(matrix, false);\n    let parent_coordinates = shallowCopy(matrix, null);\n    let coordinates = [...source];\n    let queue = new PriorityQueue();\n    let additional_dest = Object.assign({}, additional_destinations);\n    adjacency_matrix[source[0]][source[1]] = 0;\n    coordinates = [source[0], source[1]];\n    visited[source[0]][source[1]] = true;\n    parent_coordinates[source[0]][source[1]] = null;\n    queue.enqueue(coordinates, 0);\n    visited_coordinates.push(coordinates);\n\n\n\n    for (let row = 0; row < matrix.length; row++) {\n        for (let col = 0; col < matrix[row].length; col++) {\n            if (!isEqual(source, [row, col])) {\n                parent_coordinates[row][col] = null;\n                adjacency_matrix[row][col] = Infinity;\n                visited[row][col] = false;\n            }\n        }\n    }\n\n\n    let found = false;\n    while (!found && !queue.isEmpty() && Object.keys(additional_dest).length === 0) {\n        coordinates = queue.dequeue().element;\n        visited_coordinates.push(coordinates);\n        // updatetoVisited(coordinates, visited);\n        if (additional_dest[coordinates] !== undefined) {\n            delete additional_dest[coordinates];\n            let new_path = dijkstra(matrix, coordinates, end, additional_dest, walls, weights);\n            let add_to_visited_nodes = new_path.next().value\n            let add_to_path = new_path.next().value\n            visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n            console.log(\"in additional[dest] - path pre-concat: \", path)\n            // if no path to finish line\n            if (add_to_path === undefined)\n                break;\n            path = path.concat(add_to_path);\n            console.log(\"in additional[dest] - path post-concat: \", path)\n            end_coordinates = coordinates;\n            found = true;\n        }\n        if (((vertex_coordinates[0] === end_coordinates[0]) && (vertex_coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n            found = true;\n        }\n\n        const generator = checkNeighbors(coordinates, visited);\n        let result = null;\n\n        do {\n            result = generator.next();\n            var neighbors_coordinates = result.value;\n            if (!result.done && !found && walls[neighbors_coordinates] === undefined) {\n                let alternative_weight = calculateWeight(adjacency_matrix[coordinates[0]][coordinates[1]], neighbors_coordinates, weights)\n                if (alternative_weight < adjacency_matrix[neighbors_coordinates[0]][neighbors_coordinates[1]]) {\n                    updateDistance(alternative_weight, neighbors_coordinates, adjacency_matrix);\n                    queue.enqueue(neighbors_coordinates, alternative_weight);\n                    updateParent(coordinates, neighbors_coordinates, parent_coordinates);\n                }\n            }\n        }\n        while (!result.done)\n    }\n    yield visited_coordinates;\n    // could be undefined or a path\n    let undefined_or_path = getShortestPath(end_coordinates, parent_coordinates);\n    // if it is undefined, return undefined (void)\n    if (undefined_or_path === undefined) {\n        return;\n    }\n\n    path = undefined_or_path.concat(path);\n\n\n    yield path\n    // yield* traverseShortestPath(end, parent_coordinates)\n\n}\n"]},"metadata":{},"sourceType":"module"}