{"ast":null,"code":"import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\"; // import { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\n\nimport { PriorityQueue } from \"../data-structures/priority-queue\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\"; // import { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\n\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\"; // export default function* aStar(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations ={}, walls={}, weights={}) {\n//     let found = false;\n//     let start_coordinates =[...start]\n//     let end_coordinates = [...end]\n//     var priority_queue = new PriorityQueue();\n//     let additional_dest = Object.assign({}, additional_destinations);\n//     let visited_coordinates = [];\n//     let path = [];\n//     let parent_matrix = shallowCopy(matrix, null);\n//     let visited = shallowCopy(matrix, false);\n//     let distance_matrix = shallowCopy(matrix, Infinity);\n//     distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n//     priority_queue.enqueue([...start_coordinates], manhattanDistance(start_coordinates, end_coordinates));\n//     while (!priority_queue.isEmpty() && !found) {\n//         let q_item = priority_queue.dequeue();\n//         // let f_cost = tuple[0];\n//         let current_coordinates = q_item.element;\n//         updatetoVisited(current_coordinates,visited);\n//         visited_coordinates.push(current_coordinates);\n//         if (Object.keys(additional_dest).length !== 0) {\n//             let keys = Object.keys(additional_dest);\n//             let coord = additional_dest[keys[0]];\n//             delete additional_dest[keys[0]];\n//             let start_to_additional = aStar(matrix, current_coordinates, coord, additional_dest);\n//             let visited_coords = start_to_additional.next().value;\n//             let path_coords = start_to_additional.next().value;\n//             visited_coordinates.concat(visited_coords);\n//             path = getShortestPath(coord,parent_matrix);\n//         }\n//         if (((current_coordinates[0] === end_coordinates[0]) && (current_coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n//             found = true;\n//         }\n//         // yield [...current_coordinates];\n//         // if(coordinatesAreEqual(current_coordinates,end_coordinates))\n//         // {\n//         //     break;\n//         // }\n//         const generator = checkNeighbors(current_coordinates, visited);\n//         let result = generator.next();\n//         while (!result.done && !found) {\n//             let neighbor_coordinates = result.value\n//             let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]];\n//             // EDIT: needs to change once weight and walls are added in.\n//             let cost_from_current_node = calculateWeight(distance_matrix[current_coordinates[0]][current_coordinates[1]],neighbor_coordinates,weights);\n//             let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates,end_coordinates);\n//             // cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates) \n//             let is_current_cost_less = f_cost < distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]];\n//             let is_neighbor_in_priority_queue = priority_queue.items.includes([f_cost, neighbor_coordinates]);\n//             if (!have_visited && is_neighbor_in_priority_queue && is_current_cost_less) {\n//                 const index = priority_queue.items.indexOf([f_cost, neighbor_coordinates]);\n//                 priority_queue.items.splice(index);\n//             }\n//             if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_queue && walls[neighbor_coordinates] === undefined) {\n//                 // update the distance of the neighbor_node\n//                 updateDistance(f_cost,neighbor_coordinates,distance_matrix)\n//                 // distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n//                 // update the parent node of the neighbor node to the current node\n//                 updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n//                 priority_queue.enqueue(neighbor_coordinates, manhattanDistance(neighbor_coordinates, end_coordinates) )\n//             }\n//             result = generator.next();\n//         }\n//     }\n//     yield visited_coordinates;\n//     // could be undefined or a path\n//     let undefined_or_path = getShortestPath(end_coordinates, parent_matrix);\n//     // if it is undefined, return undefined (void)\n//     if (undefined_or_path === undefined) {\n//         return;\n//     }\n//     path = undefined_or_path.concat(path);\n//     yield path\n//     // yield getShortestPath(end_coordinates, parent_matrix);\n//     // yield* traverseShortestPath(end_coordinates,parent_matrix);\n// }\n\nexport default function* aStar(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations = {}, walls = {}, weights = {}) {\n  let start_coordinates = [...start];\n  let end_coordinates = [...end];\n  let path = [];\n  let visited_coordinates = [];\n  let priority_queue = new PriorityQueue();\n  let parent_matrix = shallowCopy(matrix, null);\n  let visited = shallowCopy(matrix, false);\n  let g_cost = shallowCopy(matrix, Infinity);\n  let h_cost = shallowCopy(matrix, Infinity);\n  let f_cost = shallowCopy(matrix, Infinity);\n  visited[start[0]][start[1]] = true;\n  g_cost[start[0]][start[1]] = 0;\n  h_cost[start[0]][start[1]] = manhattanDistance(start, end);\n  f_cost[start[0]][start[1]] = g_cost[start[0]][start[1]] + h_cost[start[0]][start[1]];\n  priority_queue.enqueue(start_coordinates, f_cost[start[0]][start[1]]);\n\n  while (!priority_queue.isEmpty()) {\n    let current = priority_queue.dequeue();\n    visited_coordinates.push(current);\n    const generator = checkNeighbors(current, visited);\n  }\n}\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n  return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/a-star.js"],"names":["shallowCopy","checkNeighbors","PriorityQueue","updatetoVisited","getShortestPath","calculateWeight","updateParent","updateDistance","aStar","matrix","start","end","additional_destinations","walls","weights","start_coordinates","end_coordinates","path","visited_coordinates","priority_queue","parent_matrix","visited","g_cost","Infinity","h_cost","f_cost","manhattanDistance","enqueue","isEmpty","current","dequeue","push","generator","coordinates1","coordinates2","Math","abs"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,4CAAxB;AACA,SAASC,cAAT,QAA+B,wDAA/B,C,CACA;;AACA,SAASC,aAAT,QAA8B,mCAA9B;AACA,SAASC,eAAT,QAAgC,gEAAhC;AACA,OAAOC,eAAP,MAA4B,gEAA5B,C,CACA;;AACA,SAASC,eAAT,QAAgC,+DAAhC;AACA,SAASC,YAAT,QAA6B,4DAA7B;AACA,SAASC,cAAT,QAA+B,8DAA/B,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAKA;;AAGA,eAAe,UAAUC,KAAV,CAAgBC,MAAM,GAAG,CAAC,EAAD,CAAzB,EAA+BC,KAAK,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAvC,EAA+CC,GAAG,GAAG,CAAC,CAAD,EAAI,CAAJ,CAArD,EAA6DC,uBAAuB,GAAG,EAAvF,EAA2FC,KAAK,GAAG,EAAnG,EAAuGC,OAAO,GAAG,EAAjH,EAAqH;AAChI,MAAIC,iBAAiB,GAAG,CAAC,GAAGL,KAAJ,CAAxB;AACA,MAAIM,eAAe,GAAG,CAAC,GAAGL,GAAJ,CAAtB;AACA,MAAIM,IAAI,GAAG,EAAX;AACA,MAAIC,mBAAmB,GAAG,EAA1B;AACA,MAAIC,cAAc,GAAG,IAAIjB,aAAJ,EAArB;AACA,MAAIkB,aAAa,GAAGpB,WAAW,CAACS,MAAD,EAAS,IAAT,CAA/B;AACA,MAAIY,OAAO,GAAGrB,WAAW,CAACS,MAAD,EAAS,KAAT,CAAzB;AACA,MAAIa,MAAM,GAAGtB,WAAW,CAACS,MAAD,EAASc,QAAT,CAAxB;AACA,MAAIC,MAAM,GAAGxB,WAAW,CAACS,MAAD,EAASc,QAAT,CAAxB;AACA,MAAIE,MAAM,GAAGzB,WAAW,CAACS,MAAD,EAASc,QAAT,CAAxB;AAEAF,EAAAA,OAAO,CAACX,KAAK,CAAC,CAAD,CAAN,CAAP,CAAkBA,KAAK,CAAC,CAAD,CAAvB,IAA8B,IAA9B;AACAY,EAAAA,MAAM,CAACZ,KAAK,CAAC,CAAD,CAAN,CAAN,CAAiBA,KAAK,CAAC,CAAD,CAAtB,IAA6B,CAA7B;AACAc,EAAAA,MAAM,CAACd,KAAK,CAAC,CAAD,CAAN,CAAN,CAAiBA,KAAK,CAAC,CAAD,CAAtB,IAA6BgB,iBAAiB,CAAChB,KAAD,EAAQC,GAAR,CAA9C;AACAc,EAAAA,MAAM,CAACf,KAAK,CAAC,CAAD,CAAN,CAAN,CAAiBA,KAAK,CAAC,CAAD,CAAtB,IAA6BY,MAAM,CAACZ,KAAK,CAAC,CAAD,CAAN,CAAN,CAAiBA,KAAK,CAAC,CAAD,CAAtB,IAA6Bc,MAAM,CAACd,KAAK,CAAC,CAAD,CAAN,CAAN,CAAiBA,KAAK,CAAC,CAAD,CAAtB,CAA1D;AAEAS,EAAAA,cAAc,CAACQ,OAAf,CAAuBZ,iBAAvB,EAA0CU,MAAM,CAACf,KAAK,CAAC,CAAD,CAAN,CAAN,CAAiBA,KAAK,CAAC,CAAD,CAAtB,CAA1C;;AAGA,SAAO,CAACS,cAAc,CAACS,OAAf,EAAR,EAAkC;AAC9B,QAAIC,OAAO,GAAGV,cAAc,CAACW,OAAf,EAAd;AACAZ,IAAAA,mBAAmB,CAACa,IAApB,CAAyBF,OAAzB;AAEA,UAAMG,SAAS,GAAG/B,cAAc,CAAC4B,OAAD,EAAUR,OAAV,CAAhC;AAEH;AACJ;;AACD,SAASK,iBAAT,CAA2BO,YAAY,GAAG,EAA1C,EAA8CC,YAAY,GAAG,EAA7D,EAAiE;AAC7D,SAAOC,IAAI,CAACC,GAAL,CAASH,YAAY,CAAC,CAAD,CAAZ,GAAkBC,YAAY,CAAC,CAAD,CAAvC,IAA8CC,IAAI,CAACC,GAAL,CAASH,YAAY,CAAC,CAAD,CAAZ,GAAkBC,YAAY,CAAC,CAAD,CAAvC,CAArD;AACH","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\"\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\n// import { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { PriorityQueue } from \"../data-structures/priority-queue\"\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\n// import { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\n\n// export default function* aStar(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations ={}, walls={}, weights={}) {\n//     let found = false;\n//     let start_coordinates =[...start]\n//     let end_coordinates = [...end]\n//     var priority_queue = new PriorityQueue();\n//     let additional_dest = Object.assign({}, additional_destinations);\n//     let visited_coordinates = [];\n//     let path = [];\n//     let parent_matrix = shallowCopy(matrix, null);\n//     let visited = shallowCopy(matrix, false);\n//     let distance_matrix = shallowCopy(matrix, Infinity);\n\n\n//     distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n\n//     priority_queue.enqueue([...start_coordinates], manhattanDistance(start_coordinates, end_coordinates));\n//     while (!priority_queue.isEmpty() && !found) {\n//         let q_item = priority_queue.dequeue();\n//         // let f_cost = tuple[0];\n//         let current_coordinates = q_item.element;\n//         updatetoVisited(current_coordinates,visited);\n//         visited_coordinates.push(current_coordinates);\n\n//         if (Object.keys(additional_dest).length !== 0) {\n//             let keys = Object.keys(additional_dest);\n//             let coord = additional_dest[keys[0]];\n//             delete additional_dest[keys[0]];\n//             let start_to_additional = aStar(matrix, current_coordinates, coord, additional_dest);\n//             let visited_coords = start_to_additional.next().value;\n//             let path_coords = start_to_additional.next().value;\n//             visited_coordinates.concat(visited_coords);\n//             path = getShortestPath(coord,parent_matrix);\n\n//         }\n//         if (((current_coordinates[0] === end_coordinates[0]) && (current_coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n//             found = true;\n//         }\n//         // yield [...current_coordinates];\n\n//         // if(coordinatesAreEqual(current_coordinates,end_coordinates))\n//         // {\n//         //     break;\n//         // }\n\n//         const generator = checkNeighbors(current_coordinates, visited);\n//         let result = generator.next();\n\n//         while (!result.done && !found) {\n//             let neighbor_coordinates = result.value\n//             let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]];\n//             // EDIT: needs to change once weight and walls are added in.\n//             let cost_from_current_node = calculateWeight(distance_matrix[current_coordinates[0]][current_coordinates[1]],neighbor_coordinates,weights);\n\n//             let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates,end_coordinates);\n//             // cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates) \n\n//             let is_current_cost_less = f_cost < distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]];\n//             let is_neighbor_in_priority_queue = priority_queue.items.includes([f_cost, neighbor_coordinates]);\n\n//             if (!have_visited && is_neighbor_in_priority_queue && is_current_cost_less) {\n//                 const index = priority_queue.items.indexOf([f_cost, neighbor_coordinates]);\n//                 priority_queue.items.splice(index);\n\n//             }\n//             if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_queue && walls[neighbor_coordinates] === undefined) {\n//                 // update the distance of the neighbor_node\n//                 updateDistance(f_cost,neighbor_coordinates,distance_matrix)\n//                 // distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n//                 // update the parent node of the neighbor node to the current node\n//                 updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n//                 priority_queue.enqueue(neighbor_coordinates, manhattanDistance(neighbor_coordinates, end_coordinates) )\n//             }\n\n//             result = generator.next();\n//         }\n//     }\n//     yield visited_coordinates;\n//     // could be undefined or a path\n//     let undefined_or_path = getShortestPath(end_coordinates, parent_matrix);\n//     // if it is undefined, return undefined (void)\n//     if (undefined_or_path === undefined) {\n//         return;\n//     }\n\n//     path = undefined_or_path.concat(path);\n\n\n//     yield path\n//     // yield getShortestPath(end_coordinates, parent_matrix);\n//     // yield* traverseShortestPath(end_coordinates,parent_matrix);\n\n\n\n\n// }\n\n\nexport default function* aStar(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations = {}, walls = {}, weights = {}) {\n    let start_coordinates = [...start];\n    let end_coordinates = [...end];\n    let path = []\n    let visited_coordinates = []\n    let priority_queue = new PriorityQueue();\n    let parent_matrix = shallowCopy(matrix, null);\n    let visited = shallowCopy(matrix, false);\n    let g_cost = shallowCopy(matrix, Infinity);\n    let h_cost = shallowCopy(matrix, Infinity);\n    let f_cost = shallowCopy(matrix, Infinity);\n\n    visited[start[0]][start[1]] = true;\n    g_cost[start[0]][start[1]] = 0;\n    h_cost[start[0]][start[1]] = manhattanDistance(start, end);\n    f_cost[start[0]][start[1]] = g_cost[start[0]][start[1]] + h_cost[start[0]][start[1]];\n\n    priority_queue.enqueue(start_coordinates, f_cost[start[0]][start[1]])\n\n\n    while (!priority_queue.isEmpty()) {\n        let current = priority_queue.dequeue();\n        visited_coordinates.push(current);\n\n        const generator = checkNeighbors(current, visited);\n\n    }\n}\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n    return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}"]},"metadata":{},"sourceType":"module"}