{"ast":null,"code":"import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { PriorityQueue } from \"../data-structures/priority-queue\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\"; // export default function* aStar(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations ={}, walls={}, weights={}) {\n//     let found = false;\n//     let start_coordinates =[...start]\n//     let end_coordinates = [...end]\n//     var priority_open_set = new Priorityopen_set();\n//     let additional_dest = Object.assign({}, additional_destinations);\n//     let visited_coordinates = [];\n//     let path = [];\n//     let parent_matrix = shallowCopy(matrix, null);\n//     let visited = shallowCopy(matrix, false);\n//     let distance_matrix = shallowCopy(matrix, Infinity);\n//     distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n//     priority_open_set.enopen_set([...start_coordinates], manhattanDistance(start_coordinates, end_coordinates));\n//     while (!priority_open_set.isEmpty() && !found) {\n//         let q_item = priority_open_set.deopen_set();\n//         // let f_cost = tuple[0];\n//         let current_coordinates = q_item.element;\n//         updatetoVisited(current_coordinates,visited);\n//         visited_coordinates.push(current_coordinates);\n//         if (additional_dest[current_coordinates] !== undefined) {\n//             delete additional_dest[current_coordinates];\n//             let new_path = aStar(matrix, current_coordinates, end_coordinates, additional_dest, walls)\n//             let add_to_visited_nodes = new_path.next().value\n//             let add_to_path = new_path.next().value\n//             visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n//             console.log(\"in additional[dest] - path pre-concat: \", path)\n//             // if no path to finish line\n//             if (add_to_path === undefined)\n//                 break;\n//             path = path.concat(add_to_path);\n//             console.log(\"in additional[dest] - path post-concat: \", path)\n//             end_coordinates = current_coordinates;\n//             found = true;\n//         }\n//         if (((current_coordinates[0] === end_coordinates[0]) && (current_coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n//             found = true;\n//         }\n//         // yield [...current_coordinates];\n//         // if(coordinatesAreEqual(current_coordinates,end_coordinates))\n//         // {\n//         //     break;\n//         // }\n//         const generator = checkNeighbors(current_coordinates, visited);\n//         let result = generator.next();\n//         while (!result.done) {\n//             let neighbor_coordinates = result.value\n//             let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]];\n//             // EDIT: needs to change once weight and walls are added in.\n//             let cost_from_current_node = calculateWeight(distance_matrix[current_coordinates[0]][current_coordinates[1]],neighbor_coordinates,weights);\n//             let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates,end_coordinates);\n//             // cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates) \n//             let is_current_cost_less = distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] > cost_from_current_node\n//             let is_neighbor_in_priority_open_set = priority_open_set.items.includes([f_cost, neighbor_coordinates]);\n//             if (!have_visited && is_neighbor_in_priority_open_set && is_current_cost_less) {\n//                 const index = priority_open_set.items.indexOf([f_cost, neighbor_coordinates]);\n//                 priority_open_set.items.splice(index);\n//             }\n//             if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_open_set) {\n//                 // update the distance of the neighbor_node\n//                 updateDistance(cost_from_current_node,neighbor_coordinates,distance_matrix)\n//                 // distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n//                 // update the parent node of the neighbor node to the current node\n//                 updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n//                 priority_open_set.enopen_set(neighbor_coordinates, manhattanDistance(neighbor_coordinates, end_coordinates))\n//             }\n//             result = generator.next();\n//         }\n//     }\n//     yield visited_coordinates;\n//     // could be undefined or a path\n//     let undefined_or_path = getShortestPath(end_coordinates, parent_matrix);\n//     // if it is undefined, return undefined (void)\n//     if (undefined_or_path === undefined) {\n//         return;\n//     }\n//     path = undefined_or_path.concat(path);\n//     yield path\n//     // yield getShortestPath(end_coordinates, parent_matrix);\n//     // yield* traverseShortestPath(end_coordinates,parent_matrix);\n// }\n\nexport default function* aStar(matrix = [[]], start = [5, 5], end = [9, 9], additional_destinations = {}, walls = {}, weights = {}) {\n  let start_coordinates = [...start];\n  let end_coordinates = [...end]; // let open_set = new Set();\n\n  let open_set = new PriorityQueue();\n  let visited_coordinates = [];\n  let came_from = shallowCopy(matrix, null);\n  let visited = shallowCopy(matrix, false);\n  let g_score = shallowCopy(matrix, Infinity);\n  let f_score = shallowCopy(matrix, Infinity);\n  let found = false;\n  g_score[start_coordinates[0]][start_coordinates[1]] = 0;\n  f_score[start_coordinates[0]][start_coordinates[1]] = manhattanDistance(start_coordinates, end_coordinates) + calculateWeight(0, start_coordinates, weights);\n  open_set.enopen_set(start_coordinates, f_score[start_coordinates[0]][start_coordinates[1]]);\n\n  while (!open_set.isEmpty() && !found) {\n    let current = open_set.deopen_set();\n\n    if (JSON.stringify(current) === JSON.stringify(end_coordinates)) {\n      found = true;\n    } else {\n      const generator = checkNeighbors(current, visited);\n      let result = generator.next();\n\n      while (!result.done) {\n        let neighbor = result.value; // if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n        //     // yield value;\n        //     updatetoVisited(value, visited);\n        //     updateParent(current, value, came_from);\n        //     open_set.push(value);\n        //     visited_coordinates.push(value);\n        // }\n\n        result = generator.next();\n      }\n    }\n  }\n}\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n  return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/a-star.js"],"names":["shallowCopy","checkNeighbors","updateParent","PriorityQueue","updatetoVisited","getShortestPath","updateDistance","calculateWeight","aStar","matrix","start","end","additional_destinations","walls","weights","start_coordinates","end_coordinates","open_set","visited_coordinates","came_from","visited","g_score","Infinity","f_score","found","manhattanDistance","enopen_set","isEmpty","current","deopen_set","JSON","stringify","generator","result","next","done","neighbor","value","coordinates1","coordinates2","Math","abs"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,4CAAxB;AACA,SAASC,cAAT,QAA+B,wDAA/B;AACA,SAASC,YAAT,QAA6B,4DAA7B;AACA,SAASC,aAAT,QAA8B,mCAA9B;AACA,SAASC,eAAT,QAAgC,gEAAhC;AACA,OAAOC,eAAP,MAA4B,gEAA5B;AACA,SAASC,cAAT,QAA+B,8DAA/B;AACA,SAASC,eAAT,QAAgC,+DAAhC,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAKA;;AAEA,eAAe,UAAUC,KAAV,CAAgBC,MAAM,GAAG,CAAC,EAAD,CAAzB,EAA+BC,KAAK,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAvC,EAA+CC,GAAG,GAAG,CAAC,CAAD,EAAI,CAAJ,CAArD,EAA6DC,uBAAuB,GAAG,EAAvF,EAA2FC,KAAK,GAAG,EAAnG,EAAuGC,OAAO,GAAG,EAAjH,EAAqH;AAChI,MAAIC,iBAAiB,GAAG,CAAC,GAAGL,KAAJ,CAAxB;AACA,MAAIM,eAAe,GAAG,CAAC,GAAGL,GAAJ,CAAtB,CAFgI,CAGhI;;AACA,MAAIM,QAAQ,GAAG,IAAId,aAAJ,EAAf;AACA,MAAIe,mBAAmB,GAAG,EAA1B;AACA,MAAIC,SAAS,GAAGnB,WAAW,CAACS,MAAD,EAAS,IAAT,CAA3B;AACA,MAAIW,OAAO,GAAGpB,WAAW,CAACS,MAAD,EAAS,KAAT,CAAzB;AACA,MAAIY,OAAO,GAAGrB,WAAW,CAACS,MAAD,EAASa,QAAT,CAAzB;AACA,MAAIC,OAAO,GAAGvB,WAAW,CAACS,MAAD,EAASa,QAAT,CAAzB;AACA,MAAIE,KAAK,GAAG,KAAZ;AACAH,EAAAA,OAAO,CAACN,iBAAiB,CAAC,CAAD,CAAlB,CAAP,CAA8BA,iBAAiB,CAAC,CAAD,CAA/C,IAAsD,CAAtD;AACAQ,EAAAA,OAAO,CAACR,iBAAiB,CAAC,CAAD,CAAlB,CAAP,CAA8BA,iBAAiB,CAAC,CAAD,CAA/C,IAAsDU,iBAAiB,CAACV,iBAAD,EAAoBC,eAApB,CAAjB,GAAwDT,eAAe,CAAC,CAAD,EAAIQ,iBAAJ,EAAuBD,OAAvB,CAA7H;AAEAG,EAAAA,QAAQ,CAACS,UAAT,CAAoBX,iBAApB,EAAuCQ,OAAO,CAACR,iBAAiB,CAAC,CAAD,CAAlB,CAAP,CAA8BA,iBAAiB,CAAC,CAAD,CAA/C,CAAvC;;AAEA,SAAO,CAACE,QAAQ,CAACU,OAAT,EAAD,IAAuB,CAACH,KAA/B,EAAsC;AAClC,QAAII,OAAO,GAAGX,QAAQ,CAACY,UAAT,EAAd;;AAEA,QAAGC,IAAI,CAACC,SAAL,CAAeH,OAAf,MAA4BE,IAAI,CAACC,SAAL,CAAef,eAAf,CAA/B,EACA;AACIQ,MAAAA,KAAK,GAAG,IAAR;AACH,KAHD,MAIK;AACD,YAAMQ,SAAS,GAAG/B,cAAc,CAAC2B,OAAD,EAAUR,OAAV,CAAhC;AACA,UAAIa,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAb;;AAEA,aAAO,CAACD,MAAM,CAACE,IAAf,EAAqB;AACjB,YAAIC,QAAQ,GAAGH,MAAM,CAACI,KAAtB,CADiB,CAGjB;AACA;AACA;AACA;AACA;AACA;AACA;;AACAJ,QAAAA,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAT;AACH;AACJ;AAGJ;AAGJ;;AAGD,SAAST,iBAAT,CAA2Ba,YAAY,GAAG,EAA1C,EAA8CC,YAAY,GAAG,EAA7D,EAAiE;AAC7D,SAAOC,IAAI,CAACC,GAAL,CAASH,YAAY,CAAC,CAAD,CAAZ,GAAkBC,YAAY,CAAC,CAAD,CAAvC,IAA8CC,IAAI,CAACC,GAAL,CAASH,YAAY,CAAC,CAAD,CAAZ,GAAkBC,YAAY,CAAC,CAAD,CAAvC,CAArD;AACH","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\"\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport { PriorityQueue } from \"../data-structures/priority-queue\"\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nimport { updateDistance } from \"./helpers/matrix-helpers/setters-and-getters/update-distance\";\nimport { calculateWeight } from \"./helpers/matrix-helpers/setters-and-getters/calculate-weight\";\n\n// export default function* aStar(matrix = [[]], start = [0, 0], end = [3, 3], additional_destinations ={}, walls={}, weights={}) {\n//     let found = false;\n//     let start_coordinates =[...start]\n//     let end_coordinates = [...end]\n//     var priority_open_set = new Priorityopen_set();\n//     let additional_dest = Object.assign({}, additional_destinations);\n//     let visited_coordinates = [];\n//     let path = [];\n//     let parent_matrix = shallowCopy(matrix, null);\n//     let visited = shallowCopy(matrix, false);\n//     let distance_matrix = shallowCopy(matrix, Infinity);\n\n\n//     distance_matrix[start_coordinates[0]][start_coordinates[1]] = 0;\n\n//     priority_open_set.enopen_set([...start_coordinates], manhattanDistance(start_coordinates, end_coordinates));\n//     while (!priority_open_set.isEmpty() && !found) {\n//         let q_item = priority_open_set.deopen_set();\n//         // let f_cost = tuple[0];\n//         let current_coordinates = q_item.element;\n//         updatetoVisited(current_coordinates,visited);\n//         visited_coordinates.push(current_coordinates);\n\n//         if (additional_dest[current_coordinates] !== undefined) {\n//             delete additional_dest[current_coordinates];\n//             let new_path = aStar(matrix, current_coordinates, end_coordinates, additional_dest, walls)\n//             let add_to_visited_nodes = new_path.next().value\n//             let add_to_path = new_path.next().value\n//             visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n//             console.log(\"in additional[dest] - path pre-concat: \", path)\n//             // if no path to finish line\n//             if (add_to_path === undefined)\n//                 break;\n//             path = path.concat(add_to_path);\n//             console.log(\"in additional[dest] - path post-concat: \", path)\n\n\n//             end_coordinates = current_coordinates;\n//             found = true;\n\n//         }\n//         if (((current_coordinates[0] === end_coordinates[0]) && (current_coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n//             found = true;\n//         }\n//         // yield [...current_coordinates];\n\n//         // if(coordinatesAreEqual(current_coordinates,end_coordinates))\n//         // {\n//         //     break;\n//         // }\n\n//         const generator = checkNeighbors(current_coordinates, visited);\n//         let result = generator.next();\n\n//         while (!result.done) {\n//             let neighbor_coordinates = result.value\n//             let have_visited = visited[neighbor_coordinates[0]][neighbor_coordinates[1]];\n//             // EDIT: needs to change once weight and walls are added in.\n//             let cost_from_current_node = calculateWeight(distance_matrix[current_coordinates[0]][current_coordinates[1]],neighbor_coordinates,weights);\n\n//             let f_cost = cost_from_current_node + manhattanDistance(neighbor_coordinates,end_coordinates);\n//             // cost_from_current_node + manhattanDistance(neighbor_coordinates, end_coordinates) \n\n//             let is_current_cost_less = distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] > cost_from_current_node\n//             let is_neighbor_in_priority_open_set = priority_open_set.items.includes([f_cost, neighbor_coordinates]);\n\n//             if (!have_visited && is_neighbor_in_priority_open_set && is_current_cost_less) {\n//                 const index = priority_open_set.items.indexOf([f_cost, neighbor_coordinates]);\n//                 priority_open_set.items.splice(index);\n\n//             }\n//             if (!have_visited && is_current_cost_less && !is_neighbor_in_priority_open_set) {\n//                 // update the distance of the neighbor_node\n//                 updateDistance(cost_from_current_node,neighbor_coordinates,distance_matrix)\n//                 // distance_matrix[neighbor_coordinates[0]][neighbor_coordinates[1]] = cost_from_current_node;\n//                 // update the parent node of the neighbor node to the current node\n//                 updateParent(current_coordinates, neighbor_coordinates, parent_matrix);\n//                 priority_open_set.enopen_set(neighbor_coordinates, manhattanDistance(neighbor_coordinates, end_coordinates))\n//             }\n\n//             result = generator.next();\n//         }\n//     }\n//     yield visited_coordinates;\n//     // could be undefined or a path\n//     let undefined_or_path = getShortestPath(end_coordinates, parent_matrix);\n//     // if it is undefined, return undefined (void)\n//     if (undefined_or_path === undefined) {\n//         return;\n//     }\n\n//     path = undefined_or_path.concat(path);\n\n\n//     yield path\n//     // yield getShortestPath(end_coordinates, parent_matrix);\n//     // yield* traverseShortestPath(end_coordinates,parent_matrix);\n\n\n\n\n// }\n\nexport default function* aStar(matrix = [[]], start = [5, 5], end = [9, 9], additional_destinations = {}, walls = {}, weights = {}) {\n    let start_coordinates = [...start];\n    let end_coordinates = [...end];\n    // let open_set = new Set();\n    let open_set = new PriorityQueue();\n    let visited_coordinates = [];\n    let came_from = shallowCopy(matrix, null);\n    let visited = shallowCopy(matrix, false);\n    let g_score = shallowCopy(matrix, Infinity);\n    let f_score = shallowCopy(matrix, Infinity);\n    let found = false;\n    g_score[start_coordinates[0]][start_coordinates[1]] = 0;\n    f_score[start_coordinates[0]][start_coordinates[1]] = manhattanDistance(start_coordinates, end_coordinates) + calculateWeight(0, start_coordinates, weights);\n\n    open_set.enopen_set(start_coordinates, f_score[start_coordinates[0]][start_coordinates[1]]);\n\n    while (!open_set.isEmpty() && !found) {\n        let current = open_set.deopen_set();\n\n        if(JSON.stringify(current) === JSON.stringify(end_coordinates))\n        {\n            found = true;\n        }\n        else {\n            const generator = checkNeighbors(current, visited);\n            let result = generator.next();\n\n            while (!result.done) {\n                let neighbor = result.value\n\n                // if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n                //     // yield value;\n                //     updatetoVisited(value, visited);\n                //     updateParent(current, value, came_from);\n                //     open_set.push(value);\n                //     visited_coordinates.push(value);\n                // }\n                result = generator.next();\n            }\n        }\n\n\n    }\n\n    \n}\n\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n    return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}"]},"metadata":{},"sourceType":"module"}