{"ast":null,"code":"import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nexport default function* depthFirstSearch(matrix = [[]], start_node_coordinates = [2, 2], end_node_coordinates = [0, 0], additional_destinations, walls) {\n  // data structure for storing next values\n  let stack = [];\n  let path = [];\n  let start_coordinates = [...start_node_coordinates];\n  let end_coordinates = [...end_node_coordinates];\n  let additional_dest = Object.assign({}, additional_destinations); // coordinates that have been visited\n\n  let visited_coordinates = []; // matrix that shows if a node at index [i][j] has been visited\n\n  let visited = shallowCopy(matrix, false); // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n\n  let parent_matrix = shallowCopy(matrix, null); // if end is found\n\n  let found = false; // pushing the starting coordintes into the stack, this will be where we start our search.\n\n  stack.push([...start_node_coordinates]); // while stack is not empty\n\n  while (stack.length !== 0 && !found) {\n    // the current verticies.\n    let vertex_coordinates = stack.pop();\n    visited_coordinates.push(vertex_coordinates);\n\n    if (additional_dest[vertex_coordinates] !== undefined) {\n      delete additional_dest[vertex_coordinates];\n      let new_path = depthFirstSearch(matrix, vertex_coordinates, end_coordinates, additional_dest, walls);\n      let add_to_visited_nodes = new_path.next().value;\n      let add_to_path = new_path.next().value;\n      visited_coordinates = visited_coordinates.concat(add_to_visited_nodes); // console.log(\"in additional[dest] - path pre-concat: \", path)\n      // if no path to finish line\n\n      if (add_to_path === undefined) break; // path = path.concat(add_to_path);\n\n      console.log(\"in additional[dest] - path post-concat: \", path);\n      end_coordinates = vertex_coordinates;\n      found = true;\n    }\n\n    if (vertex_coordinates[0] === end_coordinates[0] && vertex_coordinates[1] === end_coordinates[1] && Object.keys(additional_dest).length === 0) {\n      found = true;\n    } else {\n      updatetoVisited(vertex_coordinates, visited);\n      const generator = checkNeighbors(vertex_coordinates, visited);\n      let result = generator.next();\n\n      while (!result.done) {\n        let value = result.value;\n\n        if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n          updateParent(vertex_coordinates, value, parent_matrix);\n          stack.push(value);\n        }\n\n        result = generator.next();\n      }\n    }\n  }\n\n  yield visited_coordinates; // could be undefined or a path\n\n  let undefined_or_path = getShortestPath(end_coordinates, parent_matrix); // if it is undefined, return undefined (void)\n\n  if (undefined_or_path === undefined) {\n    return;\n  }\n\n  path = undefined_or_path.concat(path);\n  console.log(\"path: \", path);\n  yield path;\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/depth-first-search.js"],"names":["shallowCopy","updatetoVisited","checkNeighbors","updateParent","coordinatesAreEqual","getShortestPath","depthFirstSearch","matrix","start_node_coordinates","end_node_coordinates","additional_destinations","walls","stack","path","start_coordinates","end_coordinates","additional_dest","Object","assign","visited_coordinates","visited","parent_matrix","found","push","length","vertex_coordinates","pop","undefined","new_path","add_to_visited_nodes","next","value","add_to_path","concat","console","log","keys","generator","result","done","undefined_or_path"],"mappings":"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","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport coordinatesAreEqual from \"./helpers/matrix-helpers/setters-and-getters/coordinates-are-equal\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\n\n\nexport default function* depthFirstSearch(matrix = [[]], start_node_coordinates = [2, 2], end_node_coordinates = [0, 0], additional_destinations, walls) {\n    // data structure for storing next values\n    let stack = [];\n    let path = [];\n    let start_coordinates = [...start_node_coordinates];\n    let end_coordinates = [...end_node_coordinates];\n    let additional_dest = Object.assign({}, additional_destinations);\n    // coordinates that have been visited\n    let visited_coordinates = [];\n\n    // matrix that shows if a node at index [i][j] has been visited\n    let visited = shallowCopy(matrix, false);\n    // stores whether a node at [i][j] has a parent node. if so, stores the coordinates of the parent at [i][j], else null values\n    let parent_matrix = shallowCopy(matrix, null);\n    // if end is found\n    let found = false;\n    // pushing the starting coordintes into the stack, this will be where we start our search.\n    stack.push([...start_node_coordinates]);\n    // while stack is not empty\n    while (stack.length !== 0 && !found) {\n        // the current verticies.\n        let vertex_coordinates = stack.pop();\n        visited_coordinates.push(vertex_coordinates);\n\n        if (additional_dest[vertex_coordinates] !== undefined) {\n            delete additional_dest[vertex_coordinates];\n            let new_path = depthFirstSearch(matrix, vertex_coordinates, end_coordinates, additional_dest, walls);\n            let add_to_visited_nodes = new_path.next().value\n            let add_to_path = new_path.next().value\n            visited_coordinates = visited_coordinates.concat(add_to_visited_nodes);\n            // console.log(\"in additional[dest] - path pre-concat: \", path)\n            // if no path to finish line\n            if (add_to_path === undefined)\n                break;\n            // path = path.concat(add_to_path);\n            console.log(\"in additional[dest] - path post-concat: \", path)\n\n\n            end_coordinates = vertex_coordinates;\n            found = true;\n\n        }\n        if (((vertex_coordinates[0] === end_coordinates[0]) && (vertex_coordinates[1] === end_coordinates[1])) && Object.keys(additional_dest).length === 0) {\n            found = true;\n        }\n        else {\n            updatetoVisited(vertex_coordinates, visited);\n\n\n            const generator = checkNeighbors(vertex_coordinates, visited);\n            let result = generator.next();\n\n            while (!result.done) {\n                let value = result.value\n\n                if (!visited[value[0]][value[1]] && walls[value] === undefined) {\n                    updateParent(vertex_coordinates, value, parent_matrix);\n                    stack.push(value);\n                }\n\n                result = generator.next();\n            }\n        }\n    }\n\n\n    yield visited_coordinates;\n\n    // could be undefined or a path\n    let undefined_or_path = getShortestPath(end_coordinates, parent_matrix);\n    // if it is undefined, return undefined (void)\n    if (undefined_or_path === undefined) {\n        return;\n    }\n\n    path = undefined_or_path.concat(path);\n\n    console.log(\"path: \", path)\n    yield path\n}\n\n"]},"metadata":{},"sourceType":"module"}