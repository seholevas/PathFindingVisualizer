{"ast":null,"code":"import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\"; // import { check_neighbors, update_to_visited, update_parent } from \"./dijkstra\"\n\nimport traverseShortestPath from \"./helpers/matrix-helpers/async-helpers/traverse-shortest-path\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\";\nexport function* breadthFirstSearch(matrix = [[]], start_coordinates = [2, 2], end_coordinates = [3, 3]) {\n  // yield start_coordinates;\n  let visited_coordinates = [];\n  let shortest_path = [];\n  let queue = [];\n  let visited = shallowCopy(matrix, false);\n  let found = false;\n  let parent_matrix = shallowCopy(matrix, null);\n  console.log(\"visited: \", visited);\n  visited[start_coordinates[0]][start_coordinates[1]] = true;\n  queue.push(start_coordinates);\n\n  while (queue.length !== 0 && !found) {\n    let vertex_coordinates = queue.shift();\n\n    if (vertex_coordinates[0] === end_coordinates[0] && vertex_coordinates[1] === end_coordinates[1]) {\n      found = true;\n      yield visited_coordinates; // yield* traverseShortestPath(end_coordinates,parent_matrix);\n      // yield vertex_coordinates;\n    } else {\n      const generator = checkNeighbors(vertex_coordinates, visited);\n      let result = generator.next();\n\n      while (!result.done) {\n        let value = result.value;\n\n        if (visited[value[0]][value[1]] === false) {\n          // yield value;\n          updatetoVisited(value, visited);\n          updateParent(vertex_coordinates, value, parent_matrix);\n          queue.push(value);\n          visited_coordinates.push(value);\n        }\n\n        result = generator.next();\n      }\n    }\n  }\n\n  return getShortestPath(end_coordinates, parent_matrix);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/breadth-first-search.js"],"names":["shallowCopy","traverseShortestPath","checkNeighbors","updatetoVisited","updateParent","getShortestPath","breadthFirstSearch","matrix","start_coordinates","end_coordinates","visited_coordinates","shortest_path","queue","visited","found","parent_matrix","console","log","push","length","vertex_coordinates","shift","generator","result","next","done","value"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,4CAAxB,C,CACA;;AACA,OAAOC,oBAAP,MAAiC,+DAAjC;AACA,SAASC,cAAT,QAA+B,wDAA/B;AACA,SAASC,eAAT,QAAgC,gEAAhC;AACA,SAASC,YAAT,QAA6B,4DAA7B;AACA,OAAOC,eAAP,MAA4B,gEAA5B;AACA,OAAO,UAAUC,kBAAV,CAA6BC,MAAM,GAAG,CAAC,EAAD,CAAtC,EAA4CC,iBAAiB,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAhE,EAAwEC,eAAe,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA1F,EAAkG;AACrG;AACA,MAAIC,mBAAmB,GAAG,EAA1B;AACA,MAAIC,aAAa,GAAG,EAApB;AACA,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,OAAO,GAAGb,WAAW,CAACO,MAAD,EAAS,KAAT,CAAzB;AACA,MAAIO,KAAK,GAAG,KAAZ;AACA,MAAIC,aAAa,GAAGf,WAAW,CAACO,MAAD,EAAS,IAAT,CAA/B;AACAS,EAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyBJ,OAAzB;AACAA,EAAAA,OAAO,CAACL,iBAAiB,CAAC,CAAD,CAAlB,CAAP,CAA8BA,iBAAiB,CAAC,CAAD,CAA/C,IAAsD,IAAtD;AACAI,EAAAA,KAAK,CAACM,IAAN,CAAWV,iBAAX;;AAGA,SAAOI,KAAK,CAACO,MAAN,KAAiB,CAAjB,IAAsB,CAACL,KAA9B,EAAqC;AACjC,QAAIM,kBAAkB,GAAGR,KAAK,CAACS,KAAN,EAAzB;;AACA,QAAKD,kBAAkB,CAAC,CAAD,CAAlB,KAA2BX,eAAe,CAAC,CAAD,CAA3C,IAAoDW,kBAAkB,CAAC,CAAD,CAAlB,KAA0BX,eAAe,CAAC,CAAD,CAAjG,EAAuG;AACnGK,MAAAA,KAAK,GAAG,IAAR;AACA,YAAMJ,mBAAN,CAFmG,CAInG;AACA;AACH,KAND,MAOK;AACD,YAAMY,SAAS,GAAGpB,cAAc,CAACkB,kBAAD,EAAqBP,OAArB,CAAhC;AACA,UAAIU,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAb;;AAEA,aAAO,CAACD,MAAM,CAACE,IAAf,EAAqB;AACjB,YAAIC,KAAK,GAAGH,MAAM,CAACG,KAAnB;;AAEA,YAAIb,OAAO,CAACa,KAAK,CAAC,CAAD,CAAN,CAAP,CAAkBA,KAAK,CAAC,CAAD,CAAvB,MAAgC,KAApC,EACA;AACI;AACAvB,UAAAA,eAAe,CAACuB,KAAD,EAAQb,OAAR,CAAf;AACAT,UAAAA,YAAY,CAACgB,kBAAD,EAAoBM,KAApB,EAA0BX,aAA1B,CAAZ;AACAH,UAAAA,KAAK,CAACM,IAAN,CAAWQ,KAAX;AACAhB,UAAAA,mBAAmB,CAACQ,IAApB,CAAyBQ,KAAzB;AACH;;AACDH,QAAAA,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAT;AACH;AACJ;AACJ;;AAED,SAAOnB,eAAe,CAACI,eAAD,EAAkBM,aAAlB,CAAtB;AACH","sourcesContent":["import shallowCopy from \"../helpers/2d-array-functions/shallow-copy\";\n// import { check_neighbors, update_to_visited, update_parent } from \"./dijkstra\"\nimport traverseShortestPath from \"./helpers/matrix-helpers/async-helpers/traverse-shortest-path\";\nimport { checkNeighbors } from \"./helpers/matrix-helpers/async-helpers/check-neighbors\";\nimport { updatetoVisited } from \"./helpers/matrix-helpers/setters-and-getters/update-to-visited\";\nimport { updateParent } from \"./helpers/matrix-helpers/setters-and-getters/update-parent\";\nimport getShortestPath from \"./helpers/matrix-helpers/setters-and-getters/get-shortest-path\"\nexport function* breadthFirstSearch(matrix = [[]], start_coordinates = [2, 2], end_coordinates = [3, 3]) {\n    // yield start_coordinates;\n    let visited_coordinates = [];\n    let shortest_path = []\n    let queue = [];\n    let visited = shallowCopy(matrix, false);\n    let found = false;\n    let parent_matrix = shallowCopy(matrix, null);\n    console.log(\"visited: \", visited);\n    visited[start_coordinates[0]][start_coordinates[1]] = true;\n    queue.push(start_coordinates);\n\n\n    while (queue.length !== 0 && !found) {\n        let vertex_coordinates = queue.shift();\n        if ((vertex_coordinates[0] ===  end_coordinates[0]) && (vertex_coordinates[1] === end_coordinates[1])) {\n            found = true;\n            yield visited_coordinates;\n            \n            // yield* traverseShortestPath(end_coordinates,parent_matrix);\n            // yield vertex_coordinates;\n        }\n        else {\n            const generator = checkNeighbors(vertex_coordinates, visited);\n            let result = generator.next();\n\n            while (!result.done) {\n                let value = result.value\n\n                if (visited[value[0]][value[1]] === false)\n                {\n                    // yield value;\n                    updatetoVisited(value, visited);\n                    updateParent(vertex_coordinates,value,parent_matrix);\n                    queue.push(value);\n                    visited_coordinates.push(value);\n                }    \n                result = generator.next();\n            }\n        }\n    }\n    \n    return getShortestPath(end_coordinates, parent_matrix);\n}"]},"metadata":{},"sourceType":"module"}