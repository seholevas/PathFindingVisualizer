{"ast":null,"code":"// function reconstruct_path(cameFrom, current)\n//     total_path := {current}\n//     while current in cameFrom.Keys:\n//         current := cameFrom[current]\n//         total_path.prepend(current)\n//     return total_path\n// // A* finds a path from start to goal.\n// // h is the heuristic function. h(n) estimates the cost to reach goal from node n.\n// function A_Star(start, goal, h)\n//     // The set of discovered nodes that may need to be (re-)expanded.\n//     // Initially, only the start node is known.\n//     // This is usually implemented as a min-heap or priority queue rather than a hash-set.\n//     openSet := {start}\n//     // For node n, cameFrom[n] is the node immediately preceding it on the cheapest path from start\n//     // to n currently known.\n//     cameFrom := an empty map\n//     // For node n, gScore[n] is the cost of the cheapest path from start to n currently known.\n//     gScore := map with default value of Infinity\n//     gScore[start] := 0\n//     // For node n, fScore[n] := gScore[n] + h(n). fScore[n] represents our current best guess as to\n//     // how short a path from start to finish can be if it goes through n.\n//     fScore := map with default value of Infinity\n//     fScore[start] := h(start)\n//     while openSet is not empty\n//         // This operation can occur in O(1) time if openSet is a min-heap or a priority queue\n//         current := the node in openSet having the lowest fScore[] value\n//         if current = goal\n//             return reconstruct_path(cameFrom, current)\n//         openSet.Remove(current)\n//         for each neighbor of current\n//             // d(current,neighbor) is the weight of the edge from current to neighbor\n//             // tentative_gScore is the distance from start to the neighbor through current\n//             tentative_gScore := gScore[current] + d(current, neighbor)\n//             if tentative_gScore < gScore[neighbor]\n//                 // This path to neighbor is better than any previous one. Record it!\n//                 cameFrom[neighbor] := current\n//                 gScore[neighbor] := tentative_gScore\n//                 fScore[neighbor] := gScore[neighbor] + h(neighbor)\n//                 if neighbor not in openSet\n//                     openSet.add(neighbor)\n//     // Open set is empty but goal was never reached\n//     return failure\nimport shallowCopy from \"../../../helpers/2d-array-functions/shallow-copy\";\nimport { checkNeighbors } from \"./async-helpers/check-neighbors\";\nimport { updateParent } from \"./setters-and-getters/update-parent\";\nexport default function aStar(start_coordinates = [0, 0], end_cordinates = [3, 3], adjacency_matrix = [[]]) {\n  let queue = [];\n  let parent_matrix = shallowCopy(adjacency_matrix, null);\n  let final_cost_matrix = shallowCopy(adjacency_matrix, Infinity);\n  let visited = shallowCopy(adjacency_matrix, false);\n  queue.push([Infinity, [...start_coordinates]]);\n\n  while (queue.lenth !== 0) {\n    let f_cost,\n        current_vertex_coordinates = queue.shift(); // let g_cost = manhattanDistance(current_vertex_coordinates, start_coordinates);\n    // let h_cost = manhattanDistance(current_vertex_coordinates, end_cordinates);\n\n    const generator = checkNeighbors(current_vertex_coordinates, visited);\n    let result = generator.next();\n\n    while (!result.done) {\n      let value = result.value; // updatetoVisited(value, visited);\n\n      updateParent(current_vertex_coordinates, value, parent_matrix);\n      queue.push(value);\n      result = generator.next();\n    }\n  }\n}\n\nfunction manhattanDistance(coordinates1 = [], coordinates2 = []) {\n  return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1]);\n}","map":{"version":3,"sources":["/home/steven/SWE/Code/path-finding-visualizer/src/algorithms/helpers/matrix-helpers/a-star.js"],"names":["shallowCopy","checkNeighbors","updateParent","aStar","start_coordinates","end_cordinates","adjacency_matrix","queue","parent_matrix","final_cost_matrix","Infinity","visited","push","lenth","f_cost","current_vertex_coordinates","shift","generator","result","next","done","value","manhattanDistance","coordinates1","coordinates2","Math","abs"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA,OAAOA,WAAP,MAAwB,kDAAxB;AACA,SAASC,cAAT,QAA+B,iCAA/B;AACA,SAASC,YAAT,QAA6B,qCAA7B;AAEA,eAAe,SAASC,KAAT,CAAeC,iBAAiB,GAAC,CAAC,CAAD,EAAG,CAAH,CAAjC,EAAwCC,cAAc,GAAC,CAAC,CAAD,EAAG,CAAH,CAAvD,EAA8DC,gBAAgB,GAAC,CAAC,EAAD,CAA/E,EACf;AACI,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,aAAa,GAAGR,WAAW,CAACM,gBAAD,EAAmB,IAAnB,CAA/B;AACA,MAAIG,iBAAiB,GAAGT,WAAW,CAACM,gBAAD,EAAmBI,QAAnB,CAAnC;AACA,MAAIC,OAAO,GAAGX,WAAW,CAACM,gBAAD,EAAmB,KAAnB,CAAzB;AACAC,EAAAA,KAAK,CAACK,IAAN,CAAW,CAACF,QAAD,EAAU,CAAC,GAAGN,iBAAJ,CAAV,CAAX;;AAEA,SAAMG,KAAK,CAACM,KAAN,KAAgB,CAAtB,EACA;AACI,QAAIC,MAAJ;AAAA,QAAYC,0BAA0B,GAAGR,KAAK,CAACS,KAAN,EAAzC,CADJ,CAEI;AACA;;AAIA,UAAMC,SAAS,GAAGhB,cAAc,CAACc,0BAAD,EAA6BJ,OAA7B,CAAhC;AACI,QAAIO,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAb;;AAEA,WAAO,CAACD,MAAM,CAACE,IAAf,EAAqB;AACjB,UAAIC,KAAK,GAAGH,MAAM,CAACG,KAAnB,CADiB,CAGb;;AACAnB,MAAAA,YAAY,CAACa,0BAAD,EAA4BM,KAA5B,EAAkCb,aAAlC,CAAZ;AACAD,MAAAA,KAAK,CAACK,IAAN,CAAWS,KAAX;AAEJH,MAAAA,MAAM,GAAGD,SAAS,CAACE,IAAV,EAAT;AACH;AACR;AAEJ;;AAED,SAASG,iBAAT,CAA2BC,YAAY,GAAE,EAAzC,EAA6CC,YAAY,GAAE,EAA3D,EACA;AACI,SAAOC,IAAI,CAACC,GAAL,CAASH,YAAY,CAAC,CAAD,CAAZ,GAAkBC,YAAY,CAAC,CAAD,CAAvC,IAA8CC,IAAI,CAACC,GAAL,CAASH,YAAY,CAAC,CAAD,CAAZ,GAAkBC,YAAY,CAAC,CAAD,CAAvC,CAArD;AACH","sourcesContent":["// function reconstruct_path(cameFrom, current)\n//     total_path := {current}\n//     while current in cameFrom.Keys:\n//         current := cameFrom[current]\n//         total_path.prepend(current)\n//     return total_path\n\n\n\n// // A* finds a path from start to goal.\n// // h is the heuristic function. h(n) estimates the cost to reach goal from node n.\n// function A_Star(start, goal, h)\n//     // The set of discovered nodes that may need to be (re-)expanded.\n//     // Initially, only the start node is known.\n//     // This is usually implemented as a min-heap or priority queue rather than a hash-set.\n//     openSet := {start}\n\n//     // For node n, cameFrom[n] is the node immediately preceding it on the cheapest path from start\n//     // to n currently known.\n//     cameFrom := an empty map\n\n//     // For node n, gScore[n] is the cost of the cheapest path from start to n currently known.\n//     gScore := map with default value of Infinity\n//     gScore[start] := 0\n\n//     // For node n, fScore[n] := gScore[n] + h(n). fScore[n] represents our current best guess as to\n//     // how short a path from start to finish can be if it goes through n.\n//     fScore := map with default value of Infinity\n//     fScore[start] := h(start)\n\n//     while openSet is not empty\n//         // This operation can occur in O(1) time if openSet is a min-heap or a priority queue\n//         current := the node in openSet having the lowest fScore[] value\n//         if current = goal\n//             return reconstruct_path(cameFrom, current)\n\n//         openSet.Remove(current)\n//         for each neighbor of current\n//             // d(current,neighbor) is the weight of the edge from current to neighbor\n//             // tentative_gScore is the distance from start to the neighbor through current\n//             tentative_gScore := gScore[current] + d(current, neighbor)\n//             if tentative_gScore < gScore[neighbor]\n//                 // This path to neighbor is better than any previous one. Record it!\n//                 cameFrom[neighbor] := current\n//                 gScore[neighbor] := tentative_gScore\n//                 fScore[neighbor] := gScore[neighbor] + h(neighbor)\n//                 if neighbor not in openSet\n//                     openSet.add(neighbor)\n\n//     // Open set is empty but goal was never reached\n//     return failure\nimport shallowCopy from \"../../../helpers/2d-array-functions/shallow-copy\"\nimport { checkNeighbors } from \"./async-helpers/check-neighbors\";\nimport { updateParent } from \"./setters-and-getters/update-parent\";\n\nexport default function aStar(start_coordinates=[0,0], end_cordinates=[3,3], adjacency_matrix=[[]])\n{\n    let queue = []\n    let parent_matrix = shallowCopy(adjacency_matrix, null);\n    let final_cost_matrix = shallowCopy(adjacency_matrix, Infinity);\n    let visited = shallowCopy(adjacency_matrix, false);\n    queue.push([Infinity,[...start_coordinates]]);\n\n    while(queue.lenth !== 0)\n    {\n        let f_cost ,current_vertex_coordinates = queue.shift();\n        // let g_cost = manhattanDistance(current_vertex_coordinates, start_coordinates);\n        // let h_cost = manhattanDistance(current_vertex_coordinates, end_cordinates);\n        \n\n\n        const generator = checkNeighbors(current_vertex_coordinates, visited);\n            let result = generator.next();\n\n            while (!result.done) {\n                let value = result.value\n\n                    // updatetoVisited(value, visited);\n                    updateParent(current_vertex_coordinates,value,parent_matrix);\n                    queue.push(value);\n\n                result = generator.next();\n            }\n    }\n\n}\n\nfunction manhattanDistance(coordinates1 =[], coordinates2 =[])\n{\n    return Math.abs(coordinates1[0] - coordinates2[0]) + Math.abs(coordinates1[1] - coordinates2[1])\n}"]},"metadata":{},"sourceType":"module"}